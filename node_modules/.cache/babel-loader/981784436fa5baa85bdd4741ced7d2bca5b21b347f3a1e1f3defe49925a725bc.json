{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useTheme } from '@mui/material/styles';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useForkRef from '@mui/utils/useForkRef';\nimport { getActiveElement } from '../../utils/utils';\nimport { getSectionVisibleValue, isAndroid } from './useField.utils';\nconst cleanString = dirtyString => dirtyString.replace(/[\\u2066\\u2067\\u2068\\u2069]/g, '');\nexport const addPositionPropertiesToSections = (sections, localizedDigits, isRTL) => {\n  let position = 0;\n  let positionInInput = isRTL ? 1 : 0;\n  const newSections = [];\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const renderedValue = getSectionVisibleValue(section, isRTL ? 'input-rtl' : 'input-ltr', localizedDigits);\n    const sectionStr = \"\".concat(section.startSeparator).concat(renderedValue).concat(section.endSeparator);\n    const sectionLength = cleanString(sectionStr).length;\n    const sectionLengthInInput = sectionStr.length;\n\n    // The ...InInput values consider the unicode characters but do include them in their indexes\n    const cleanedValue = cleanString(renderedValue);\n    const startInInput = positionInInput + (cleanedValue === '' ? 0 : renderedValue.indexOf(cleanedValue[0])) + section.startSeparator.length;\n    const endInInput = startInInput + cleanedValue.length;\n    newSections.push(_extends({}, section, {\n      start: position,\n      end: position + sectionLength,\n      startInInput,\n      endInInput\n    }));\n    position += sectionLength;\n    // Move position to the end of string associated to the current section\n    positionInInput += sectionLengthInInput;\n  }\n  return newSections;\n};\nexport const useFieldV6TextField = params => {\n  const theme = useTheme();\n  const isRTL = theme.direction === 'rtl';\n  const focusTimeoutRef = React.useRef();\n  const {\n    forwardedProps: {\n      onFocus,\n      onClick,\n      onPaste,\n      onBlur,\n      inputRef: inputRefProp,\n      placeholder: inPlaceholder\n    },\n    internalProps: {\n      readOnly = false\n    },\n    parsedSelectedSections,\n    activeSectionIndex,\n    state,\n    fieldValueManager,\n    valueManager,\n    applyCharacterEditing,\n    resetCharacterQuery,\n    updateSectionValue,\n    updateValueFromValueStr,\n    clearActiveSection,\n    clearValue,\n    setTempAndroidValueStr,\n    setSelectedSections,\n    getSectionsFromValue,\n    areAllSectionsEmpty,\n    localizedDigits\n  } = params;\n  const inputRef = React.useRef(null);\n  const handleRef = useForkRef(inputRefProp, inputRef);\n  const sections = React.useMemo(() => addPositionPropertiesToSections(state.sections, localizedDigits, isRTL), [state.sections, localizedDigits, isRTL]);\n  const interactions = React.useMemo(() => ({\n    syncSelectionToDOM: () => {\n      if (!inputRef.current) {\n        return;\n      }\n      if (parsedSelectedSections == null) {\n        if (inputRef.current.scrollLeft) {\n          // Ensure that input content is not marked as selected.\n          // setting selection range to 0 causes issues in Safari.\n          // https://bugs.webkit.org/show_bug.cgi?id=224425\n          inputRef.current.scrollLeft = 0;\n        }\n        return;\n      }\n\n      // On multi input range pickers we want to update selection range only for the active input\n      // This helps to avoid the focus jumping on Safari https://github.com/mui/mui-x/issues/9003\n      // because WebKit implements the `setSelectionRange` based on the spec: https://bugs.webkit.org/show_bug.cgi?id=224425\n      if (inputRef.current !== getActiveElement(document)) {\n        return;\n      }\n\n      // Fix scroll jumping on iOS browser: https://github.com/mui/mui-x/issues/8321\n      const currentScrollTop = inputRef.current.scrollTop;\n      if (parsedSelectedSections === 'all') {\n        inputRef.current.select();\n      } else {\n        const selectedSection = sections[parsedSelectedSections];\n        const selectionStart = selectedSection.type === 'empty' ? selectedSection.startInInput - selectedSection.startSeparator.length : selectedSection.startInInput;\n        const selectionEnd = selectedSection.type === 'empty' ? selectedSection.endInInput + selectedSection.endSeparator.length : selectedSection.endInInput;\n        if (selectionStart !== inputRef.current.selectionStart || selectionEnd !== inputRef.current.selectionEnd) {\n          if (inputRef.current === getActiveElement(document)) {\n            inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n          }\n        }\n      }\n\n      // Even reading this variable seems to do the trick, but also setting it just to make use of it\n      inputRef.current.scrollTop = currentScrollTop;\n    },\n    getActiveSectionIndexFromDOM: () => {\n      var _inputRef$current$sel, _inputRef$current$sel2, _inputRef$current;\n      const browserStartIndex = (_inputRef$current$sel = inputRef.current.selectionStart) !== null && _inputRef$current$sel !== void 0 ? _inputRef$current$sel : 0;\n      const browserEndIndex = (_inputRef$current$sel2 = inputRef.current.selectionEnd) !== null && _inputRef$current$sel2 !== void 0 ? _inputRef$current$sel2 : 0;\n      const isInputReadOnly = !!((_inputRef$current = inputRef.current) !== null && _inputRef$current !== void 0 && _inputRef$current.readOnly);\n      if (browserStartIndex === 0 && browserEndIndex === 0 || isInputReadOnly) {\n        return null;\n      }\n      const nextSectionIndex = browserStartIndex <= sections[0].startInInput ? 1 // Special case if browser index is in invisible characters at the beginning.\n      : sections.findIndex(section => section.startInInput - section.startSeparator.length > browserStartIndex);\n      return nextSectionIndex === -1 ? sections.length - 1 : nextSectionIndex - 1;\n    },\n    focusField: function () {\n      var _inputRef$current2;\n      let newSelectedSection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.focus();\n      setSelectedSections(newSelectedSection);\n    },\n    setSelectedSections: newSelectedSections => setSelectedSections(newSelectedSections),\n    isFieldFocused: () => inputRef.current === getActiveElement(document)\n  }), [inputRef, parsedSelectedSections, sections, setSelectedSections]);\n  const syncSelectionFromDOM = () => {\n    var _inputRef$current$sel3;\n    if (readOnly) {\n      setSelectedSections(null);\n      return;\n    }\n    const browserStartIndex = (_inputRef$current$sel3 = inputRef.current.selectionStart) !== null && _inputRef$current$sel3 !== void 0 ? _inputRef$current$sel3 : 0;\n    let nextSectionIndex;\n    if (browserStartIndex <= sections[0].startInInput) {\n      // Special case if browser index is in invisible characters at the beginning\n      nextSectionIndex = 1;\n    } else if (browserStartIndex >= sections[sections.length - 1].endInInput) {\n      // If the click is after the last character of the input, then we want to select the 1st section.\n      nextSectionIndex = 1;\n    } else {\n      nextSectionIndex = sections.findIndex(section => section.startInInput - section.startSeparator.length > browserStartIndex);\n    }\n    const sectionIndex = nextSectionIndex === -1 ? sections.length - 1 : nextSectionIndex - 1;\n    setSelectedSections(sectionIndex);\n  };\n  const handleInputFocus = useEventCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    onFocus === null || onFocus === void 0 || onFocus(...args);\n    // The ref is guaranteed to be resolved at this point.\n    const input = inputRef.current;\n    clearTimeout(focusTimeoutRef.current);\n    focusTimeoutRef.current = setTimeout(() => {\n      // The ref changed, the component got remounted, the focus event is no longer relevant.\n      if (!input || input !== inputRef.current) {\n        return;\n      }\n      if (activeSectionIndex != null || readOnly) {\n        return;\n      }\n      if (\n      // avoid selecting all sections when focusing empty field without value\n      input.value.length && Number(input.selectionEnd) - Number(input.selectionStart) === input.value.length) {\n        setSelectedSections('all');\n      } else {\n        syncSelectionFromDOM();\n      }\n    });\n  });\n  const handleInputClick = useEventCallback(function (event) {\n    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.\n    // We avoid this by checking if the call of `handleInputClick` is actually intended, or a side effect.\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    onClick === null || onClick === void 0 || onClick(event, ...args);\n    syncSelectionFromDOM();\n  });\n  const handleInputPaste = useEventCallback(event => {\n    onPaste === null || onPaste === void 0 || onPaste(event);\n\n    // prevent default to avoid the input `onChange` handler being called\n    event.preventDefault();\n    if (readOnly) {\n      return;\n    }\n    const pastedValue = event.clipboardData.getData('text');\n    if (typeof parsedSelectedSections === 'number') {\n      const activeSection = state.sections[parsedSelectedSections];\n      const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);\n      const digitsOnly = /^[0-9]+$/.test(pastedValue);\n      const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);\n      const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly || activeSection.contentType === 'digit-with-letter' && digitsAndLetterOnly;\n      if (isValidPastedValue) {\n        resetCharacterQuery();\n        updateSectionValue({\n          activeSection,\n          newSectionValue: pastedValue,\n          shouldGoToNextSection: true\n        });\n        return;\n      }\n      if (lettersOnly || digitsOnly) {\n        // The pasted value corresponds to a single section, but not the expected type,\n        // skip the modification\n        return;\n      }\n    }\n    resetCharacterQuery();\n    updateValueFromValueStr(pastedValue);\n  });\n  const handleContainerBlur = useEventCallback(function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    onBlur === null || onBlur === void 0 || onBlur(...args);\n    setSelectedSections(null);\n  });\n  const handleInputChange = useEventCallback(event => {\n    if (readOnly) {\n      return;\n    }\n    const targetValue = event.target.value;\n    if (targetValue === '') {\n      resetCharacterQuery();\n      clearValue();\n      return;\n    }\n    const eventData = event.nativeEvent.data;\n    // Calling `.fill(04/11/2022)` in playwright will trigger a change event with the requested content to insert in `event.nativeEvent.data`\n    // usual changes have only the currently typed character in the `event.nativeEvent.data`\n    const shouldUseEventData = eventData && eventData.length > 1;\n    const valueStr = shouldUseEventData ? eventData : targetValue;\n    const cleanValueStr = cleanString(valueStr);\n\n    // If no section is selected or eventData should be used, we just try to parse the new value\n    // This line is mostly triggered by imperative code / application tests.\n    if (activeSectionIndex == null || shouldUseEventData) {\n      updateValueFromValueStr(shouldUseEventData ? eventData : cleanValueStr);\n      return;\n    }\n    let keyPressed;\n    if (parsedSelectedSections === 'all' && cleanValueStr.length === 1) {\n      keyPressed = cleanValueStr;\n    } else {\n      const prevValueStr = cleanString(fieldValueManager.getV6InputValueFromSections(sections, localizedDigits, isRTL));\n      let startOfDiffIndex = -1;\n      let endOfDiffIndex = -1;\n      for (let i = 0; i < prevValueStr.length; i += 1) {\n        if (startOfDiffIndex === -1 && prevValueStr[i] !== cleanValueStr[i]) {\n          startOfDiffIndex = i;\n        }\n        if (endOfDiffIndex === -1 && prevValueStr[prevValueStr.length - i - 1] !== cleanValueStr[cleanValueStr.length - i - 1]) {\n          endOfDiffIndex = i;\n        }\n      }\n      const activeSection = sections[activeSectionIndex];\n      const hasDiffOutsideOfActiveSection = startOfDiffIndex < activeSection.start || prevValueStr.length - endOfDiffIndex - 1 > activeSection.end;\n      if (hasDiffOutsideOfActiveSection) {\n        // TODO: Support if the new date is valid\n        return;\n      }\n\n      // The active section being selected, the browser has replaced its value with the key pressed by the user.\n      const activeSectionEndRelativeToNewValue = cleanValueStr.length - prevValueStr.length + activeSection.end - cleanString(activeSection.endSeparator || '').length;\n      keyPressed = cleanValueStr.slice(activeSection.start + cleanString(activeSection.startSeparator || '').length, activeSectionEndRelativeToNewValue);\n    }\n    if (keyPressed.length === 0) {\n      if (isAndroid()) {\n        setTempAndroidValueStr(valueStr);\n      } else {\n        resetCharacterQuery();\n        clearActiveSection();\n      }\n      return;\n    }\n    applyCharacterEditing({\n      keyPressed,\n      sectionIndex: activeSectionIndex\n    });\n  });\n  const placeholder = React.useMemo(() => {\n    if (inPlaceholder !== undefined) {\n      return inPlaceholder;\n    }\n    return fieldValueManager.getV6InputValueFromSections(getSectionsFromValue(valueManager.emptyValue), localizedDigits, isRTL);\n  }, [inPlaceholder, fieldValueManager, getSectionsFromValue, valueManager.emptyValue, localizedDigits, isRTL]);\n  const valueStr = React.useMemo(() => {\n    var _state$tempValueStrAn;\n    return (_state$tempValueStrAn = state.tempValueStrAndroid) !== null && _state$tempValueStrAn !== void 0 ? _state$tempValueStrAn : fieldValueManager.getV6InputValueFromSections(state.sections, localizedDigits, isRTL);\n  }, [state.sections, fieldValueManager, state.tempValueStrAndroid, localizedDigits, isRTL]);\n  React.useEffect(() => {\n    // Select all the sections when focused on mount (`autoFocus = true` on the input)\n    if (inputRef.current && inputRef.current === getActiveElement(document)) {\n      setSelectedSections('all');\n    }\n    return () => {\n      clearTimeout(focusTimeoutRef.current);\n    };\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const inputMode = React.useMemo(() => {\n    if (activeSectionIndex == null) {\n      return 'text';\n    }\n    if (state.sections[activeSectionIndex].contentType === 'letter') {\n      return 'text';\n    }\n    return 'numeric';\n  }, [activeSectionIndex, state.sections]);\n  const inputHasFocus = inputRef.current && inputRef.current === getActiveElement(document);\n  const shouldShowPlaceholder = !inputHasFocus && areAllSectionsEmpty;\n  return {\n    interactions,\n    returnedValue: {\n      // Forwarded\n      readOnly,\n      onBlur: handleContainerBlur,\n      onClick: handleInputClick,\n      onFocus: handleInputFocus,\n      onPaste: handleInputPaste,\n      inputRef: handleRef,\n      // Additional\n      enableAccessibleFieldDOMStructure: false,\n      placeholder,\n      inputMode,\n      autoComplete: 'off',\n      value: shouldShowPlaceholder ? '' : valueStr,\n      onChange: handleInputChange\n    }\n  };\n};","map":{"version":3,"names":["_extends","React","useTheme","useEventCallback","useForkRef","getActiveElement","getSectionVisibleValue","isAndroid","cleanString","dirtyString","replace","addPositionPropertiesToSections","sections","localizedDigits","isRTL","position","positionInInput","newSections","i","length","section","renderedValue","sectionStr","concat","startSeparator","endSeparator","sectionLength","sectionLengthInInput","cleanedValue","startInInput","indexOf","endInInput","push","start","end","useFieldV6TextField","params","theme","direction","focusTimeoutRef","useRef","forwardedProps","onFocus","onClick","onPaste","onBlur","inputRef","inputRefProp","placeholder","inPlaceholder","internalProps","readOnly","parsedSelectedSections","activeSectionIndex","state","fieldValueManager","valueManager","applyCharacterEditing","resetCharacterQuery","updateSectionValue","updateValueFromValueStr","clearActiveSection","clearValue","setTempAndroidValueStr","setSelectedSections","getSectionsFromValue","areAllSectionsEmpty","handleRef","useMemo","interactions","syncSelectionToDOM","current","scrollLeft","document","currentScrollTop","scrollTop","select","selectedSection","selectionStart","type","selectionEnd","setSelectionRange","getActiveSectionIndexFromDOM","_inputRef$current$sel","_inputRef$current$sel2","_inputRef$current","browserStartIndex","browserEndIndex","isInputReadOnly","nextSectionIndex","findIndex","focusField","_inputRef$current2","newSelectedSection","arguments","undefined","focus","newSelectedSections","isFieldFocused","syncSelectionFromDOM","_inputRef$current$sel3","sectionIndex","handleInputFocus","_len","args","Array","_key","input","clearTimeout","setTimeout","value","Number","handleInputClick","event","isDefaultPrevented","_len2","_key2","handleInputPaste","preventDefault","pastedValue","clipboardData","getData","activeSection","lettersOnly","test","digitsOnly","digitsAndLetterOnly","isValidPastedValue","contentType","newSectionValue","shouldGoToNextSection","handleContainerBlur","_len3","_key3","handleInputChange","targetValue","target","eventData","nativeEvent","data","shouldUseEventData","valueStr","cleanValueStr","keyPressed","prevValueStr","getV6InputValueFromSections","startOfDiffIndex","endOfDiffIndex","hasDiffOutsideOfActiveSection","activeSectionEndRelativeToNewValue","slice","emptyValue","_state$tempValueStrAn","tempValueStrAndroid","useEffect","inputMode","inputHasFocus","shouldShowPlaceholder","returnedValue","enableAccessibleFieldDOMStructure","autoComplete","onChange"],"sources":["/Users/khangdo/Documents/Best Fit College/react code/best_fit_colleges/node_modules/@mui/x-date-pickers/internals/hooks/useField/useFieldV6TextField.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useTheme } from '@mui/material/styles';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useForkRef from '@mui/utils/useForkRef';\nimport { getActiveElement } from '../../utils/utils';\nimport { getSectionVisibleValue, isAndroid } from './useField.utils';\nconst cleanString = dirtyString => dirtyString.replace(/[\\u2066\\u2067\\u2068\\u2069]/g, '');\nexport const addPositionPropertiesToSections = (sections, localizedDigits, isRTL) => {\n  let position = 0;\n  let positionInInput = isRTL ? 1 : 0;\n  const newSections = [];\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const renderedValue = getSectionVisibleValue(section, isRTL ? 'input-rtl' : 'input-ltr', localizedDigits);\n    const sectionStr = `${section.startSeparator}${renderedValue}${section.endSeparator}`;\n    const sectionLength = cleanString(sectionStr).length;\n    const sectionLengthInInput = sectionStr.length;\n\n    // The ...InInput values consider the unicode characters but do include them in their indexes\n    const cleanedValue = cleanString(renderedValue);\n    const startInInput = positionInInput + (cleanedValue === '' ? 0 : renderedValue.indexOf(cleanedValue[0])) + section.startSeparator.length;\n    const endInInput = startInInput + cleanedValue.length;\n    newSections.push(_extends({}, section, {\n      start: position,\n      end: position + sectionLength,\n      startInInput,\n      endInInput\n    }));\n    position += sectionLength;\n    // Move position to the end of string associated to the current section\n    positionInInput += sectionLengthInInput;\n  }\n  return newSections;\n};\nexport const useFieldV6TextField = params => {\n  const theme = useTheme();\n  const isRTL = theme.direction === 'rtl';\n  const focusTimeoutRef = React.useRef();\n  const {\n    forwardedProps: {\n      onFocus,\n      onClick,\n      onPaste,\n      onBlur,\n      inputRef: inputRefProp,\n      placeholder: inPlaceholder\n    },\n    internalProps: {\n      readOnly = false\n    },\n    parsedSelectedSections,\n    activeSectionIndex,\n    state,\n    fieldValueManager,\n    valueManager,\n    applyCharacterEditing,\n    resetCharacterQuery,\n    updateSectionValue,\n    updateValueFromValueStr,\n    clearActiveSection,\n    clearValue,\n    setTempAndroidValueStr,\n    setSelectedSections,\n    getSectionsFromValue,\n    areAllSectionsEmpty,\n    localizedDigits\n  } = params;\n  const inputRef = React.useRef(null);\n  const handleRef = useForkRef(inputRefProp, inputRef);\n  const sections = React.useMemo(() => addPositionPropertiesToSections(state.sections, localizedDigits, isRTL), [state.sections, localizedDigits, isRTL]);\n  const interactions = React.useMemo(() => ({\n    syncSelectionToDOM: () => {\n      if (!inputRef.current) {\n        return;\n      }\n      if (parsedSelectedSections == null) {\n        if (inputRef.current.scrollLeft) {\n          // Ensure that input content is not marked as selected.\n          // setting selection range to 0 causes issues in Safari.\n          // https://bugs.webkit.org/show_bug.cgi?id=224425\n          inputRef.current.scrollLeft = 0;\n        }\n        return;\n      }\n\n      // On multi input range pickers we want to update selection range only for the active input\n      // This helps to avoid the focus jumping on Safari https://github.com/mui/mui-x/issues/9003\n      // because WebKit implements the `setSelectionRange` based on the spec: https://bugs.webkit.org/show_bug.cgi?id=224425\n      if (inputRef.current !== getActiveElement(document)) {\n        return;\n      }\n\n      // Fix scroll jumping on iOS browser: https://github.com/mui/mui-x/issues/8321\n      const currentScrollTop = inputRef.current.scrollTop;\n      if (parsedSelectedSections === 'all') {\n        inputRef.current.select();\n      } else {\n        const selectedSection = sections[parsedSelectedSections];\n        const selectionStart = selectedSection.type === 'empty' ? selectedSection.startInInput - selectedSection.startSeparator.length : selectedSection.startInInput;\n        const selectionEnd = selectedSection.type === 'empty' ? selectedSection.endInInput + selectedSection.endSeparator.length : selectedSection.endInInput;\n        if (selectionStart !== inputRef.current.selectionStart || selectionEnd !== inputRef.current.selectionEnd) {\n          if (inputRef.current === getActiveElement(document)) {\n            inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n          }\n        }\n      }\n\n      // Even reading this variable seems to do the trick, but also setting it just to make use of it\n      inputRef.current.scrollTop = currentScrollTop;\n    },\n    getActiveSectionIndexFromDOM: () => {\n      const browserStartIndex = inputRef.current.selectionStart ?? 0;\n      const browserEndIndex = inputRef.current.selectionEnd ?? 0;\n      const isInputReadOnly = !!inputRef.current?.readOnly;\n      if (browserStartIndex === 0 && browserEndIndex === 0 || isInputReadOnly) {\n        return null;\n      }\n      const nextSectionIndex = browserStartIndex <= sections[0].startInInput ? 1 // Special case if browser index is in invisible characters at the beginning.\n      : sections.findIndex(section => section.startInInput - section.startSeparator.length > browserStartIndex);\n      return nextSectionIndex === -1 ? sections.length - 1 : nextSectionIndex - 1;\n    },\n    focusField: (newSelectedSection = 0) => {\n      inputRef.current?.focus();\n      setSelectedSections(newSelectedSection);\n    },\n    setSelectedSections: newSelectedSections => setSelectedSections(newSelectedSections),\n    isFieldFocused: () => inputRef.current === getActiveElement(document)\n  }), [inputRef, parsedSelectedSections, sections, setSelectedSections]);\n  const syncSelectionFromDOM = () => {\n    if (readOnly) {\n      setSelectedSections(null);\n      return;\n    }\n    const browserStartIndex = inputRef.current.selectionStart ?? 0;\n    let nextSectionIndex;\n    if (browserStartIndex <= sections[0].startInInput) {\n      // Special case if browser index is in invisible characters at the beginning\n      nextSectionIndex = 1;\n    } else if (browserStartIndex >= sections[sections.length - 1].endInInput) {\n      // If the click is after the last character of the input, then we want to select the 1st section.\n      nextSectionIndex = 1;\n    } else {\n      nextSectionIndex = sections.findIndex(section => section.startInInput - section.startSeparator.length > browserStartIndex);\n    }\n    const sectionIndex = nextSectionIndex === -1 ? sections.length - 1 : nextSectionIndex - 1;\n    setSelectedSections(sectionIndex);\n  };\n  const handleInputFocus = useEventCallback((...args) => {\n    onFocus?.(...args);\n    // The ref is guaranteed to be resolved at this point.\n    const input = inputRef.current;\n    clearTimeout(focusTimeoutRef.current);\n    focusTimeoutRef.current = setTimeout(() => {\n      // The ref changed, the component got remounted, the focus event is no longer relevant.\n      if (!input || input !== inputRef.current) {\n        return;\n      }\n      if (activeSectionIndex != null || readOnly) {\n        return;\n      }\n      if (\n      // avoid selecting all sections when focusing empty field without value\n      input.value.length && Number(input.selectionEnd) - Number(input.selectionStart) === input.value.length) {\n        setSelectedSections('all');\n      } else {\n        syncSelectionFromDOM();\n      }\n    });\n  });\n  const handleInputClick = useEventCallback((event, ...args) => {\n    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.\n    // We avoid this by checking if the call of `handleInputClick` is actually intended, or a side effect.\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n    onClick?.(event, ...args);\n    syncSelectionFromDOM();\n  });\n  const handleInputPaste = useEventCallback(event => {\n    onPaste?.(event);\n\n    // prevent default to avoid the input `onChange` handler being called\n    event.preventDefault();\n    if (readOnly) {\n      return;\n    }\n    const pastedValue = event.clipboardData.getData('text');\n    if (typeof parsedSelectedSections === 'number') {\n      const activeSection = state.sections[parsedSelectedSections];\n      const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);\n      const digitsOnly = /^[0-9]+$/.test(pastedValue);\n      const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);\n      const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly || activeSection.contentType === 'digit-with-letter' && digitsAndLetterOnly;\n      if (isValidPastedValue) {\n        resetCharacterQuery();\n        updateSectionValue({\n          activeSection,\n          newSectionValue: pastedValue,\n          shouldGoToNextSection: true\n        });\n        return;\n      }\n      if (lettersOnly || digitsOnly) {\n        // The pasted value corresponds to a single section, but not the expected type,\n        // skip the modification\n        return;\n      }\n    }\n    resetCharacterQuery();\n    updateValueFromValueStr(pastedValue);\n  });\n  const handleContainerBlur = useEventCallback((...args) => {\n    onBlur?.(...args);\n    setSelectedSections(null);\n  });\n  const handleInputChange = useEventCallback(event => {\n    if (readOnly) {\n      return;\n    }\n    const targetValue = event.target.value;\n    if (targetValue === '') {\n      resetCharacterQuery();\n      clearValue();\n      return;\n    }\n    const eventData = event.nativeEvent.data;\n    // Calling `.fill(04/11/2022)` in playwright will trigger a change event with the requested content to insert in `event.nativeEvent.data`\n    // usual changes have only the currently typed character in the `event.nativeEvent.data`\n    const shouldUseEventData = eventData && eventData.length > 1;\n    const valueStr = shouldUseEventData ? eventData : targetValue;\n    const cleanValueStr = cleanString(valueStr);\n\n    // If no section is selected or eventData should be used, we just try to parse the new value\n    // This line is mostly triggered by imperative code / application tests.\n    if (activeSectionIndex == null || shouldUseEventData) {\n      updateValueFromValueStr(shouldUseEventData ? eventData : cleanValueStr);\n      return;\n    }\n    let keyPressed;\n    if (parsedSelectedSections === 'all' && cleanValueStr.length === 1) {\n      keyPressed = cleanValueStr;\n    } else {\n      const prevValueStr = cleanString(fieldValueManager.getV6InputValueFromSections(sections, localizedDigits, isRTL));\n      let startOfDiffIndex = -1;\n      let endOfDiffIndex = -1;\n      for (let i = 0; i < prevValueStr.length; i += 1) {\n        if (startOfDiffIndex === -1 && prevValueStr[i] !== cleanValueStr[i]) {\n          startOfDiffIndex = i;\n        }\n        if (endOfDiffIndex === -1 && prevValueStr[prevValueStr.length - i - 1] !== cleanValueStr[cleanValueStr.length - i - 1]) {\n          endOfDiffIndex = i;\n        }\n      }\n      const activeSection = sections[activeSectionIndex];\n      const hasDiffOutsideOfActiveSection = startOfDiffIndex < activeSection.start || prevValueStr.length - endOfDiffIndex - 1 > activeSection.end;\n      if (hasDiffOutsideOfActiveSection) {\n        // TODO: Support if the new date is valid\n        return;\n      }\n\n      // The active section being selected, the browser has replaced its value with the key pressed by the user.\n      const activeSectionEndRelativeToNewValue = cleanValueStr.length - prevValueStr.length + activeSection.end - cleanString(activeSection.endSeparator || '').length;\n      keyPressed = cleanValueStr.slice(activeSection.start + cleanString(activeSection.startSeparator || '').length, activeSectionEndRelativeToNewValue);\n    }\n    if (keyPressed.length === 0) {\n      if (isAndroid()) {\n        setTempAndroidValueStr(valueStr);\n      } else {\n        resetCharacterQuery();\n        clearActiveSection();\n      }\n      return;\n    }\n    applyCharacterEditing({\n      keyPressed,\n      sectionIndex: activeSectionIndex\n    });\n  });\n  const placeholder = React.useMemo(() => {\n    if (inPlaceholder !== undefined) {\n      return inPlaceholder;\n    }\n    return fieldValueManager.getV6InputValueFromSections(getSectionsFromValue(valueManager.emptyValue), localizedDigits, isRTL);\n  }, [inPlaceholder, fieldValueManager, getSectionsFromValue, valueManager.emptyValue, localizedDigits, isRTL]);\n  const valueStr = React.useMemo(() => state.tempValueStrAndroid ?? fieldValueManager.getV6InputValueFromSections(state.sections, localizedDigits, isRTL), [state.sections, fieldValueManager, state.tempValueStrAndroid, localizedDigits, isRTL]);\n  React.useEffect(() => {\n    // Select all the sections when focused on mount (`autoFocus = true` on the input)\n    if (inputRef.current && inputRef.current === getActiveElement(document)) {\n      setSelectedSections('all');\n    }\n    return () => {\n      clearTimeout(focusTimeoutRef.current);\n    };\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const inputMode = React.useMemo(() => {\n    if (activeSectionIndex == null) {\n      return 'text';\n    }\n    if (state.sections[activeSectionIndex].contentType === 'letter') {\n      return 'text';\n    }\n    return 'numeric';\n  }, [activeSectionIndex, state.sections]);\n  const inputHasFocus = inputRef.current && inputRef.current === getActiveElement(document);\n  const shouldShowPlaceholder = !inputHasFocus && areAllSectionsEmpty;\n  return {\n    interactions,\n    returnedValue: {\n      // Forwarded\n      readOnly,\n      onBlur: handleContainerBlur,\n      onClick: handleInputClick,\n      onFocus: handleInputFocus,\n      onPaste: handleInputPaste,\n      inputRef: handleRef,\n      // Additional\n      enableAccessibleFieldDOMStructure: false,\n      placeholder,\n      inputMode,\n      autoComplete: 'off',\n      value: shouldShowPlaceholder ? '' : valueStr,\n      onChange: handleInputChange\n    }\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}