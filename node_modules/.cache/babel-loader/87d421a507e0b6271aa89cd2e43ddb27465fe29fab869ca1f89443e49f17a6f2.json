{"ast":null,"code":"import { flexRender as flexRender$1, createRow as createRow$1, sortingFns, aggregationFns, filterFns, getCoreRowModel, getExpandedRowModel, getFacetedMinMaxValues, getFacetedRowModel, getFacetedUniqueValues, getFilteredRowModel, getGroupedRowModel, getPaginationRowModel, getSortedRowModel, useReactTable } from '@tanstack/react-table';\nimport { useMemo, useState, useReducer, useRef, useEffect, useCallback, memo, Fragment as Fragment$1, useLayoutEffect } from 'react';\nimport { compareItems, rankItem, rankings } from '@tanstack/match-sorter-utils';\nimport { jsx, jsxs, Fragment } from 'react/jsx-runtime';\nimport IconButton from '@mui/material/IconButton';\nimport Tooltip from '@mui/material/Tooltip';\nimport Box from '@mui/material/Box';\nimport Button from '@mui/material/Button';\nimport CircularProgress from '@mui/material/CircularProgress';\nimport { lighten, darken, alpha, useTheme } from '@mui/material/styles';\nimport Menu from '@mui/material/Menu';\nimport ListItemIcon from '@mui/material/ListItemIcon';\nimport MenuItem from '@mui/material/MenuItem';\nimport Stack from '@mui/material/Stack';\nimport Checkbox from '@mui/material/Checkbox';\nimport Radio from '@mui/material/Radio';\nimport ArrowDownwardIcon from '@mui/icons-material/ArrowDownward';\nimport ArrowRightIcon from '@mui/icons-material/ArrowRight';\nimport CancelIcon from '@mui/icons-material/Cancel';\nimport ChevronLeftIcon from '@mui/icons-material/ChevronLeft';\nimport ChevronRightIcon from '@mui/icons-material/ChevronRight';\nimport ClearAllIcon from '@mui/icons-material/ClearAll';\nimport CloseIcon from '@mui/icons-material/Close';\nimport ContentCopy from '@mui/icons-material/ContentCopy';\nimport DensityLargeIcon from '@mui/icons-material/DensityLarge';\nimport DensityMediumIcon from '@mui/icons-material/DensityMedium';\nimport DensitySmallIcon from '@mui/icons-material/DensitySmall';\nimport DragHandleIcon from '@mui/icons-material/DragHandle';\nimport DynamicFeedIcon from '@mui/icons-material/DynamicFeed';\nimport EditIcon from '@mui/icons-material/Edit';\nimport ExpandMoreIcon from '@mui/icons-material/ExpandMore';\nimport FilterAltIcon from '@mui/icons-material/FilterAlt';\nimport FilterListIcon from '@mui/icons-material/FilterList';\nimport FilterListOffIcon from '@mui/icons-material/FilterListOff';\nimport FirstPageIcon from '@mui/icons-material/FirstPage';\nimport FullscreenIcon from '@mui/icons-material/Fullscreen';\nimport FullscreenExitIcon from '@mui/icons-material/FullscreenExit';\nimport KeyboardDoubleArrowDownIcon from '@mui/icons-material/KeyboardDoubleArrowDown';\nimport LastPageIcon from '@mui/icons-material/LastPage';\nimport MoreHorizIcon from '@mui/icons-material/MoreHoriz';\nimport MoreVertIcon from '@mui/icons-material/MoreVert';\nimport PushPinIcon from '@mui/icons-material/PushPin';\nimport RestartAltIcon from '@mui/icons-material/RestartAlt';\nimport SaveIcon from '@mui/icons-material/Save';\nimport SearchIcon from '@mui/icons-material/Search';\nimport SearchOffIcon from '@mui/icons-material/SearchOff';\nimport SortIcon from '@mui/icons-material/Sort';\nimport SyncAltIcon from '@mui/icons-material/SyncAlt';\nimport ViewColumnIcon from '@mui/icons-material/ViewColumn';\nimport VisibilityOffIcon from '@mui/icons-material/VisibilityOff';\nimport { defaultRangeExtractor, useVirtualizer } from '@tanstack/react-virtual';\nimport Paper from '@mui/material/Paper';\nimport { useTheme as useTheme$1 } from '@mui/material';\nimport TableContainer from '@mui/material/TableContainer';\nimport Table from '@mui/material/Table';\nimport TableBody from '@mui/material/TableBody';\nimport Typography from '@mui/material/Typography';\nimport TableRow from '@mui/material/TableRow';\nimport Skeleton from '@mui/material/Skeleton';\nimport TableCell from '@mui/material/TableCell';\nimport highlightWords from 'highlight-words';\nimport TextField from '@mui/material/TextField';\nimport Collapse from '@mui/material/Collapse';\nimport TableFooter from '@mui/material/TableFooter';\nimport TableHead from '@mui/material/TableHead';\nimport FormControlLabel from '@mui/material/FormControlLabel';\nimport Autocomplete from '@mui/material/Autocomplete';\nimport Chip from '@mui/material/Chip';\nimport InputAdornment from '@mui/material/InputAdornment';\nimport { debounce } from '@mui/material/utils';\nimport { DatePicker } from '@mui/x-date-pickers/DatePicker';\nimport { DateTimePicker } from '@mui/x-date-pickers/DateTimePicker';\nimport { TimePicker } from '@mui/x-date-pickers/TimePicker';\nimport FormHelperText from '@mui/material/FormHelperText';\nimport Slider from '@mui/material/Slider';\nimport Grow from '@mui/material/Grow';\nimport Popover from '@mui/material/Popover';\nimport Divider from '@mui/material/Divider';\nimport Badge from '@mui/material/Badge';\nimport TableSortLabel from '@mui/material/TableSortLabel';\nimport Alert from '@mui/material/Alert';\nimport AlertTitle from '@mui/material/AlertTitle';\nimport Dialog from '@mui/material/Dialog';\nimport DialogActions from '@mui/material/DialogActions';\nimport DialogContent from '@mui/material/DialogContent';\nimport DialogTitle from '@mui/material/DialogTitle';\nimport useMediaQuery from '@mui/material/useMediaQuery';\nimport LinearProgress from '@mui/material/LinearProgress';\nimport InputLabel from '@mui/material/InputLabel';\nimport Pagination from '@mui/material/Pagination';\nimport PaginationItem from '@mui/material/PaginationItem';\nimport Select from '@mui/material/Select';\nimport Fade from '@mui/material/Fade';\nimport Switch from '@mui/material/Switch';\nconst getColumnId = columnDef => {\n  var _a, _b, _c, _d;\n  return (_d = (_a = columnDef.id) !== null && _a !== void 0 ? _a : (_c = (_b = columnDef.accessorKey) === null || _b === void 0 ? void 0 : _b.toString) === null || _c === void 0 ? void 0 : _c.call(_b)) !== null && _d !== void 0 ? _d : columnDef.header;\n};\nconst getAllLeafColumnDefs = columns => {\n  const allLeafColumnDefs = [];\n  const getLeafColumns = cols => {\n    cols.forEach(col => {\n      if (col.columns) {\n        getLeafColumns(col.columns);\n      } else {\n        allLeafColumnDefs.push(col);\n      }\n    });\n  };\n  getLeafColumns(columns);\n  return allLeafColumnDefs;\n};\nconst prepareColumns = ({\n  columnDefs,\n  tableOptions\n}) => {\n  const {\n    aggregationFns = {},\n    defaultDisplayColumn,\n    filterFns = {},\n    sortingFns = {},\n    state: {\n      columnFilterFns = {}\n    } = {}\n  } = tableOptions;\n  return columnDefs.map(columnDef => {\n    var _a, _b;\n    //assign columnId\n    if (!columnDef.id) columnDef.id = getColumnId(columnDef);\n    //assign columnDefType\n    if (!columnDef.columnDefType) columnDef.columnDefType = 'data';\n    if ((_a = columnDef.columns) === null || _a === void 0 ? void 0 : _a.length) {\n      columnDef.columnDefType = 'group';\n      //recursively prepare columns if this is a group column\n      columnDef.columns = prepareColumns({\n        columnDefs: columnDef.columns,\n        tableOptions\n      });\n    } else if (columnDef.columnDefType === 'data') {\n      //assign aggregationFns if multiple aggregationFns are provided\n      if (Array.isArray(columnDef.aggregationFn)) {\n        const aggFns = columnDef.aggregationFn;\n        columnDef.aggregationFn = (columnId, leafRows, childRows) => aggFns.map(fn => {\n          var _a;\n          return (_a = aggregationFns[fn]) === null || _a === void 0 ? void 0 : _a.call(aggregationFns, columnId, leafRows, childRows);\n        });\n      }\n      //assign filterFns\n      if (Object.keys(filterFns).includes(columnFilterFns[columnDef.id])) {\n        columnDef.filterFn = (_b = filterFns[columnFilterFns[columnDef.id]]) !== null && _b !== void 0 ? _b : filterFns.fuzzy;\n        columnDef._filterFn = columnFilterFns[columnDef.id];\n      }\n      //assign sortingFns\n      if (Object.keys(sortingFns).includes(columnDef.sortingFn)) {\n        // @ts-ignore\n        columnDef.sortingFn = sortingFns[columnDef.sortingFn];\n      }\n    } else if (columnDef.columnDefType === 'display') {\n      columnDef = Object.assign(Object.assign({}, defaultDisplayColumn), columnDef);\n    }\n    return columnDef;\n  });\n};\nconst reorderColumn = (draggedColumn, targetColumn, columnOrder) => {\n  if (draggedColumn.getCanPin()) {\n    draggedColumn.pin(targetColumn.getIsPinned());\n  }\n  const newColumnOrder = [...columnOrder];\n  newColumnOrder.splice(newColumnOrder.indexOf(targetColumn.id), 0, newColumnOrder.splice(newColumnOrder.indexOf(draggedColumn.id), 1)[0]);\n  return newColumnOrder;\n};\nconst getDefaultColumnFilterFn = columnDef => {\n  const {\n    filterVariant\n  } = columnDef;\n  if (filterVariant === 'multi-select') return 'arrIncludesSome';\n  if (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.includes('range')) return 'betweenInclusive';\n  if (filterVariant === 'select' || filterVariant === 'checkbox') return 'equals';\n  return 'fuzzy';\n};\nconst getColumnFilterInfo = ({\n  header,\n  table\n}) => {\n  var _a;\n  const {\n    options: {\n      columnFilterModeOptions\n    }\n  } = table;\n  const {\n    column\n  } = header;\n  const {\n    columnDef\n  } = column;\n  const {\n    filterVariant\n  } = columnDef;\n  const isDateFilter = !!((filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.startsWith('date')) || (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.startsWith('time')));\n  const isAutocompleteFilter = filterVariant === 'autocomplete';\n  const isRangeFilter = (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.includes('range')) || ['between', 'betweenInclusive', 'inNumberRange'].includes(columnDef._filterFn);\n  const isSelectFilter = filterVariant === 'select';\n  const isMultiSelectFilter = filterVariant === 'multi-select';\n  const isTextboxFilter = ['autocomplete', 'text'].includes(filterVariant) || !isSelectFilter && !isMultiSelectFilter;\n  const currentFilterOption = columnDef._filterFn;\n  const allowedColumnFilterOptions = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _a !== void 0 ? _a : columnFilterModeOptions;\n  const facetedUniqueValues = column.getFacetedUniqueValues();\n  return {\n    allowedColumnFilterOptions,\n    currentFilterOption,\n    facetedUniqueValues,\n    isAutocompleteFilter,\n    isDateFilter,\n    isMultiSelectFilter,\n    isRangeFilter,\n    isSelectFilter,\n    isTextboxFilter\n  };\n};\nconst useDropdownOptions = ({\n  header,\n  table\n}) => {\n  const {\n    column\n  } = header;\n  const {\n    columnDef\n  } = column;\n  const {\n    facetedUniqueValues,\n    isAutocompleteFilter,\n    isMultiSelectFilter,\n    isSelectFilter\n  } = getColumnFilterInfo({\n    header,\n    table\n  });\n  return useMemo(() => {\n    var _a;\n    return (_a = columnDef.filterSelectOptions) !== null && _a !== void 0 ? _a : (isSelectFilter || isMultiSelectFilter || isAutocompleteFilter) && facetedUniqueValues ? Array.from(facetedUniqueValues.keys()).filter(value => value !== null && value !== undefined).sort((a, b) => a.localeCompare(b)) : undefined;\n  }, [columnDef.filterSelectOptions, facetedUniqueValues, isMultiSelectFilter, isSelectFilter]);\n};\nconst flexRender = flexRender$1;\nfunction createMRTColumnHelper() {\n  return {\n    accessor: (accessor, column) => {\n      return typeof accessor === 'function' ? Object.assign(Object.assign({}, column), {\n        accessorFn: accessor\n      }) : Object.assign(Object.assign({}, column), {\n        accessorKey: accessor\n      });\n    },\n    display: column => column,\n    group: column => column\n  };\n}\nconst createRow = (table, originalRow, rowIndex = -1, depth = 0, subRows, parentId) => createRow$1(table, 'mrt-row-create', originalRow !== null && originalRow !== void 0 ? originalRow : Object.assign({}, ...getAllLeafColumnDefs(table.options.columns).map(col => ({\n  [getColumnId(col)]: ''\n}))), rowIndex, depth, subRows, parentId);\nconst parseFromValuesOrFunc = (fn, arg) => fn instanceof Function ? fn(arg) : fn;\nconst getValueAndLabel = option => {\n  var _a, _b, _c;\n  let label = '';\n  let value = '';\n  if (option) {\n    if (typeof option !== 'object') {\n      label = option;\n      value = option;\n    } else {\n      label = (_b = (_a = option.label) !== null && _a !== void 0 ? _a : option.text) !== null && _b !== void 0 ? _b : option.value;\n      value = (_c = option.value) !== null && _c !== void 0 ? _c : label;\n    }\n  }\n  return {\n    label,\n    value\n  };\n};\nconst isCellEditable = ({\n  cell,\n  table\n}) => {\n  const {\n    enableEditing\n  } = table.options;\n  const {\n    column: {\n      columnDef\n    },\n    row\n  } = cell;\n  return !cell.getIsPlaceholder() && parseFromValuesOrFunc(enableEditing, row) && parseFromValuesOrFunc(columnDef.enableEditing, row) !== false;\n};\nconst openEditingCell = ({\n  cell,\n  table\n}) => {\n  const {\n    options: {\n      editDisplayMode\n    },\n    refs: {\n      editInputRefs\n    }\n  } = table;\n  const {\n    column\n  } = cell;\n  if (isCellEditable({\n    cell,\n    table\n  }) && editDisplayMode === 'cell') {\n    table.setEditingCell(cell);\n    queueMicrotask(() => {\n      var _a;\n      const textField = editInputRefs.current[column.id];\n      if (textField) {\n        textField.focus();\n        (_a = textField.select) === null || _a === void 0 ? void 0 : _a.call(textField);\n      }\n    });\n  }\n};\nfunction defaultDisplayColumnProps({\n  header,\n  id,\n  size,\n  tableOptions\n}) {\n  const {\n    defaultDisplayColumn,\n    displayColumnDefOptions,\n    localization\n  } = tableOptions;\n  return Object.assign(Object.assign(Object.assign(Object.assign({}, defaultDisplayColumn), {\n    header: header ? localization[header] : '',\n    size\n  }), displayColumnDefOptions === null || displayColumnDefOptions === void 0 ? void 0 : displayColumnDefOptions[id]), {\n    id\n  });\n}\nconst showRowPinningColumn = tableOptions => {\n  const {\n    enableRowPinning,\n    rowPinningDisplayMode\n  } = tableOptions;\n  return !!(enableRowPinning && !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.startsWith('select')));\n};\nconst showRowDragColumn = tableOptions => {\n  const {\n    enableRowDragging,\n    enableRowOrdering\n  } = tableOptions;\n  return !!(enableRowDragging || enableRowOrdering);\n};\nconst showRowExpandColumn = tableOptions => {\n  const {\n    enableExpanding,\n    enableGrouping,\n    renderDetailPanel,\n    state: {\n      grouping\n    }\n  } = tableOptions;\n  return !!(enableExpanding || enableGrouping && (grouping === null || grouping === void 0 ? void 0 : grouping.length) || renderDetailPanel);\n};\nconst showRowActionsColumn = tableOptions => {\n  const {\n    createDisplayMode,\n    editDisplayMode,\n    enableEditing,\n    enableRowActions,\n    state: {\n      creatingRow\n    }\n  } = tableOptions;\n  return !!(enableRowActions || creatingRow && createDisplayMode === 'row' || enableEditing && ['modal', 'row'].includes(editDisplayMode !== null && editDisplayMode !== void 0 ? editDisplayMode : ''));\n};\nconst showRowSelectionColumn = tableOptions => !!tableOptions.enableRowSelection;\nconst showRowNumbersColumn = tableOptions => !!tableOptions.enableRowNumbers;\nconst showRowSpacerColumn = tableOptions => tableOptions.layoutMode === 'grid-no-grow';\nconst getLeadingDisplayColumnIds = tableOptions => [showRowPinningColumn(tableOptions) && 'mrt-row-pin', showRowDragColumn(tableOptions) && 'mrt-row-drag', tableOptions.positionActionsColumn === 'first' && showRowActionsColumn(tableOptions) && 'mrt-row-actions', tableOptions.positionExpandColumn === 'first' && showRowExpandColumn(tableOptions) && 'mrt-row-expand', showRowSelectionColumn(tableOptions) && 'mrt-row-select', showRowNumbersColumn(tableOptions) && 'mrt-row-numbers'].filter(Boolean);\nconst getTrailingDisplayColumnIds = tableOptions => [tableOptions.positionActionsColumn === 'last' && showRowActionsColumn(tableOptions) && 'mrt-row-actions', tableOptions.positionExpandColumn === 'last' && showRowExpandColumn(tableOptions) && 'mrt-row-expand', showRowSpacerColumn(tableOptions) && 'mrt-row-spacer'].filter(Boolean);\nconst getDefaultColumnOrderIds = (tableOptions, reset = false) => {\n  const {\n    state: {\n      columnOrder: currentColumnOrderIds = []\n    }\n  } = tableOptions;\n  const leadingDisplayColIds = getLeadingDisplayColumnIds(tableOptions);\n  const trailingDisplayColIds = getTrailingDisplayColumnIds(tableOptions);\n  const defaultColumnDefIds = getAllLeafColumnDefs(tableOptions.columns).map(columnDef => getColumnId(columnDef));\n  let allLeafColumnDefIds = reset ? defaultColumnDefIds : Array.from(new Set([...currentColumnOrderIds, ...defaultColumnDefIds]));\n  allLeafColumnDefIds = allLeafColumnDefIds.filter(colId => !leadingDisplayColIds.includes(colId) && !trailingDisplayColIds.includes(colId));\n  return [...leadingDisplayColIds, ...allLeafColumnDefIds, ...trailingDisplayColIds];\n};\nconst fuzzy$1 = (rowA, rowB, columnId) => {\n  let dir = 0;\n  if (rowA.columnFiltersMeta[columnId]) {\n    dir = compareItems(rowA.columnFiltersMeta[columnId], rowB.columnFiltersMeta[columnId]);\n  }\n  // Provide a fallback for when the item ranks are equal\n  return dir === 0 ? sortingFns.alphanumeric(rowA, rowB, columnId) : dir;\n};\nconst MRT_SortingFns = Object.assign(Object.assign({}, sortingFns), {\n  fuzzy: fuzzy$1\n});\nconst rankGlobalFuzzy = (rowA, rowB) => Math.max(...Object.values(rowB.columnFiltersMeta).map(v => v.rank)) - Math.max(...Object.values(rowA.columnFiltersMeta).map(v => v.rank));\nconst getMRT_Rows = (table, all) => {\n  const {\n    getCenterRows,\n    getPrePaginationRowModel,\n    getRowModel,\n    getState,\n    getTopRows,\n    options: {\n      createDisplayMode,\n      enablePagination,\n      enableRowPinning,\n      manualPagination,\n      positionCreatingRow,\n      rowPinningDisplayMode\n    }\n  } = table;\n  const {\n    creatingRow,\n    pagination\n  } = getState();\n  const isRankingRows = getIsRankingRows(table);\n  let rows = [];\n  if (!isRankingRows) {\n    rows = !enableRowPinning || (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky')) ? all ? getPrePaginationRowModel().rows : getRowModel().rows : getCenterRows();\n  } else {\n    // fuzzy ranking adjustments\n    rows = getPrePaginationRowModel().rows.sort((a, b) => rankGlobalFuzzy(a, b));\n    if (enablePagination && !manualPagination && !all) {\n      const start = pagination.pageIndex * pagination.pageSize;\n      rows = rows.slice(start, start + pagination.pageSize);\n    }\n    if (enableRowPinning && !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky'))) {\n      // \"re-center-ize\" the rows (no top or bottom pinned rows unless sticky)\n      rows = rows.filter(row => !row.getIsPinned());\n    }\n  }\n  // row pinning adjustments\n  if (enableRowPinning && (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky'))) {\n    const centerPinnedRowIds = rows.filter(row => row.getIsPinned()).map(r => r.id);\n    rows = [...getTopRows().filter(row => !centerPinnedRowIds.includes(row.id)), ...rows];\n  }\n  // blank inserted creating row adjustments\n  if (positionCreatingRow !== undefined && creatingRow && createDisplayMode === 'row') {\n    const creatingRowIndex = !isNaN(+positionCreatingRow) ? +positionCreatingRow : positionCreatingRow === 'top' ? 0 : rows.length;\n    rows = [...rows.slice(0, creatingRowIndex), creatingRow, ...rows.slice(creatingRowIndex)];\n  }\n  return rows;\n};\nconst getCanRankRows = table => {\n  const {\n    getState,\n    options: {\n      enableGlobalFilterRankedResults,\n      manualExpanding,\n      manualFiltering,\n      manualGrouping,\n      manualSorting\n    }\n  } = table;\n  const {\n    expanded,\n    globalFilterFn\n  } = getState();\n  return !manualExpanding && !manualFiltering && !manualGrouping && !manualSorting && enableGlobalFilterRankedResults && globalFilterFn === 'fuzzy' && expanded !== true && !Object.values(expanded).some(Boolean);\n};\nconst getIsRankingRows = table => {\n  const {\n    globalFilter,\n    sorting\n  } = table.getState();\n  return getCanRankRows(table) && globalFilter && !Object.values(sorting).some(Boolean);\n};\nconst getIsRowSelected = ({\n  row,\n  table\n}) => {\n  const {\n    options: {\n      enableRowSelection\n    }\n  } = table;\n  return row.getIsSelected() || parseFromValuesOrFunc(enableRowSelection, row) && row.getCanSelectSubRows() && row.getIsAllSubRowsSelected();\n};\nconst getMRT_RowSelectionHandler = ({\n  row,\n  staticRowIndex = 0,\n  table\n}) => (event, value) => {\n  var _a;\n  const {\n    getState,\n    options: {\n      enableBatchRowSelection,\n      enableMultiRowSelection,\n      enableRowPinning,\n      manualPagination,\n      rowPinningDisplayMode\n    },\n    refs: {\n      lastSelectedRowId: lastSelectedRowId\n    }\n  } = table;\n  const {\n    pagination: {\n      pageIndex,\n      pageSize\n    }\n  } = getState();\n  const paginationOffset = manualPagination ? 0 : pageSize * pageIndex;\n  const wasCurrentRowChecked = getIsRowSelected({\n    row,\n    table\n  });\n  // toggle selection of this row\n  row.toggleSelected(value !== null && value !== void 0 ? value : !wasCurrentRowChecked);\n  const changedRowIds = new Set([row.id]);\n  // if shift key is pressed, select all rows between last selected and this one\n  if (enableBatchRowSelection && enableMultiRowSelection && event.nativeEvent.shiftKey && lastSelectedRowId.current !== null) {\n    const rows = getMRT_Rows(table, true);\n    const lastIndex = rows.findIndex(r => r.id === lastSelectedRowId.current);\n    if (lastIndex !== -1) {\n      const isLastIndexChecked = getIsRowSelected({\n        row: rows === null || rows === void 0 ? void 0 : rows[lastIndex],\n        table\n      });\n      const currentIndex = staticRowIndex + paginationOffset;\n      const [start, end] = lastIndex < currentIndex ? [lastIndex, currentIndex] : [currentIndex, lastIndex];\n      // toggle selection of all rows between last selected and this one\n      // but only if the last selected row is not the same as the current one\n      if (wasCurrentRowChecked !== isLastIndexChecked) {\n        for (let i = start; i <= end; i++) {\n          rows[i].toggleSelected(!wasCurrentRowChecked);\n          changedRowIds.add(rows[i].id);\n        }\n      }\n    }\n  }\n  // record the last selected row id\n  lastSelectedRowId.current = row.id;\n  // if all sub rows were selected, unselect them\n  if (row.getCanSelectSubRows() && row.getIsAllSubRowsSelected()) {\n    (_a = row.subRows) === null || _a === void 0 ? void 0 : _a.forEach(r => r.toggleSelected(false));\n  }\n  if (enableRowPinning && (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('select'))) {\n    changedRowIds.forEach(rowId => {\n      const rowToTogglePin = table.getRow(rowId);\n      rowToTogglePin.pin(!wasCurrentRowChecked //was not previously pinned or selected\n      ? (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('bottom')) ? 'bottom' : 'top' : false);\n    });\n  }\n};\nconst getMRT_SelectAllHandler = ({\n  table\n}) => (event, value, forceAll) => {\n  const {\n    options: {\n      enableRowPinning,\n      rowPinningDisplayMode,\n      selectAllMode\n    },\n    refs: {\n      lastSelectedRowId\n    }\n  } = table;\n  selectAllMode === 'all' || forceAll ? table.toggleAllRowsSelected(value !== null && value !== void 0 ? value : event.target.checked) : table.toggleAllPageRowsSelected(value !== null && value !== void 0 ? value : event.target.checked);\n  if (enableRowPinning && (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('select'))) {\n    table.setRowPinning({\n      bottom: [],\n      top: []\n    });\n  }\n  lastSelectedRowId.current = null;\n};\nconst MRT_AggregationFns = Object.assign({}, aggregationFns);\nconst fuzzy = (row, columnId, filterValue, addMeta) => {\n  const itemRank = rankItem(row.getValue(columnId), filterValue, {\n    threshold: rankings.MATCHES\n  });\n  addMeta(itemRank);\n  return itemRank.passed;\n};\nfuzzy.autoRemove = val => !val;\nconst contains = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim().includes(filterValue.toString().toLowerCase().trim());\ncontains.autoRemove = val => !val;\nconst startsWith = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim().startsWith(filterValue.toString().toLowerCase().trim());\nstartsWith.autoRemove = val => !val;\nconst endsWith = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim().endsWith(filterValue.toString().toLowerCase().trim());\nendsWith.autoRemove = val => !val;\nconst equals = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim() === (filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString().toLowerCase().trim());\nequals.autoRemove = val => !val;\nconst notEquals = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim() !== filterValue.toString().toLowerCase().trim();\nnotEquals.autoRemove = val => !val;\nconst greaterThan = (row, id, filterValue) => !isNaN(+filterValue) && !isNaN(+row.getValue(id)) ? +row.getValue(id) > +filterValue : row.getValue(id).toString().toLowerCase().trim() > (filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString().toLowerCase().trim());\ngreaterThan.autoRemove = val => !val;\nconst greaterThanOrEqualTo = (row, id, filterValue) => equals(row, id, filterValue) || greaterThan(row, id, filterValue);\ngreaterThanOrEqualTo.autoRemove = val => !val;\nconst lessThan = (row, id, filterValue) => !isNaN(+filterValue) && !isNaN(+row.getValue(id)) ? +row.getValue(id) < +filterValue : row.getValue(id).toString().toLowerCase().trim() < (filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString().toLowerCase().trim());\nlessThan.autoRemove = val => !val;\nconst lessThanOrEqualTo = (row, id, filterValue) => equals(row, id, filterValue) || lessThan(row, id, filterValue);\nlessThanOrEqualTo.autoRemove = val => !val;\nconst between = (row, id, filterValues) => (['', undefined].includes(filterValues[0]) || greaterThan(row, id, filterValues[0])) && (!isNaN(+filterValues[0]) && !isNaN(+filterValues[1]) && +filterValues[0] > +filterValues[1] || ['', undefined].includes(filterValues[1]) || lessThan(row, id, filterValues[1]));\nbetween.autoRemove = val => !val;\nconst betweenInclusive = (row, id, filterValues) => (['', undefined].includes(filterValues[0]) || greaterThanOrEqualTo(row, id, filterValues[0])) && (!isNaN(+filterValues[0]) && !isNaN(+filterValues[1]) && +filterValues[0] > +filterValues[1] || ['', undefined].includes(filterValues[1]) || lessThanOrEqualTo(row, id, filterValues[1]));\nbetweenInclusive.autoRemove = val => !val;\nconst empty = (row, id, _filterValue) => !row.getValue(id).toString().trim();\nempty.autoRemove = val => !val;\nconst notEmpty = (row, id, _filterValue) => !!row.getValue(id).toString().trim();\nnotEmpty.autoRemove = val => !val;\nconst MRT_FilterFns = Object.assign(Object.assign({}, filterFns), {\n  between,\n  betweenInclusive,\n  contains,\n  empty,\n  endsWith,\n  equals,\n  fuzzy,\n  greaterThan,\n  greaterThanOrEqualTo,\n  lessThan,\n  lessThanOrEqualTo,\n  notEmpty,\n  notEquals,\n  startsWith\n});\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nconst MRT_EditActionButtons = _a => {\n  var {\n      row,\n      table,\n      variant = 'icon'\n    } = _a,\n    rest = __rest(_a, [\"row\", \"table\", \"variant\"]);\n  const {\n    getState,\n    options: {\n      icons: {\n        CancelIcon,\n        SaveIcon\n      },\n      localization,\n      onCreatingRowCancel,\n      onCreatingRowSave,\n      onEditingRowCancel,\n      onEditingRowSave\n    },\n    refs: {\n      editInputRefs\n    },\n    setCreatingRow,\n    setEditingRow\n  } = table;\n  const {\n    creatingRow,\n    editingRow,\n    isSaving\n  } = getState();\n  const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;\n  const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;\n  const handleCancel = () => {\n    if (isCreating) {\n      onCreatingRowCancel === null || onCreatingRowCancel === void 0 ? void 0 : onCreatingRowCancel({\n        row,\n        table\n      });\n      setCreatingRow(null);\n    } else if (isEditing) {\n      onEditingRowCancel === null || onEditingRowCancel === void 0 ? void 0 : onEditingRowCancel({\n        row,\n        table\n      });\n      setEditingRow(null);\n    }\n    row._valuesCache = {}; //reset values cache\n  };\n  const handleSubmitRow = () => {\n    var _a;\n    //look for auto-filled input values\n    (_a = Object.values(editInputRefs === null || editInputRefs === void 0 ? void 0 : editInputRefs.current).filter(inputRef => {\n      var _a, _b;\n      return row.id === ((_b = (_a = inputRef === null || inputRef === void 0 ? void 0 : inputRef.name) === null || _a === void 0 ? void 0 : _a.split('_')) === null || _b === void 0 ? void 0 : _b[0]);\n    })) === null || _a === void 0 ? void 0 : _a.forEach(input => {\n      if (input.value !== undefined && Object.hasOwn(row === null || row === void 0 ? void 0 : row._valuesCache, input.name)) {\n        // @ts-ignore\n        row._valuesCache[input.name] = input.value;\n      }\n    });\n    if (isCreating) onCreatingRowSave === null || onCreatingRowSave === void 0 ? void 0 : onCreatingRowSave({\n      exitCreatingMode: () => setCreatingRow(null),\n      row,\n      table,\n      values: row._valuesCache\n    });else if (isEditing) {\n      onEditingRowSave === null || onEditingRowSave === void 0 ? void 0 : onEditingRowSave({\n        exitEditingMode: () => setEditingRow(null),\n        row,\n        table,\n        values: row === null || row === void 0 ? void 0 : row._valuesCache\n      });\n    }\n  };\n  return jsx(Box, {\n    onClick: e => e.stopPropagation(),\n    sx: theme => Object.assign({\n      display: 'flex',\n      gap: '0.75rem'\n    }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)),\n    children: variant === 'icon' ? jsxs(Fragment, {\n      children: [jsx(Tooltip, {\n        title: localization.cancel,\n        children: jsx(IconButton, {\n          \"aria-label\": localization.cancel,\n          onClick: handleCancel,\n          children: jsx(CancelIcon, {})\n        })\n      }), (isCreating && onCreatingRowSave || isEditing && onEditingRowSave) && jsx(Tooltip, {\n        title: localization.save,\n        children: jsx(IconButton, {\n          \"aria-label\": localization.save,\n          color: \"info\",\n          disabled: isSaving,\n          onClick: handleSubmitRow,\n          children: isSaving ? jsx(CircularProgress, {\n            size: 18\n          }) : jsx(SaveIcon, {})\n        })\n      })]\n    }) : jsxs(Fragment, {\n      children: [jsx(Button, {\n        onClick: handleCancel,\n        sx: {\n          minWidth: '100px'\n        },\n        children: localization.cancel\n      }), jsxs(Button, {\n        disabled: isSaving,\n        onClick: handleSubmitRow,\n        sx: {\n          minWidth: '100px'\n        },\n        variant: \"contained\",\n        children: [isSaving && jsx(CircularProgress, {\n          color: \"inherit\",\n          size: 18\n        }), localization.save]\n      })]\n    })\n  });\n};\nconst parseCSSVarId = id => id.replace(/[^a-zA-Z0-9]/g, '_');\nconst getMRTTheme = (mrtTheme, muiTheme) => {\n  var _a;\n  const mrtThemeOverrides = parseFromValuesOrFunc(mrtTheme, muiTheme);\n  const baseBackgroundColor = (_a = mrtThemeOverrides === null || mrtThemeOverrides === void 0 ? void 0 : mrtThemeOverrides.baseBackgroundColor) !== null && _a !== void 0 ? _a : muiTheme.palette.mode === 'dark' ? lighten(muiTheme.palette.background.default, 0.05) : muiTheme.palette.background.default;\n  return Object.assign({\n    baseBackgroundColor,\n    draggingBorderColor: muiTheme.palette.primary.main,\n    matchHighlightColor: muiTheme.palette.mode === 'dark' ? darken(muiTheme.palette.warning.dark, 0.25) : lighten(muiTheme.palette.warning.light, 0.5),\n    menuBackgroundColor: lighten(baseBackgroundColor, 0.07),\n    pinnedRowBackgroundColor: alpha(muiTheme.palette.primary.main, 0.1),\n    selectedRowBackgroundColor: alpha(muiTheme.palette.primary.main, 0.2)\n  }, mrtThemeOverrides);\n};\nconst commonCellBeforeAfterStyles = {\n  content: '\"\"',\n  height: '100%',\n  left: 0,\n  position: 'absolute',\n  top: 0,\n  width: '100%',\n  zIndex: -1\n};\nconst getCommonPinnedCellStyles = ({\n  column,\n  table,\n  theme\n}) => {\n  const {\n    baseBackgroundColor\n  } = table.options.mrtTheme;\n  const isPinned = column === null || column === void 0 ? void 0 : column.getIsPinned();\n  return {\n    '&[data-pinned=\"true\"]': {\n      '&:before': Object.assign({\n        backgroundColor: alpha(darken(baseBackgroundColor, theme.palette.mode === 'dark' ? 0.05 : 0.01), 0.97),\n        boxShadow: column ? isPinned === 'left' && column.getIsLastColumn(isPinned) ? `-4px 0 4px -4px ${alpha(theme.palette.grey[700], 0.5)} inset` : isPinned === 'right' && column.getIsFirstColumn(isPinned) ? `4px 0 4px -4px ${alpha(theme.palette.grey[700], 0.5)} inset` : undefined : undefined\n      }, commonCellBeforeAfterStyles)\n    }\n  };\n};\nconst getCommonMRTCellStyles = ({\n  column,\n  header,\n  table,\n  tableCellProps,\n  theme\n}) => {\n  var _a, _b, _c, _d, _e, _f;\n  const {\n    getState,\n    options: {\n      enableColumnVirtualization,\n      layoutMode\n    }\n  } = table;\n  const {\n    draggingColumn\n  } = getState();\n  const {\n    columnDef\n  } = column;\n  const {\n    columnDefType\n  } = columnDef;\n  const isColumnPinned = columnDef.columnDefType !== 'group' && column.getIsPinned();\n  const widthStyles = {\n    minWidth: `max(calc(var(--${header ? 'header' : 'col'}-${parseCSSVarId((_a = header === null || header === void 0 ? void 0 : header.id) !== null && _a !== void 0 ? _a : column.id)}-size) * 1px), ${(_b = columnDef.minSize) !== null && _b !== void 0 ? _b : 30}px)`,\n    width: `calc(var(--${header ? 'header' : 'col'}-${parseCSSVarId((_c = header === null || header === void 0 ? void 0 : header.id) !== null && _c !== void 0 ? _c : column.id)}-size) * 1px)`\n  };\n  if (layoutMode === 'grid') {\n    widthStyles.flex = `${[0, false].includes(columnDef.grow) ? 0 : `var(--${header ? 'header' : 'col'}-${parseCSSVarId((_d = header === null || header === void 0 ? void 0 : header.id) !== null && _d !== void 0 ? _d : column.id)}-size)`} 0 auto`;\n  } else if (layoutMode === 'grid-no-grow') {\n    widthStyles.flex = `${+(columnDef.grow || 0)} 0 auto`;\n  }\n  const pinnedStyles = isColumnPinned ? Object.assign(Object.assign({}, getCommonPinnedCellStyles({\n    column,\n    table,\n    theme\n  })), {\n    left: isColumnPinned === 'left' ? `${column.getStart('left')}px` : undefined,\n    opacity: 0.97,\n    position: 'sticky',\n    right: isColumnPinned === 'right' ? `${column.getAfter('right')}px` : undefined\n  }) : {};\n  return Object.assign(Object.assign(Object.assign({\n    backgroundColor: 'inherit',\n    backgroundImage: 'inherit',\n    display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'flex' : undefined,\n    justifyContent: columnDefType === 'group' ? 'center' : (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? tableCellProps.align : undefined,\n    opacity: ((_e = table.getState().draggingColumn) === null || _e === void 0 ? void 0 : _e.id) === column.id || ((_f = table.getState().hoveredColumn) === null || _f === void 0 ? void 0 : _f.id) === column.id ? 0.5 : 1,\n    position: 'relative',\n    transition: enableColumnVirtualization ? 'none' : `padding 150ms ease-in-out`,\n    zIndex: column.getIsResizing() || (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id ? 2 : columnDefType !== 'group' && isColumnPinned ? 1 : 0\n  }, pinnedStyles), widthStyles), parseFromValuesOrFunc(tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx, theme));\n};\nconst getCommonToolbarStyles = ({\n  table\n}) => ({\n  alignItems: 'flex-start',\n  backgroundColor: table.options.mrtTheme.baseBackgroundColor,\n  display: 'grid',\n  flexWrap: 'wrap-reverse',\n  minHeight: '3.5rem',\n  overflow: 'hidden',\n  position: 'relative',\n  transition: 'all 150ms ease-in-out',\n  zIndex: 1\n});\nconst flipIconStyles = theme => theme.direction === 'rtl' ? {\n  style: {\n    transform: 'scaleX(-1)'\n  }\n} : undefined;\nconst getCommonTooltipProps = placement => ({\n  disableInteractive: true,\n  enterDelay: 1000,\n  enterNextDelay: 1000,\n  placement\n});\nconst MRT_ActionMenuItem = _a => {\n  var {\n      icon,\n      label,\n      onOpenSubMenu,\n      table\n    } = _a,\n    rest = __rest(_a, [\"icon\", \"label\", \"onOpenSubMenu\", \"table\"]);\n  const {\n    options: {\n      icons: {\n        ArrowRightIcon\n      }\n    }\n  } = table;\n  return jsxs(MenuItem, Object.assign({\n    sx: {\n      alignItems: 'center',\n      justifyContent: 'space-between',\n      minWidth: '120px',\n      my: 0,\n      py: '6px'\n    }\n  }, rest, {\n    children: [jsxs(Box, {\n      sx: {\n        alignItems: 'center',\n        display: 'flex'\n      },\n      children: [jsx(ListItemIcon, {\n        children: icon\n      }), label]\n    }), onOpenSubMenu && jsx(IconButton, {\n      onClick: onOpenSubMenu,\n      onMouseEnter: onOpenSubMenu,\n      size: \"small\",\n      sx: {\n        p: 0\n      },\n      children: jsx(ArrowRightIcon, {})\n    })]\n  }));\n};\nconst MRT_RowActionMenu = _a => {\n  var {\n      anchorEl,\n      handleEdit,\n      row,\n      setAnchorEl,\n      staticRowIndex,\n      table\n    } = _a,\n    rest = __rest(_a, [\"anchorEl\", \"handleEdit\", \"row\", \"setAnchorEl\", \"staticRowIndex\", \"table\"]);\n  const {\n    getState,\n    options: {\n      editDisplayMode,\n      enableEditing,\n      icons: {\n        EditIcon\n      },\n      localization,\n      mrtTheme: {\n        menuBackgroundColor\n      },\n      renderRowActionMenuItems\n    }\n  } = table;\n  const {\n    density\n  } = getState();\n  return jsxs(Menu, Object.assign({\n    MenuListProps: {\n      dense: density === 'compact',\n      sx: {\n        backgroundColor: menuBackgroundColor\n      }\n    },\n    anchorEl: anchorEl,\n    disableScrollLock: true,\n    onClick: event => event.stopPropagation(),\n    onClose: () => setAnchorEl(null),\n    open: !!anchorEl\n  }, rest, {\n    children: [parseFromValuesOrFunc(enableEditing, row) && ['modal', 'row'].includes(editDisplayMode) && jsx(MRT_ActionMenuItem, {\n      icon: jsx(EditIcon, {}),\n      label: localization.edit,\n      onClick: handleEdit,\n      table: table\n    }), renderRowActionMenuItems === null || renderRowActionMenuItems === void 0 ? void 0 : renderRowActionMenuItems({\n      closeMenu: () => setAnchorEl(null),\n      row,\n      staticRowIndex,\n      table\n    })]\n  }));\n};\nconst commonIconButtonStyles = {\n  '&:hover': {\n    opacity: 1\n  },\n  height: '2rem',\n  ml: '10px',\n  opacity: 0.5,\n  transition: 'opacity 150ms',\n  width: '2rem'\n};\nconst MRT_ToggleRowActionMenuButton = _a => {\n  var {\n      cell,\n      row,\n      staticRowIndex,\n      table\n    } = _a,\n    rest = __rest(_a, [\"cell\", \"row\", \"staticRowIndex\", \"table\"]);\n  const {\n    getState,\n    options: {\n      createDisplayMode,\n      editDisplayMode,\n      enableEditing,\n      icons: {\n        EditIcon,\n        MoreHorizIcon\n      },\n      localization,\n      renderRowActionMenuItems,\n      renderRowActions\n    },\n    setEditingRow\n  } = table;\n  const {\n    creatingRow,\n    editingRow\n  } = getState();\n  const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;\n  const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;\n  const showEditActionButtons = isCreating && createDisplayMode === 'row' || isEditing && editDisplayMode === 'row';\n  const [anchorEl, setAnchorEl] = useState(null);\n  const handleOpenRowActionMenu = event => {\n    event.stopPropagation();\n    event.preventDefault();\n    setAnchorEl(event.currentTarget);\n  };\n  const handleStartEditMode = event => {\n    event.stopPropagation();\n    setEditingRow(Object.assign({}, row));\n    setAnchorEl(null);\n  };\n  return jsx(Fragment, {\n    children: renderRowActions && !showEditActionButtons ? renderRowActions({\n      cell,\n      row,\n      staticRowIndex,\n      table\n    }) : showEditActionButtons ? jsx(MRT_EditActionButtons, {\n      row: row,\n      table: table\n    }) : !renderRowActionMenuItems && parseFromValuesOrFunc(enableEditing, row) && ['modal', 'row'].includes(editDisplayMode) ? jsx(Tooltip, {\n      placement: \"right\",\n      title: localization.edit,\n      children: jsx(IconButton, Object.assign({\n        \"aria-label\": localization.edit,\n        onClick: handleStartEditMode,\n        sx: commonIconButtonStyles\n      }, rest, {\n        children: jsx(EditIcon, {})\n      }))\n    }) : renderRowActionMenuItems ? jsxs(Fragment, {\n      children: [jsx(Tooltip, Object.assign({}, getCommonTooltipProps(), {\n        title: localization.rowActions,\n        children: jsx(IconButton, Object.assign({\n          \"aria-label\": localization.rowActions,\n          onClick: handleOpenRowActionMenu,\n          size: \"small\",\n          sx: commonIconButtonStyles\n        }, rest, {\n          children: jsx(MoreHorizIcon, {})\n        }))\n      })), jsx(MRT_RowActionMenu, {\n        anchorEl: anchorEl,\n        handleEdit: handleStartEditMode,\n        row: row,\n        setAnchorEl: setAnchorEl,\n        staticRowIndex: staticRowIndex,\n        table: table\n      })]\n    }) : null\n  });\n};\nconst getMRT_RowActionsColumnDef = tableOptions => {\n  return Object.assign({\n    Cell: ({\n      cell,\n      row,\n      staticRowIndex,\n      table\n    }) => jsx(MRT_ToggleRowActionMenuButton, {\n      cell: cell,\n      row: row,\n      staticRowIndex: staticRowIndex,\n      table: table\n    })\n  }, defaultDisplayColumnProps({\n    header: 'actions',\n    id: 'mrt-row-actions',\n    size: 70,\n    tableOptions\n  }));\n};\nconst MRT_GrabHandleButton = _a => {\n  var _b, _c;\n  var {\n      location,\n      table\n    } = _a,\n    rest = __rest(_a, [\"location\", \"table\"]);\n  const {\n    options: {\n      icons: {\n        DragHandleIcon\n      },\n      localization\n    }\n  } = table;\n  return jsx(Tooltip, Object.assign({}, getCommonTooltipProps('top'), {\n    title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.move,\n    children: jsx(IconButton, Object.assign({\n      \"aria-label\": (_c = rest.title) !== null && _c !== void 0 ? _c : localization.move,\n      disableRipple: true,\n      draggable: \"true\",\n      size: \"small\"\n    }, rest, {\n      onClick: e => {\n        var _a;\n        e.stopPropagation();\n        (_a = rest === null || rest === void 0 ? void 0 : rest.onClick) === null || _a === void 0 ? void 0 : _a.call(rest, e);\n      },\n      sx: theme => Object.assign({\n        '&:active': {\n          cursor: 'grabbing'\n        },\n        '&:hover': {\n          backgroundColor: 'transparent',\n          opacity: 1\n        },\n        cursor: 'grab',\n        m: '0 -0.1rem',\n        opacity: location === 'row' ? 1 : 0.5,\n        p: '2px',\n        transition: 'all 150ms ease-in-out'\n      }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)),\n      title: undefined,\n      children: jsx(DragHandleIcon, {})\n    }))\n  }));\n};\nconst MRT_TableBodyRowGrabHandle = _a => {\n  var {\n      row,\n      rowRef,\n      table\n    } = _a,\n    rest = __rest(_a, [\"row\", \"rowRef\", \"table\"]);\n  const {\n    options: {\n      muiRowDragHandleProps\n    }\n  } = table;\n  const iconButtonProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiRowDragHandleProps, {\n    row,\n    table\n  })), rest);\n  const handleDragStart = event => {\n    var _a;\n    (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragStart) === null || _a === void 0 ? void 0 : _a.call(iconButtonProps, event);\n    try {\n      event.dataTransfer.setDragImage(rowRef.current, 0, 0);\n    } catch (e) {\n      console.error(e);\n    }\n    table.setDraggingRow(row);\n  };\n  const handleDragEnd = event => {\n    var _a;\n    (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragEnd) === null || _a === void 0 ? void 0 : _a.call(iconButtonProps, event);\n    table.setDraggingRow(null);\n    table.setHoveredRow(null);\n  };\n  return jsx(MRT_GrabHandleButton, Object.assign({}, iconButtonProps, {\n    location: \"row\",\n    onDragEnd: handleDragEnd,\n    onDragStart: handleDragStart,\n    table: table\n  }));\n};\nconst getMRT_RowDragColumnDef = tableOptions => {\n  return Object.assign({\n    Cell: ({\n      row,\n      rowRef,\n      table\n    }) => jsx(MRT_TableBodyRowGrabHandle, {\n      row: row,\n      rowRef: rowRef,\n      table: table\n    }),\n    grow: false\n  }, defaultDisplayColumnProps({\n    header: 'move',\n    id: 'mrt-row-drag',\n    size: 60,\n    tableOptions\n  }));\n};\nconst MRT_ExpandAllButton = _a => {\n  var _b, _c;\n  var {\n      table\n    } = _a,\n    rest = __rest(_a, [\"table\"]);\n  const {\n    getCanSomeRowsExpand,\n    getIsAllRowsExpanded,\n    getIsSomeRowsExpanded,\n    getState,\n    options: {\n      icons: {\n        KeyboardDoubleArrowDownIcon\n      },\n      localization,\n      muiExpandAllButtonProps,\n      renderDetailPanel\n    },\n    toggleAllRowsExpanded\n  } = table;\n  const {\n    density,\n    isLoading\n  } = getState();\n  const iconButtonProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiExpandAllButtonProps, {\n    table\n  })), rest);\n  const isAllRowsExpanded = getIsAllRowsExpanded();\n  return jsx(Tooltip, Object.assign({}, getCommonTooltipProps(), {\n    title: (_b = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.title) !== null && _b !== void 0 ? _b : isAllRowsExpanded ? localization.collapseAll : localization.expandAll,\n    children: jsx(\"span\", {\n      children: jsx(IconButton, Object.assign({\n        \"aria-label\": localization.expandAll,\n        disabled: isLoading || !renderDetailPanel && !getCanSomeRowsExpand(),\n        onClick: () => toggleAllRowsExpanded(!isAllRowsExpanded)\n      }, iconButtonProps, {\n        sx: theme => Object.assign({\n          height: density === 'compact' ? '1.75rem' : '2.25rem',\n          mt: density !== 'compact' ? '-0.25rem' : undefined,\n          width: density === 'compact' ? '1.75rem' : '2.25rem'\n        }, parseFromValuesOrFunc(iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx, theme)),\n        title: undefined,\n        children: (_c = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.children) !== null && _c !== void 0 ? _c : jsx(KeyboardDoubleArrowDownIcon, {\n          style: {\n            transform: `rotate(${isAllRowsExpanded ? -180 : getIsSomeRowsExpanded() ? -90 : 0}deg)`,\n            transition: 'transform 150ms'\n          }\n        })\n      }))\n    })\n  }));\n};\nconst MRT_ExpandButton = ({\n  row,\n  staticRowIndex,\n  table\n}) => {\n  var _a, _b;\n  const theme = useTheme();\n  const {\n    getState,\n    options: {\n      icons: {\n        ExpandMoreIcon\n      },\n      localization,\n      muiExpandButtonProps,\n      positionExpandColumn,\n      renderDetailPanel\n    }\n  } = table;\n  const {\n    density\n  } = getState();\n  const iconButtonProps = parseFromValuesOrFunc(muiExpandButtonProps, {\n    row,\n    staticRowIndex,\n    table\n  });\n  const canExpand = row.getCanExpand();\n  const isExpanded = row.getIsExpanded();\n  const handleToggleExpand = event => {\n    var _a;\n    event.stopPropagation();\n    row.toggleExpanded();\n    (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onClick) === null || _a === void 0 ? void 0 : _a.call(iconButtonProps, event);\n  };\n  const detailPanel = !!(renderDetailPanel === null || renderDetailPanel === void 0 ? void 0 : renderDetailPanel({\n    row,\n    table\n  }));\n  return jsx(Tooltip, Object.assign({\n    disableHoverListener: !canExpand && !detailPanel\n  }, getCommonTooltipProps(), {\n    title: (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.title) !== null && _a !== void 0 ? _a : isExpanded ? localization.collapse : localization.expand,\n    children: jsx(\"span\", {\n      children: jsx(IconButton, Object.assign({\n        \"aria-label\": localization.expand,\n        disabled: !canExpand && !detailPanel\n      }, iconButtonProps, {\n        onClick: handleToggleExpand,\n        sx: theme => Object.assign({\n          height: density === 'compact' ? '1.75rem' : '2.25rem',\n          opacity: !canExpand && !detailPanel ? 0.3 : 1,\n          [theme.direction === 'rtl' || positionExpandColumn === 'last' ? 'mr' : 'ml']: `${row.depth * 16}px`,\n          width: density === 'compact' ? '1.75rem' : '2.25rem'\n        }, parseFromValuesOrFunc(iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx, theme)),\n        title: undefined,\n        children: (_b = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.children) !== null && _b !== void 0 ? _b : jsx(ExpandMoreIcon, {\n          style: {\n            transform: `rotate(${!canExpand && !renderDetailPanel ? positionExpandColumn === 'last' || theme.direction === 'rtl' ? 90 : -90 : isExpanded ? -180 : 0}deg)`,\n            transition: 'transform 150ms'\n          }\n        })\n      }))\n    })\n  }));\n};\nconst getMRT_RowExpandColumnDef = tableOptions => {\n  var _a;\n  const {\n    defaultColumn,\n    enableExpandAll,\n    groupedColumnMode,\n    positionExpandColumn,\n    renderDetailPanel,\n    state: {\n      grouping\n    }\n  } = tableOptions;\n  const alignProps = positionExpandColumn === 'last' ? {\n    align: 'right'\n  } : undefined;\n  return Object.assign({\n    Cell: ({\n      cell,\n      column,\n      row,\n      staticRowIndex,\n      table\n    }) => {\n      var _a, _b, _c;\n      const expandButtonProps = {\n        row,\n        staticRowIndex,\n        table\n      };\n      const subRowsLength = (_a = row.subRows) === null || _a === void 0 ? void 0 : _a.length;\n      if (groupedColumnMode === 'remove' && row.groupingColumnId) {\n        return jsxs(Stack, {\n          alignItems: \"center\",\n          flexDirection: \"row\",\n          gap: \"0.25rem\",\n          children: [jsx(MRT_ExpandButton, Object.assign({}, expandButtonProps)), jsx(Tooltip, Object.assign({}, getCommonTooltipProps('right'), {\n            title: table.getColumn(row.groupingColumnId).columnDef.header,\n            children: jsx(\"span\", {\n              children: row.groupingValue\n            })\n          })), !!subRowsLength && jsxs(\"span\", {\n            children: [\"(\", subRowsLength, \")\"]\n          })]\n        });\n      } else {\n        return jsxs(Fragment, {\n          children: [jsx(MRT_ExpandButton, Object.assign({}, expandButtonProps)), (_c = (_b = column.columnDef).GroupedCell) === null || _c === void 0 ? void 0 : _c.call(_b, {\n            cell,\n            column,\n            row,\n            table\n          })]\n        });\n      }\n    },\n    Header: enableExpandAll ? ({\n      table\n    }) => {\n      var _a;\n      return jsxs(Fragment, {\n        children: [jsx(MRT_ExpandAllButton, {\n          table: table\n        }), groupedColumnMode === 'remove' && ((_a = grouping === null || grouping === void 0 ? void 0 : grouping.map(groupedColumnId => table.getColumn(groupedColumnId).columnDef.header)) === null || _a === void 0 ? void 0 : _a.join(', '))]\n      });\n    } : undefined,\n    muiTableBodyCellProps: alignProps,\n    muiTableHeadCellProps: alignProps\n  }, defaultDisplayColumnProps({\n    header: 'expand',\n    id: 'mrt-row-expand',\n    size: groupedColumnMode === 'remove' ? (_a = defaultColumn === null || defaultColumn === void 0 ? void 0 : defaultColumn.size) !== null && _a !== void 0 ? _a : 180 : renderDetailPanel ? enableExpandAll ? 60 : 70 : 100,\n    tableOptions\n  }));\n};\nconst getMRT_RowNumbersColumnDef = tableOptions => {\n  const {\n    localization,\n    rowNumberDisplayMode\n  } = tableOptions;\n  const {\n    pagination: {\n      pageIndex,\n      pageSize\n    }\n  } = tableOptions.state;\n  return Object.assign({\n    Cell: ({\n      row,\n      staticRowIndex\n    }) => {\n      var _a;\n      return ((_a = rowNumberDisplayMode === 'static' ? (staticRowIndex || 0) + (pageSize || 0) * (pageIndex || 0) : row.index) !== null && _a !== void 0 ? _a : 0) + 1;\n    },\n    Header: () => localization.rowNumber,\n    grow: false\n  }, defaultDisplayColumnProps({\n    header: 'rowNumbers',\n    id: 'mrt-row-numbers',\n    size: 50,\n    tableOptions\n  }));\n};\nconst MRT_RowPinButton = _a => {\n  var {\n      pinningPosition,\n      row,\n      table\n    } = _a,\n    rest = __rest(_a, [\"pinningPosition\", \"row\", \"table\"]);\n  const {\n    options: {\n      icons: {\n        CloseIcon,\n        PushPinIcon\n      },\n      localization,\n      rowPinningDisplayMode\n    }\n  } = table;\n  const isPinned = row.getIsPinned();\n  const [tooltipOpened, setTooltipOpened] = useState(false);\n  const handleTogglePin = event => {\n    setTooltipOpened(false);\n    event.stopPropagation();\n    row.pin(isPinned ? false : pinningPosition);\n  };\n  return jsx(Tooltip, Object.assign({}, getCommonTooltipProps(), {\n    open: tooltipOpened,\n    title: isPinned ? localization.unpin : localization.pin,\n    children: jsx(IconButton, Object.assign({\n      \"aria-label\": localization.pin,\n      onClick: handleTogglePin,\n      onMouseEnter: () => setTooltipOpened(true),\n      onMouseLeave: () => setTooltipOpened(false),\n      size: \"small\"\n    }, rest, {\n      sx: theme => Object.assign({\n        height: '24px',\n        width: '24px'\n      }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)),\n      children: isPinned ? jsx(CloseIcon, {}) : jsx(PushPinIcon, {\n        fontSize: \"small\",\n        style: {\n          transform: `rotate(${rowPinningDisplayMode === 'sticky' ? 135 : pinningPosition === 'top' ? 180 : 0}deg)`\n        }\n      })\n    }))\n  }));\n};\nconst MRT_TableBodyRowPinButton = _a => {\n  var {\n      row,\n      table\n    } = _a,\n    rest = __rest(_a, [\"row\", \"table\"]);\n  const {\n    getState,\n    options: {\n      enableRowPinning,\n      rowPinningDisplayMode\n    }\n  } = table;\n  const {\n    density\n  } = getState();\n  const canPin = parseFromValuesOrFunc(enableRowPinning, row);\n  if (!canPin) return null;\n  const rowPinButtonProps = Object.assign({\n    row,\n    table\n  }, rest);\n  if (rowPinningDisplayMode === 'top-and-bottom' && !row.getIsPinned()) {\n    return jsxs(Box, {\n      sx: {\n        display: 'flex',\n        flexDirection: density === 'compact' ? 'row' : 'column'\n      },\n      children: [jsx(MRT_RowPinButton, Object.assign({\n        pinningPosition: \"top\"\n      }, rowPinButtonProps)), jsx(MRT_RowPinButton, Object.assign({\n        pinningPosition: \"bottom\"\n      }, rowPinButtonProps))]\n    });\n  }\n  return jsx(MRT_RowPinButton, Object.assign({\n    pinningPosition: rowPinningDisplayMode === 'bottom' ? 'bottom' : 'top'\n  }, rowPinButtonProps));\n};\nconst getMRT_RowPinningColumnDef = tableOptions => {\n  return Object.assign({\n    Cell: ({\n      row,\n      table\n    }) => jsx(MRT_TableBodyRowPinButton, {\n      row: row,\n      table: table\n    }),\n    grow: false\n  }, defaultDisplayColumnProps({\n    header: 'pin',\n    id: 'mrt-row-pin',\n    size: 60,\n    tableOptions\n  }));\n};\nconst MRT_SelectCheckbox = _a => {\n  var _b;\n  var {\n      row,\n      staticRowIndex,\n      table\n    } = _a,\n    rest = __rest(_a, [\"row\", \"staticRowIndex\", \"table\"]);\n  const {\n    getState,\n    options: {\n      enableMultiRowSelection,\n      localization,\n      muiSelectAllCheckboxProps,\n      muiSelectCheckboxProps,\n      selectAllMode\n    }\n  } = table;\n  const {\n    density,\n    isLoading\n  } = getState();\n  const selectAll = !row;\n  const allRowsSelected = selectAll ? selectAllMode === 'page' ? table.getIsAllPageRowsSelected() : table.getIsAllRowsSelected() : undefined;\n  const isChecked = selectAll ? allRowsSelected : getIsRowSelected({\n    row,\n    table\n  });\n  const checkboxProps = Object.assign(Object.assign({}, selectAll ? parseFromValuesOrFunc(muiSelectAllCheckboxProps, {\n    table\n  }) : parseFromValuesOrFunc(muiSelectCheckboxProps, {\n    row,\n    staticRowIndex,\n    table\n  })), rest);\n  const onSelectionChange = row ? getMRT_RowSelectionHandler({\n    row,\n    staticRowIndex,\n    table\n  }) : undefined;\n  const onSelectAllChange = getMRT_SelectAllHandler({\n    table\n  });\n  const commonProps = Object.assign(Object.assign({\n    'aria-label': selectAll ? localization.toggleSelectAll : localization.toggleSelectRow,\n    checked: isChecked,\n    disabled: isLoading || row && !row.getCanSelect() || (row === null || row === void 0 ? void 0 : row.id) === 'mrt-row-create',\n    inputProps: {\n      'aria-label': selectAll ? localization.toggleSelectAll : localization.toggleSelectRow\n    },\n    onChange: event => {\n      event.stopPropagation();\n      selectAll ? onSelectAllChange(event) : onSelectionChange(event);\n    },\n    size: density === 'compact' ? 'small' : 'medium'\n  }, checkboxProps), {\n    onClick: e => {\n      var _a;\n      e.stopPropagation();\n      (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a === void 0 ? void 0 : _a.call(checkboxProps, e);\n    },\n    sx: theme => Object.assign({\n      height: density === 'compact' ? '1.75rem' : '2.5rem',\n      m: density !== 'compact' ? '-0.4rem' : undefined,\n      width: density === 'compact' ? '1.75rem' : '2.5rem',\n      zIndex: 0\n    }, parseFromValuesOrFunc(checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.sx, theme)),\n    title: undefined\n  });\n  return jsx(Tooltip, Object.assign({}, getCommonTooltipProps(), {\n    title: (_b = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.title) !== null && _b !== void 0 ? _b : selectAll ? localization.toggleSelectAll : localization.toggleSelectRow,\n    children: enableMultiRowSelection === false ? jsx(Radio, Object.assign({}, commonProps)) : jsx(Checkbox, Object.assign({\n      indeterminate: !isChecked && selectAll ? table.getIsSomeRowsSelected() : (row === null || row === void 0 ? void 0 : row.getIsSomeSelected()) && row.getCanSelectSubRows()\n    }, commonProps))\n  }));\n};\nconst getMRT_RowSelectColumnDef = tableOptions => {\n  const {\n    enableMultiRowSelection,\n    enableSelectAll\n  } = tableOptions;\n  return Object.assign({\n    Cell: ({\n      row,\n      staticRowIndex,\n      table\n    }) => jsx(MRT_SelectCheckbox, {\n      row: row,\n      staticRowIndex: staticRowIndex,\n      table: table\n    }),\n    Header: enableSelectAll && enableMultiRowSelection ? ({\n      table\n    }) => jsx(MRT_SelectCheckbox, {\n      table: table\n    }) : undefined,\n    grow: false\n  }, defaultDisplayColumnProps({\n    header: 'select',\n    id: 'mrt-row-select',\n    size: enableSelectAll ? 60 : 70,\n    tableOptions\n  }));\n};\nconst MRT_Default_Icons = {\n  ArrowDownwardIcon,\n  ArrowRightIcon,\n  CancelIcon,\n  ChevronLeftIcon,\n  ChevronRightIcon,\n  ClearAllIcon,\n  CloseIcon,\n  ContentCopy,\n  DensityLargeIcon,\n  DensityMediumIcon,\n  DensitySmallIcon,\n  DragHandleIcon,\n  DynamicFeedIcon,\n  EditIcon,\n  ExpandMoreIcon,\n  FilterAltIcon,\n  FilterListIcon,\n  FilterListOffIcon,\n  FirstPageIcon,\n  FullscreenExitIcon,\n  FullscreenIcon,\n  KeyboardDoubleArrowDownIcon,\n  LastPageIcon,\n  MoreHorizIcon,\n  MoreVertIcon,\n  PushPinIcon,\n  RestartAltIcon,\n  SaveIcon,\n  SearchIcon,\n  SearchOffIcon,\n  SortIcon,\n  SyncAltIcon,\n  ViewColumnIcon,\n  VisibilityOffIcon\n};\nconst MRT_Localization_EN = {\n  actions: 'Actions',\n  and: 'and',\n  cancel: 'Cancel',\n  changeFilterMode: 'Change filter mode',\n  changeSearchMode: 'Change search mode',\n  clearFilter: 'Clear filter',\n  clearSearch: 'Clear search',\n  clearSelection: 'Clear selection',\n  clearSort: 'Clear sort',\n  clickToCopy: 'Click to copy',\n  copy: 'Copy',\n  collapse: 'Collapse',\n  collapseAll: 'Collapse all',\n  columnActions: 'Column Actions',\n  copiedToClipboard: 'Copied to clipboard',\n  dropToGroupBy: 'Drop to group by {column}',\n  edit: 'Edit',\n  expand: 'Expand',\n  expandAll: 'Expand all',\n  filterArrIncludes: 'Includes',\n  filterArrIncludesAll: 'Includes all',\n  filterArrIncludesSome: 'Includes',\n  filterBetween: 'Between',\n  filterBetweenInclusive: 'Between Inclusive',\n  filterByColumn: 'Filter by {column}',\n  filterContains: 'Contains',\n  filterEmpty: 'Empty',\n  filterEndsWith: 'Ends With',\n  filterEquals: 'Equals',\n  filterEqualsString: 'Equals',\n  filterFuzzy: 'Fuzzy',\n  filterGreaterThan: 'Greater Than',\n  filterGreaterThanOrEqualTo: 'Greater Than Or Equal To',\n  filterInNumberRange: 'Between',\n  filterIncludesString: 'Contains',\n  filterIncludesStringSensitive: 'Contains',\n  filterLessThan: 'Less Than',\n  filterLessThanOrEqualTo: 'Less Than Or Equal To',\n  filterMode: 'Filter Mode: {filterType}',\n  filterNotEmpty: 'Not Empty',\n  filterNotEquals: 'Not Equals',\n  filterStartsWith: 'Starts With',\n  filterWeakEquals: 'Equals',\n  filteringByColumn: 'Filtering by {column} - {filterType} {filterValue}',\n  goToFirstPage: 'Go to first page',\n  goToLastPage: 'Go to last page',\n  goToNextPage: 'Go to next page',\n  goToPreviousPage: 'Go to previous page',\n  grab: 'Grab',\n  groupByColumn: 'Group by {column}',\n  groupedBy: 'Grouped by ',\n  hideAll: 'Hide all',\n  hideColumn: 'Hide {column} column',\n  max: 'Max',\n  min: 'Min',\n  move: 'Move',\n  noRecordsToDisplay: 'No records to display',\n  noResultsFound: 'No results found',\n  of: 'of',\n  or: 'or',\n  pin: 'Pin',\n  pinToLeft: 'Pin to left',\n  pinToRight: 'Pin to right',\n  resetColumnSize: 'Reset column size',\n  resetOrder: 'Reset order',\n  rowActions: 'Row Actions',\n  rowNumber: '#',\n  rowNumbers: 'Row Numbers',\n  rowsPerPage: 'Rows per page',\n  save: 'Save',\n  search: 'Search',\n  selectedCountOfRowCountRowsSelected: '{selectedCount} of {rowCount} row(s) selected',\n  select: 'Select',\n  showAll: 'Show all',\n  showAllColumns: 'Show all columns',\n  showHideColumns: 'Show/Hide columns',\n  showHideFilters: 'Show/Hide filters',\n  showHideSearch: 'Show/Hide search',\n  sortByColumnAsc: 'Sort by {column} ascending',\n  sortByColumnDesc: 'Sort by {column} descending',\n  sortedByColumnAsc: 'Sorted by {column} ascending',\n  sortedByColumnDesc: 'Sorted by {column} descending',\n  thenBy: ', then by ',\n  toggleDensity: 'Toggle density',\n  toggleFullScreen: 'Toggle full screen',\n  toggleSelectAll: 'Toggle select all',\n  toggleSelectRow: 'Toggle select row',\n  toggleVisibility: 'Toggle visibility',\n  ungroupByColumn: 'Ungroup by {column}',\n  unpin: 'Unpin',\n  unpinAll: 'Unpin all'\n};\nconst MRT_DefaultColumn = {\n  filterVariant: 'text',\n  maxSize: 1000,\n  minSize: 40,\n  size: 180\n};\nconst MRT_DefaultDisplayColumn = {\n  columnDefType: 'display',\n  enableClickToCopy: false,\n  enableColumnActions: false,\n  enableColumnDragging: false,\n  enableColumnFilter: false,\n  enableColumnOrdering: false,\n  enableEditing: false,\n  enableGlobalFilter: false,\n  enableGrouping: false,\n  enableHiding: false,\n  enableResizing: false,\n  enableSorting: false\n};\nconst useMRT_TableOptions = _a => {\n  var _b;\n  var {\n      aggregationFns,\n      autoResetExpanded = false,\n      columnFilterDisplayMode = 'subheader',\n      columnResizeDirection,\n      columnResizeMode = 'onChange',\n      createDisplayMode = 'modal',\n      defaultColumn,\n      defaultDisplayColumn,\n      editDisplayMode = 'modal',\n      enableBatchRowSelection = true,\n      enableBottomToolbar = true,\n      enableColumnActions = true,\n      enableColumnFilters = true,\n      enableColumnOrdering = false,\n      enableColumnPinning = false,\n      enableColumnResizing = false,\n      enableColumnVirtualization,\n      enableDensityToggle = true,\n      enableExpandAll = true,\n      enableExpanding,\n      enableFacetedValues = false,\n      enableFilterMatchHighlighting = true,\n      enableFilters = true,\n      enableFullScreenToggle = true,\n      enableGlobalFilter = true,\n      enableGlobalFilterRankedResults = true,\n      enableGrouping = false,\n      enableHiding = true,\n      enableMultiRowSelection = true,\n      enableMultiSort = true,\n      enablePagination = true,\n      enableRowPinning = false,\n      enableRowSelection = false,\n      enableRowVirtualization,\n      enableSelectAll = true,\n      enableSorting = true,\n      enableStickyHeader = false,\n      enableTableFooter = true,\n      enableTableHead = true,\n      enableToolbarInternalActions = true,\n      enableTopToolbar = true,\n      filterFns,\n      icons,\n      layoutMode,\n      localization,\n      manualFiltering,\n      manualGrouping,\n      manualPagination,\n      manualSorting,\n      mrtTheme,\n      paginationDisplayMode = 'default',\n      positionActionsColumn = 'first',\n      positionCreatingRow = 'top',\n      positionExpandColumn = 'first',\n      positionGlobalFilter = 'right',\n      positionPagination = 'bottom',\n      positionToolbarAlertBanner = 'top',\n      positionToolbarDropZone = 'top',\n      rowNumberDisplayMode = 'static',\n      rowPinningDisplayMode = 'sticky',\n      selectAllMode = 'page',\n      sortingFns\n    } = _a,\n    rest = __rest(_a, [\"aggregationFns\", \"autoResetExpanded\", \"columnFilterDisplayMode\", \"columnResizeDirection\", \"columnResizeMode\", \"createDisplayMode\", \"defaultColumn\", \"defaultDisplayColumn\", \"editDisplayMode\", \"enableBatchRowSelection\", \"enableBottomToolbar\", \"enableColumnActions\", \"enableColumnFilters\", \"enableColumnOrdering\", \"enableColumnPinning\", \"enableColumnResizing\", \"enableColumnVirtualization\", \"enableDensityToggle\", \"enableExpandAll\", \"enableExpanding\", \"enableFacetedValues\", \"enableFilterMatchHighlighting\", \"enableFilters\", \"enableFullScreenToggle\", \"enableGlobalFilter\", \"enableGlobalFilterRankedResults\", \"enableGrouping\", \"enableHiding\", \"enableMultiRowSelection\", \"enableMultiSort\", \"enablePagination\", \"enableRowPinning\", \"enableRowSelection\", \"enableRowVirtualization\", \"enableSelectAll\", \"enableSorting\", \"enableStickyHeader\", \"enableTableFooter\", \"enableTableHead\", \"enableToolbarInternalActions\", \"enableTopToolbar\", \"filterFns\", \"icons\", \"layoutMode\", \"localization\", \"manualFiltering\", \"manualGrouping\", \"manualPagination\", \"manualSorting\", \"mrtTheme\", \"paginationDisplayMode\", \"positionActionsColumn\", \"positionCreatingRow\", \"positionExpandColumn\", \"positionGlobalFilter\", \"positionPagination\", \"positionToolbarAlertBanner\", \"positionToolbarDropZone\", \"rowNumberDisplayMode\", \"rowPinningDisplayMode\", \"selectAllMode\", \"sortingFns\"]);\n  const theme = useTheme();\n  icons = useMemo(() => Object.assign(Object.assign({}, MRT_Default_Icons), icons), [icons]);\n  localization = useMemo(() => Object.assign(Object.assign({}, MRT_Localization_EN), localization), [localization]);\n  mrtTheme = useMemo(() => getMRTTheme(mrtTheme, theme), [mrtTheme, theme]);\n  aggregationFns = useMemo(() => Object.assign(Object.assign({}, MRT_AggregationFns), aggregationFns), []);\n  filterFns = useMemo(() => Object.assign(Object.assign({}, MRT_FilterFns), filterFns), []);\n  sortingFns = useMemo(() => Object.assign(Object.assign({}, MRT_SortingFns), sortingFns), []);\n  defaultColumn = useMemo(() => Object.assign(Object.assign({}, MRT_DefaultColumn), defaultColumn), [defaultColumn]);\n  defaultDisplayColumn = useMemo(() => Object.assign(Object.assign({}, MRT_DefaultDisplayColumn), defaultDisplayColumn), [defaultDisplayColumn]);\n  //cannot be changed after initialization\n  [enableColumnVirtualization, enableRowVirtualization] = useMemo(() => [enableColumnVirtualization, enableRowVirtualization], []);\n  if (!columnResizeDirection) {\n    columnResizeDirection = theme.direction || 'ltr';\n  }\n  layoutMode = layoutMode || (enableColumnResizing ? 'grid-no-grow' : 'semantic');\n  if (layoutMode === 'semantic' && (enableRowVirtualization || enableColumnVirtualization)) {\n    layoutMode = 'grid';\n  }\n  if (enableRowVirtualization) {\n    enableStickyHeader = true;\n  }\n  if (enablePagination === false && manualPagination === undefined) {\n    manualPagination = true;\n  }\n  if (!((_b = rest.data) === null || _b === void 0 ? void 0 : _b.length)) {\n    manualFiltering = true;\n    manualGrouping = true;\n    manualPagination = true;\n    manualSorting = true;\n  }\n  return Object.assign({\n    aggregationFns,\n    autoResetExpanded,\n    columnFilterDisplayMode,\n    columnResizeDirection,\n    columnResizeMode,\n    createDisplayMode,\n    defaultColumn,\n    defaultDisplayColumn,\n    editDisplayMode,\n    enableBatchRowSelection,\n    enableBottomToolbar,\n    enableColumnActions,\n    enableColumnFilters,\n    enableColumnOrdering,\n    enableColumnPinning,\n    enableColumnResizing,\n    enableColumnVirtualization,\n    enableDensityToggle,\n    enableExpandAll,\n    enableExpanding,\n    enableFacetedValues,\n    enableFilterMatchHighlighting,\n    enableFilters,\n    enableFullScreenToggle,\n    enableGlobalFilter,\n    enableGlobalFilterRankedResults,\n    enableGrouping,\n    enableHiding,\n    enableMultiRowSelection,\n    enableMultiSort,\n    enablePagination,\n    enableRowPinning,\n    enableRowSelection,\n    enableRowVirtualization,\n    enableSelectAll,\n    enableSorting,\n    enableStickyHeader,\n    enableTableFooter,\n    enableTableHead,\n    enableToolbarInternalActions,\n    enableTopToolbar,\n    filterFns,\n    getCoreRowModel: getCoreRowModel(),\n    getExpandedRowModel: enableExpanding || enableGrouping ? getExpandedRowModel() : undefined,\n    getFacetedMinMaxValues: enableFacetedValues ? getFacetedMinMaxValues() : undefined,\n    getFacetedRowModel: enableFacetedValues ? getFacetedRowModel() : undefined,\n    getFacetedUniqueValues: enableFacetedValues ? getFacetedUniqueValues() : undefined,\n    getFilteredRowModel: (enableColumnFilters || enableGlobalFilter || enableFilters) && !manualFiltering ? getFilteredRowModel() : undefined,\n    getGroupedRowModel: enableGrouping && !manualGrouping ? getGroupedRowModel() : undefined,\n    getPaginationRowModel: enablePagination && !manualPagination ? getPaginationRowModel() : undefined,\n    getSortedRowModel: enableSorting && !manualSorting ? getSortedRowModel() : undefined,\n    getSubRows: row => row === null || row === void 0 ? void 0 : row.subRows,\n    icons,\n    layoutMode,\n    localization,\n    manualFiltering,\n    manualGrouping,\n    manualPagination,\n    manualSorting,\n    mrtTheme,\n    paginationDisplayMode,\n    positionActionsColumn,\n    positionCreatingRow,\n    positionExpandColumn,\n    positionGlobalFilter,\n    positionPagination,\n    positionToolbarAlertBanner,\n    positionToolbarDropZone,\n    rowNumberDisplayMode,\n    rowPinningDisplayMode,\n    selectAllMode,\n    sortingFns\n  }, rest);\n};\nconst blankColProps = {\n  children: null,\n  sx: {\n    minWidth: 0,\n    p: 0,\n    width: 0\n  }\n};\nconst getMRT_RowSpacerColumnDef = tableOptions => {\n  return Object.assign(Object.assign(Object.assign(Object.assign({}, defaultDisplayColumnProps({\n    id: 'mrt-row-spacer',\n    size: 0,\n    tableOptions\n  })), {\n    grow: true\n  }), MRT_DefaultDisplayColumn), {\n    muiTableBodyCellProps: blankColProps,\n    muiTableFooterCellProps: blankColProps,\n    muiTableHeadCellProps: blankColProps\n  });\n};\nconst useMRT_Effects = table => {\n  const {\n    getIsSomeRowsPinned,\n    getPrePaginationRowModel,\n    getState,\n    options: {\n      enablePagination,\n      enableRowPinning,\n      rowCount\n    }\n  } = table;\n  const {\n    columnOrder,\n    density,\n    globalFilter,\n    isFullScreen,\n    isLoading,\n    pagination,\n    showSkeletons,\n    sorting\n  } = getState();\n  const totalColumnCount = table.options.columns.length;\n  const totalRowCount = rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().rows.length;\n  const rerender = useReducer(() => ({}), {})[1];\n  const initialBodyHeight = useRef();\n  const previousTop = useRef();\n  useEffect(() => {\n    if (typeof window !== 'undefined') {\n      initialBodyHeight.current = document.body.style.height;\n    }\n  }, []);\n  //hide scrollbars when table is in full screen mode, preserve body scroll position after full screen exit\n  useEffect(() => {\n    if (typeof window !== 'undefined') {\n      if (isFullScreen) {\n        previousTop.current = document.body.getBoundingClientRect().top; //save scroll position\n        document.body.style.height = '100dvh'; //hide page scrollbars when table is in full screen mode\n      } else {\n        document.body.style.height = initialBodyHeight.current;\n        if (!previousTop.current) return;\n        //restore scroll position\n        window.scrollTo({\n          behavior: 'instant',\n          top: -1 * previousTop.current\n        });\n      }\n    }\n  }, [isFullScreen]);\n  //recalculate column order when columns change or features are toggled on/off\n  useEffect(() => {\n    if (totalColumnCount !== columnOrder.length) {\n      table.setColumnOrder(getDefaultColumnOrderIds(table.options));\n    }\n  }, [totalColumnCount]);\n  //if page index is out of bounds, set it to the last page\n  useEffect(() => {\n    if (!enablePagination || isLoading || showSkeletons) return;\n    const {\n      pageIndex,\n      pageSize\n    } = pagination;\n    const firstVisibleRowIndex = pageIndex * pageSize;\n    if (firstVisibleRowIndex >= totalRowCount) {\n      table.setPageIndex(Math.ceil(totalRowCount / pageSize) - 1);\n    }\n  }, [totalRowCount]);\n  //turn off sort when global filter is looking for ranked results\n  const appliedSort = useRef(sorting);\n  useEffect(() => {\n    if (sorting.length) {\n      appliedSort.current = sorting;\n    }\n  }, [sorting]);\n  useEffect(() => {\n    if (!getCanRankRows(table)) return;\n    if (globalFilter) {\n      table.setSorting([]);\n    } else {\n      table.setSorting(() => appliedSort.current || []);\n    }\n  }, [globalFilter]);\n  //fix pinned row top style when density changes\n  useEffect(() => {\n    if (enableRowPinning && getIsSomeRowsPinned()) {\n      setTimeout(() => {\n        rerender();\n      }, 150);\n    }\n  }, [density]);\n};\n\n/**\n * The MRT hook that wraps the TanStack useReactTable hook and adds additional functionality\n * @param definedTableOptions - table options with proper defaults set\n * @returns the MRT table instance\n */\nconst useMRT_TableInstance = definedTableOptions => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10;\n  const lastSelectedRowId = useRef(null);\n  const actionCellRef = useRef(null);\n  const bottomToolbarRef = useRef(null);\n  const editInputRefs = useRef({});\n  const filterInputRefs = useRef({});\n  const searchInputRef = useRef(null);\n  const tableContainerRef = useRef(null);\n  const tableHeadCellRefs = useRef({});\n  const tablePaperRef = useRef(null);\n  const topToolbarRef = useRef(null);\n  const tableHeadRef = useRef(null);\n  const tableFooterRef = useRef(null);\n  //transform initial state with proper column order\n  const initialState = useMemo(() => {\n    var _a, _b, _c;\n    const initState = (_a = definedTableOptions.initialState) !== null && _a !== void 0 ? _a : {};\n    initState.columnOrder = (_b = initState.columnOrder) !== null && _b !== void 0 ? _b : getDefaultColumnOrderIds(Object.assign(Object.assign({}, definedTableOptions), {\n      state: Object.assign(Object.assign({}, definedTableOptions.initialState), definedTableOptions.state)\n    }));\n    initState.globalFilterFn = (_c = definedTableOptions.globalFilterFn) !== null && _c !== void 0 ? _c : 'fuzzy';\n    return initState;\n  }, []);\n  definedTableOptions.initialState = initialState;\n  const [actionCell, setActionCell] = useState((_a = initialState.actionCell) !== null && _a !== void 0 ? _a : null);\n  const [creatingRow, _setCreatingRow] = useState((_b = initialState.creatingRow) !== null && _b !== void 0 ? _b : null);\n  const [columnFilterFns, setColumnFilterFns] = useState(() => Object.assign({}, ...getAllLeafColumnDefs(definedTableOptions.columns).map(col => {\n    var _a, _b, _c, _d;\n    return {\n      [getColumnId(col)]: col.filterFn instanceof Function ? (_a = col.filterFn.name) !== null && _a !== void 0 ? _a : 'custom' : (_d = (_b = col.filterFn) !== null && _b !== void 0 ? _b : (_c = initialState === null || initialState === void 0 ? void 0 : initialState.columnFilterFns) === null || _c === void 0 ? void 0 : _c[getColumnId(col)]) !== null && _d !== void 0 ? _d : getDefaultColumnFilterFn(col)\n    };\n  })));\n  const [columnOrder, onColumnOrderChange] = useState((_c = initialState.columnOrder) !== null && _c !== void 0 ? _c : []);\n  const [columnSizingInfo, onColumnSizingInfoChange] = useState((_d = initialState.columnSizingInfo) !== null && _d !== void 0 ? _d : {});\n  const [density, setDensity] = useState((_e = initialState === null || initialState === void 0 ? void 0 : initialState.density) !== null && _e !== void 0 ? _e : 'comfortable');\n  const [draggingColumn, setDraggingColumn] = useState((_f = initialState.draggingColumn) !== null && _f !== void 0 ? _f : null);\n  const [draggingRow, setDraggingRow] = useState((_g = initialState.draggingRow) !== null && _g !== void 0 ? _g : null);\n  const [editingCell, setEditingCell] = useState((_h = initialState.editingCell) !== null && _h !== void 0 ? _h : null);\n  const [editingRow, setEditingRow] = useState((_j = initialState.editingRow) !== null && _j !== void 0 ? _j : null);\n  const [globalFilterFn, setGlobalFilterFn] = useState((_k = initialState.globalFilterFn) !== null && _k !== void 0 ? _k : 'fuzzy');\n  const [grouping, onGroupingChange] = useState((_l = initialState.grouping) !== null && _l !== void 0 ? _l : []);\n  const [hoveredColumn, setHoveredColumn] = useState((_m = initialState.hoveredColumn) !== null && _m !== void 0 ? _m : null);\n  const [hoveredRow, setHoveredRow] = useState((_o = initialState.hoveredRow) !== null && _o !== void 0 ? _o : null);\n  const [isFullScreen, setIsFullScreen] = useState((_p = initialState === null || initialState === void 0 ? void 0 : initialState.isFullScreen) !== null && _p !== void 0 ? _p : false);\n  const [pagination, onPaginationChange] = useState((_q = initialState === null || initialState === void 0 ? void 0 : initialState.pagination) !== null && _q !== void 0 ? _q : {\n    pageIndex: 0,\n    pageSize: 10\n  });\n  const [showAlertBanner, setShowAlertBanner] = useState((_r = initialState === null || initialState === void 0 ? void 0 : initialState.showAlertBanner) !== null && _r !== void 0 ? _r : false);\n  const [showColumnFilters, setShowColumnFilters] = useState((_s = initialState === null || initialState === void 0 ? void 0 : initialState.showColumnFilters) !== null && _s !== void 0 ? _s : false);\n  const [showGlobalFilter, setShowGlobalFilter] = useState((_t = initialState === null || initialState === void 0 ? void 0 : initialState.showGlobalFilter) !== null && _t !== void 0 ? _t : false);\n  const [showToolbarDropZone, setShowToolbarDropZone] = useState((_u = initialState === null || initialState === void 0 ? void 0 : initialState.showToolbarDropZone) !== null && _u !== void 0 ? _u : false);\n  definedTableOptions.state = Object.assign({\n    actionCell,\n    columnFilterFns,\n    columnOrder,\n    columnSizingInfo,\n    creatingRow,\n    density,\n    draggingColumn,\n    draggingRow,\n    editingCell,\n    editingRow,\n    globalFilterFn,\n    grouping,\n    hoveredColumn,\n    hoveredRow,\n    isFullScreen,\n    pagination,\n    showAlertBanner,\n    showColumnFilters,\n    showGlobalFilter,\n    showToolbarDropZone\n  }, definedTableOptions.state);\n  //The table options now include all state needed to help determine column visibility and order logic\n  const statefulTableOptions = definedTableOptions;\n  //don't recompute columnDefs while resizing column or dragging column/row\n  const columnDefsRef = useRef([]);\n  statefulTableOptions.columns = statefulTableOptions.state.columnSizingInfo.isResizingColumn || statefulTableOptions.state.draggingColumn || statefulTableOptions.state.draggingRow ? columnDefsRef.current : prepareColumns({\n    columnDefs: [...[showRowPinningColumn(statefulTableOptions) && getMRT_RowPinningColumnDef(statefulTableOptions), showRowDragColumn(statefulTableOptions) && getMRT_RowDragColumnDef(statefulTableOptions), showRowActionsColumn(statefulTableOptions) && getMRT_RowActionsColumnDef(statefulTableOptions), showRowExpandColumn(statefulTableOptions) && getMRT_RowExpandColumnDef(statefulTableOptions), showRowSelectionColumn(statefulTableOptions) && getMRT_RowSelectColumnDef(statefulTableOptions), showRowNumbersColumn(statefulTableOptions) && getMRT_RowNumbersColumnDef(statefulTableOptions)].filter(Boolean), ...statefulTableOptions.columns, ...[showRowSpacerColumn(statefulTableOptions) && getMRT_RowSpacerColumnDef(statefulTableOptions)].filter(Boolean)],\n    tableOptions: statefulTableOptions\n  });\n  columnDefsRef.current = statefulTableOptions.columns;\n  //if loading, generate blank rows to show skeleton loaders\n  statefulTableOptions.data = useMemo(() => (statefulTableOptions.state.isLoading || statefulTableOptions.state.showSkeletons) && !statefulTableOptions.data.length ? [...Array(Math.min(statefulTableOptions.state.pagination.pageSize, 20)).fill(null)].map(() => Object.assign({}, ...getAllLeafColumnDefs(statefulTableOptions.columns).map(col => ({\n    [getColumnId(col)]: null\n  })))) : statefulTableOptions.data, [statefulTableOptions.data, statefulTableOptions.state.isLoading, statefulTableOptions.state.showSkeletons]);\n  //@ts-ignore\n  const table = useReactTable(Object.assign(Object.assign({\n    onColumnOrderChange,\n    onColumnSizingInfoChange,\n    onGroupingChange,\n    onPaginationChange\n  }, statefulTableOptions), {\n    globalFilterFn: (_v = statefulTableOptions.filterFns) === null || _v === void 0 ? void 0 : _v[globalFilterFn !== null && globalFilterFn !== void 0 ? globalFilterFn : 'fuzzy']\n  }));\n  table.refs = {\n    actionCellRef,\n    bottomToolbarRef,\n    editInputRefs,\n    filterInputRefs,\n    lastSelectedRowId,\n    searchInputRef,\n    tableContainerRef,\n    tableFooterRef,\n    tableHeadCellRefs,\n    tableHeadRef,\n    tablePaperRef,\n    topToolbarRef\n  };\n  table.setActionCell = (_w = statefulTableOptions.onActionCellChange) !== null && _w !== void 0 ? _w : setActionCell;\n  table.setCreatingRow = row => {\n    var _a, _b;\n    let _row = row;\n    if (row === true) {\n      _row = createRow(table);\n    }\n    (_b = (_a = statefulTableOptions === null || statefulTableOptions === void 0 ? void 0 : statefulTableOptions.onCreatingRowChange) === null || _a === void 0 ? void 0 : _a.call(statefulTableOptions, _row)) !== null && _b !== void 0 ? _b : _setCreatingRow(_row);\n  };\n  table.setColumnFilterFns = (_x = statefulTableOptions.onColumnFilterFnsChange) !== null && _x !== void 0 ? _x : setColumnFilterFns;\n  table.setDensity = (_y = statefulTableOptions.onDensityChange) !== null && _y !== void 0 ? _y : setDensity;\n  table.setDraggingColumn = (_z = statefulTableOptions.onDraggingColumnChange) !== null && _z !== void 0 ? _z : setDraggingColumn;\n  table.setDraggingRow = (_0 = statefulTableOptions.onDraggingRowChange) !== null && _0 !== void 0 ? _0 : setDraggingRow;\n  table.setEditingCell = (_1 = statefulTableOptions.onEditingCellChange) !== null && _1 !== void 0 ? _1 : setEditingCell;\n  table.setEditingRow = (_2 = statefulTableOptions.onEditingRowChange) !== null && _2 !== void 0 ? _2 : setEditingRow;\n  table.setGlobalFilterFn = (_3 = statefulTableOptions.onGlobalFilterFnChange) !== null && _3 !== void 0 ? _3 : setGlobalFilterFn;\n  table.setHoveredColumn = (_4 = statefulTableOptions.onHoveredColumnChange) !== null && _4 !== void 0 ? _4 : setHoveredColumn;\n  table.setHoveredRow = (_5 = statefulTableOptions.onHoveredRowChange) !== null && _5 !== void 0 ? _5 : setHoveredRow;\n  table.setIsFullScreen = (_6 = statefulTableOptions.onIsFullScreenChange) !== null && _6 !== void 0 ? _6 : setIsFullScreen;\n  table.setShowAlertBanner = (_7 = statefulTableOptions.onShowAlertBannerChange) !== null && _7 !== void 0 ? _7 : setShowAlertBanner;\n  table.setShowColumnFilters = (_8 = statefulTableOptions.onShowColumnFiltersChange) !== null && _8 !== void 0 ? _8 : setShowColumnFilters;\n  table.setShowGlobalFilter = (_9 = statefulTableOptions.onShowGlobalFilterChange) !== null && _9 !== void 0 ? _9 : setShowGlobalFilter;\n  table.setShowToolbarDropZone = (_10 = statefulTableOptions.onShowToolbarDropZoneChange) !== null && _10 !== void 0 ? _10 : setShowToolbarDropZone;\n  useMRT_Effects(table);\n  return table;\n};\nconst useMaterialReactTable = tableOptions => useMRT_TableInstance(useMRT_TableOptions(tableOptions));\nconst extraIndexRangeExtractor = (range, draggingIndex) => {\n  const newIndexes = defaultRangeExtractor(range);\n  if (draggingIndex === undefined) return newIndexes;\n  if (draggingIndex >= 0 && draggingIndex < Math.max(range.startIndex - range.overscan, 0)) {\n    newIndexes.unshift(draggingIndex);\n  }\n  if (draggingIndex >= 0 && draggingIndex > range.endIndex + range.overscan) {\n    newIndexes.push(draggingIndex);\n  }\n  return newIndexes;\n};\nconst useMRT_ColumnVirtualizer = table => {\n  var _a, _b, _c, _d;\n  const {\n    getState,\n    options: {\n      columnVirtualizerInstanceRef,\n      columnVirtualizerOptions,\n      enableColumnPinning,\n      enableColumnVirtualization\n    },\n    refs: {\n      tableContainerRef\n    }\n  } = table;\n  const {\n    columnPinning,\n    columnVisibility,\n    draggingColumn\n  } = getState();\n  if (!enableColumnVirtualization) return undefined;\n  const columnVirtualizerProps = parseFromValuesOrFunc(columnVirtualizerOptions, {\n    table\n  });\n  const visibleColumns = table.getVisibleLeafColumns();\n  const [leftPinnedIndexes, rightPinnedIndexes] = useMemo(() => enableColumnPinning ? [table.getLeftVisibleLeafColumns().map(c => c.getPinnedIndex()), table.getRightVisibleLeafColumns().map(column => visibleColumns.length - column.getPinnedIndex() - 1).sort((a, b) => a - b)] : [[], []], [columnPinning, columnVisibility, enableColumnPinning]);\n  const numPinnedLeft = leftPinnedIndexes.length;\n  const numPinnedRight = rightPinnedIndexes.length;\n  const draggingColumnIndex = useMemo(() => (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) ? visibleColumns.findIndex(c => c.id === (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id)) : undefined, [draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id]);\n  const columnVirtualizer = useVirtualizer(Object.assign({\n    count: visibleColumns.length,\n    estimateSize: index => visibleColumns[index].getSize(),\n    getScrollElement: () => tableContainerRef.current,\n    horizontal: true,\n    overscan: 3,\n    rangeExtractor: useCallback(range => {\n      const newIndexes = extraIndexRangeExtractor(range, draggingColumnIndex);\n      if (!numPinnedLeft && !numPinnedRight) {\n        return newIndexes;\n      }\n      return [...new Set([...leftPinnedIndexes, ...newIndexes, ...rightPinnedIndexes])];\n    }, [leftPinnedIndexes, rightPinnedIndexes, draggingColumnIndex])\n  }, columnVirtualizerProps));\n  const virtualColumns = columnVirtualizer.getVirtualItems();\n  columnVirtualizer.virtualColumns = virtualColumns;\n  const numColumns = virtualColumns.length;\n  if (numColumns) {\n    const totalSize = columnVirtualizer.getTotalSize();\n    const leftNonPinnedStart = ((_a = virtualColumns[numPinnedLeft]) === null || _a === void 0 ? void 0 : _a.start) || 0;\n    const leftNonPinnedEnd = ((_b = virtualColumns[leftPinnedIndexes.length - 1]) === null || _b === void 0 ? void 0 : _b.end) || 0;\n    const rightNonPinnedStart = ((_c = virtualColumns[numColumns - numPinnedRight]) === null || _c === void 0 ? void 0 : _c.start) || 0;\n    const rightNonPinnedEnd = ((_d = virtualColumns[numColumns - numPinnedRight - 1]) === null || _d === void 0 ? void 0 : _d.end) || 0;\n    columnVirtualizer.virtualPaddingLeft = leftNonPinnedStart - leftNonPinnedEnd;\n    columnVirtualizer.virtualPaddingRight = totalSize - rightNonPinnedEnd - (numPinnedRight ? totalSize - rightNonPinnedStart : 0);\n  }\n  if (columnVirtualizerInstanceRef) {\n    //@ts-ignore\n    columnVirtualizerInstanceRef.current = columnVirtualizer;\n  }\n  return columnVirtualizer;\n};\nconst useMRT_RowVirtualizer = (table, rows) => {\n  var _a;\n  const {\n    getRowModel,\n    getState,\n    options: {\n      enableRowVirtualization,\n      renderDetailPanel,\n      rowVirtualizerInstanceRef,\n      rowVirtualizerOptions\n    },\n    refs: {\n      tableContainerRef\n    }\n  } = table;\n  const {\n    density,\n    draggingRow,\n    expanded\n  } = getState();\n  if (!enableRowVirtualization) return undefined;\n  const rowVirtualizerProps = parseFromValuesOrFunc(rowVirtualizerOptions, {\n    table\n  });\n  const rowCount = (_a = rows === null || rows === void 0 ? void 0 : rows.length) !== null && _a !== void 0 ? _a : getRowModel().rows.length;\n  const normalRowHeight = density === 'compact' ? 37 : density === 'comfortable' ? 58 : 73;\n  const rowVirtualizer = useVirtualizer(Object.assign({\n    count: renderDetailPanel ? rowCount * 2 : rowCount,\n    estimateSize: index => renderDetailPanel && index % 2 === 1 ? expanded === true ? 100 : 0 : normalRowHeight,\n    getScrollElement: () => tableContainerRef.current,\n    measureElement: typeof window !== 'undefined' && navigator.userAgent.indexOf('Firefox') === -1 ? element => element === null || element === void 0 ? void 0 : element.getBoundingClientRect().height : undefined,\n    overscan: 4,\n    rangeExtractor: useCallback(range => {\n      var _a;\n      return extraIndexRangeExtractor(range, (_a = draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.index) !== null && _a !== void 0 ? _a : 0);\n    }, [draggingRow])\n  }, rowVirtualizerProps));\n  rowVirtualizer.virtualRows = rowVirtualizer.getVirtualItems();\n  if (rowVirtualizerInstanceRef) {\n    //@ts-ignore\n    rowVirtualizerInstanceRef.current = rowVirtualizer;\n  }\n  return rowVirtualizer;\n};\nconst useMRT_Rows = table => {\n  const {\n    getRowModel,\n    getState,\n    options: {\n      data,\n      enableGlobalFilterRankedResults,\n      positionCreatingRow\n    }\n  } = table;\n  const {\n    creatingRow,\n    expanded,\n    globalFilter,\n    pagination,\n    rowPinning,\n    sorting\n  } = getState();\n  const rows = useMemo(() => getMRT_Rows(table), [creatingRow, data, enableGlobalFilterRankedResults, expanded, getRowModel().rows, globalFilter, pagination.pageIndex, pagination.pageSize, positionCreatingRow, rowPinning, sorting]);\n  return rows;\n};\nconst allowedTypes = ['string', 'number'];\nconst MRT_TableBodyCellValue = ({\n  cell,\n  rowRef,\n  staticColumnIndex,\n  staticRowIndex,\n  table\n}) => {\n  var _a, _b, _c;\n  const {\n    getState,\n    options: {\n      enableFilterMatchHighlighting,\n      mrtTheme: {\n        matchHighlightColor\n      }\n    }\n  } = table;\n  const {\n    column,\n    row\n  } = cell;\n  const {\n    columnDef\n  } = column;\n  const {\n    globalFilter,\n    globalFilterFn\n  } = getState();\n  const filterValue = column.getFilterValue();\n  let renderedCellValue = cell.getIsAggregated() && columnDef.AggregatedCell ? columnDef.AggregatedCell({\n    cell,\n    column,\n    row,\n    table\n  }) : row.getIsGrouped() && !cell.getIsGrouped() ? null : cell.getIsGrouped() && columnDef.GroupedCell ? columnDef.GroupedCell({\n    cell,\n    column,\n    row,\n    table\n  }) : undefined;\n  const isGroupedValue = renderedCellValue !== undefined;\n  if (!isGroupedValue) {\n    renderedCellValue = cell.renderValue();\n  }\n  if (enableFilterMatchHighlighting && columnDef.enableFilterMatchHighlighting !== false && String(renderedCellValue) && allowedTypes.includes(typeof renderedCellValue) && (filterValue && allowedTypes.includes(typeof filterValue) && ['autocomplete', 'text'].includes(columnDef.filterVariant) || globalFilter && allowedTypes.includes(typeof globalFilter) && column.getCanGlobalFilter())) {\n    const chunks = highlightWords === null || highlightWords === void 0 ? void 0 : highlightWords({\n      matchExactly: (filterValue ? columnDef._filterFn : globalFilterFn) !== 'fuzzy',\n      query: ((_a = filterValue !== null && filterValue !== void 0 ? filterValue : globalFilter) !== null && _a !== void 0 ? _a : '').toString(),\n      text: renderedCellValue === null || renderedCellValue === void 0 ? void 0 : renderedCellValue.toString()\n    });\n    if ((chunks === null || chunks === void 0 ? void 0 : chunks.length) > 1 || ((_b = chunks === null || chunks === void 0 ? void 0 : chunks[0]) === null || _b === void 0 ? void 0 : _b.match)) {\n      renderedCellValue = jsx(\"span\", {\n        \"aria-label\": renderedCellValue,\n        role: \"note\",\n        children: (_c = chunks === null || chunks === void 0 ? void 0 : chunks.map(({\n          key,\n          match,\n          text\n        }) => jsx(Box, {\n          \"aria-hidden\": \"true\",\n          component: \"span\",\n          sx: match ? {\n            backgroundColor: matchHighlightColor,\n            borderRadius: '2px',\n            color: theme => theme.palette.mode === 'dark' ? theme.palette.common.white : theme.palette.common.black,\n            padding: '2px 1px'\n          } : undefined,\n          children: text\n        }, key))) !== null && _c !== void 0 ? _c : renderedCellValue\n      });\n    }\n  }\n  if (columnDef.Cell && !isGroupedValue) {\n    renderedCellValue = columnDef.Cell({\n      cell,\n      column,\n      renderedCellValue,\n      row,\n      rowRef,\n      staticColumnIndex,\n      staticRowIndex,\n      table\n    });\n  }\n  return renderedCellValue;\n};\nconst MRT_CopyButton = _a => {\n  var _b;\n  var {\n      cell,\n      table\n    } = _a,\n    rest = __rest(_a, [\"cell\", \"table\"]);\n  const {\n    options: {\n      localization,\n      muiCopyButtonProps\n    }\n  } = table;\n  const {\n    column,\n    row\n  } = cell;\n  const {\n    columnDef\n  } = column;\n  const [copied, setCopied] = useState(false);\n  const handleCopy = (event, text) => {\n    event.stopPropagation();\n    navigator.clipboard.writeText(text);\n    setCopied(true);\n    setTimeout(() => setCopied(false), 4000);\n  };\n  const buttonProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiCopyButtonProps, {\n    cell,\n    column,\n    row,\n    table\n  })), parseFromValuesOrFunc(columnDef.muiCopyButtonProps, {\n    cell,\n    column,\n    row,\n    table\n  })), rest);\n  return jsx(Tooltip, Object.assign({}, getCommonTooltipProps('top'), {\n    title: (_b = buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.title) !== null && _b !== void 0 ? _b : copied ? localization.copiedToClipboard : localization.clickToCopy,\n    children: jsx(Button, Object.assign({\n      onClick: e => handleCopy(e, cell.getValue()),\n      size: \"small\",\n      type: \"button\",\n      variant: \"text\"\n    }, buttonProps, {\n      sx: theme => Object.assign({\n        backgroundColor: 'transparent',\n        border: 'none',\n        color: 'inherit',\n        cursor: 'copy',\n        fontFamily: 'inherit',\n        fontSize: 'inherit',\n        letterSpacing: 'inherit',\n        m: '-0.25rem',\n        minWidth: 'unset',\n        py: 0,\n        textAlign: 'inherit',\n        textTransform: 'inherit'\n      }, parseFromValuesOrFunc(buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.sx, theme)),\n      title: undefined\n    }))\n  }));\n};\nconst MRT_EditCellTextField = _a => {\n  var _b, _c;\n  var {\n      cell,\n      table\n    } = _a,\n    rest = __rest(_a, [\"cell\", \"table\"]);\n  const {\n    getState,\n    options: {\n      createDisplayMode,\n      editDisplayMode,\n      muiEditTextFieldProps\n    },\n    refs: {\n      editInputRefs\n    },\n    setCreatingRow,\n    setEditingCell,\n    setEditingRow\n  } = table;\n  const {\n    column,\n    row\n  } = cell;\n  const {\n    columnDef\n  } = column;\n  const {\n    creatingRow,\n    editingRow\n  } = getState();\n  const {\n    editSelectOptions,\n    editVariant\n  } = columnDef;\n  const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;\n  const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;\n  const [value, setValue] = useState(() => cell.getValue());\n  const textFieldProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiEditTextFieldProps, {\n    cell,\n    column,\n    row,\n    table\n  })), parseFromValuesOrFunc(columnDef.muiEditTextFieldProps, {\n    cell,\n    column,\n    row,\n    table\n  })), rest);\n  const selectOptions = parseFromValuesOrFunc(editSelectOptions, {\n    cell,\n    column,\n    row,\n    table\n  });\n  const isSelectEdit = editVariant === 'select' || (textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.select);\n  const saveInputValueToRowCache = newValue => {\n    //@ts-ignore\n    row._valuesCache[column.id] = newValue;\n    if (isCreating) {\n      setCreatingRow(row);\n    } else if (isEditing) {\n      setEditingRow(row);\n    }\n  };\n  const handleChange = event => {\n    var _a;\n    (_a = textFieldProps.onChange) === null || _a === void 0 ? void 0 : _a.call(textFieldProps, event);\n    setValue(event.target.value);\n    if (isSelectEdit) {\n      saveInputValueToRowCache(event.target.value);\n    }\n  };\n  const handleBlur = event => {\n    var _a;\n    (_a = textFieldProps.onBlur) === null || _a === void 0 ? void 0 : _a.call(textFieldProps, event);\n    saveInputValueToRowCache(value);\n    setEditingCell(null);\n  };\n  const handleEnterKeyDown = event => {\n    var _a, _b;\n    (_a = textFieldProps.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(textFieldProps, event);\n    if (event.key === 'Enter' && !event.shiftKey) {\n      (_b = editInputRefs.current[column.id]) === null || _b === void 0 ? void 0 : _b.blur();\n    }\n  };\n  if (columnDef.Edit) {\n    return jsx(Fragment, {\n      children: (_b = columnDef.Edit) === null || _b === void 0 ? void 0 : _b.call(columnDef, {\n        cell,\n        column,\n        row,\n        table\n      })\n    });\n  }\n  return jsx(TextField, Object.assign({\n    disabled: parseFromValuesOrFunc(columnDef.enableEditing, row) === false,\n    fullWidth: true,\n    inputRef: inputRef => {\n      if (inputRef) {\n        editInputRefs.current[column.id] = inputRef;\n        if (textFieldProps.inputRef) {\n          textFieldProps.inputRef = inputRef;\n        }\n      }\n    },\n    label: ['custom', 'modal'].includes(isCreating ? createDisplayMode : editDisplayMode) ? columnDef.header : undefined,\n    margin: \"none\",\n    name: column.id,\n    placeholder: !['custom', 'modal'].includes(isCreating ? createDisplayMode : editDisplayMode) ? columnDef.header : undefined,\n    select: isSelectEdit,\n    size: \"small\",\n    value: value !== null && value !== void 0 ? value : '',\n    variant: \"standard\"\n  }, textFieldProps, {\n    InputProps: Object.assign(Object.assign(Object.assign({}, textFieldProps.variant !== 'outlined' ? {\n      disableUnderline: editDisplayMode === 'table'\n    } : {}), textFieldProps.InputProps), {\n      sx: theme => {\n        var _a;\n        return Object.assign({\n          mb: 0\n        }, parseFromValuesOrFunc((_a = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.InputProps) === null || _a === void 0 ? void 0 : _a.sx, theme));\n      }\n    }),\n    SelectProps: {\n      MenuProps: {\n        disableScrollLock: true\n      }\n    },\n    inputProps: Object.assign({\n      autoComplete: 'new-password'\n    }, textFieldProps.inputProps),\n    onBlur: handleBlur,\n    onChange: handleChange,\n    onClick: e => {\n      var _a;\n      e.stopPropagation();\n      (_a = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.onClick) === null || _a === void 0 ? void 0 : _a.call(textFieldProps, e);\n    },\n    onKeyDown: handleEnterKeyDown,\n    children: (_c = textFieldProps.children) !== null && _c !== void 0 ? _c : selectOptions === null || selectOptions === void 0 ? void 0 : selectOptions.map(option => {\n      const {\n        label,\n        value\n      } = getValueAndLabel(option);\n      return jsx(MenuItem, {\n        sx: {\n          alignItems: 'center',\n          display: 'flex',\n          gap: '0.5rem',\n          m: 0\n        },\n        value: value,\n        children: label\n      }, value);\n    })\n  }));\n};\nconst MRT_TableBodyCell = _a => {\n  var _b, _c, _d, _e, _f;\n  var {\n      cell,\n      numRows,\n      rowRef,\n      staticColumnIndex,\n      staticRowIndex,\n      table\n    } = _a,\n    rest = __rest(_a, [\"cell\", \"numRows\", \"rowRef\", \"staticColumnIndex\", \"staticRowIndex\", \"table\"]);\n  const theme = useTheme();\n  const {\n    getState,\n    options: {\n      columnResizeDirection,\n      columnResizeMode,\n      createDisplayMode,\n      editDisplayMode,\n      enableCellActions,\n      enableClickToCopy,\n      enableColumnOrdering,\n      enableColumnPinning,\n      enableGrouping,\n      layoutMode,\n      mrtTheme: {\n        draggingBorderColor\n      },\n      muiSkeletonProps,\n      muiTableBodyCellProps\n    },\n    setHoveredColumn\n  } = table;\n  const {\n    actionCell,\n    columnSizingInfo,\n    creatingRow,\n    density,\n    draggingColumn,\n    draggingRow,\n    editingCell,\n    editingRow,\n    hoveredColumn,\n    hoveredRow,\n    isLoading,\n    showSkeletons\n  } = getState();\n  const {\n    column,\n    row\n  } = cell;\n  const {\n    columnDef\n  } = column;\n  const {\n    columnDefType\n  } = columnDef;\n  const args = {\n    cell,\n    column,\n    row,\n    table\n  };\n  const tableCellProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableBodyCellProps, args)), parseFromValuesOrFunc(columnDef.muiTableBodyCellProps, args)), rest);\n  const skeletonProps = parseFromValuesOrFunc(muiSkeletonProps, {\n    cell,\n    column,\n    row,\n    table\n  });\n  const [skeletonWidth, setSkeletonWidth] = useState(100);\n  useEffect(() => {\n    if (!isLoading && !showSkeletons || skeletonWidth !== 100) return;\n    const size = column.getSize();\n    setSkeletonWidth(columnDefType === 'display' ? size / 2 : Math.round(Math.random() * (size - size / 3) + size / 3));\n  }, [isLoading, showSkeletons]);\n  const draggingBorders = useMemo(() => {\n    const isDraggingColumn = (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id;\n    const isHoveredColumn = (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id;\n    const isDraggingRow = (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id) === row.id;\n    const isHoveredRow = (hoveredRow === null || hoveredRow === void 0 ? void 0 : hoveredRow.id) === row.id;\n    const isFirstColumn = column.getIsFirstColumn();\n    const isLastColumn = column.getIsLastColumn();\n    const isLastRow = numRows && staticRowIndex === numRows - 1;\n    const isResizingColumn = columnSizingInfo.isResizingColumn === column.id;\n    const showResizeBorder = isResizingColumn && columnResizeMode === 'onChange';\n    const borderStyle = showResizeBorder ? `2px solid ${draggingBorderColor} !important` : isDraggingColumn || isDraggingRow ? `1px dashed ${theme.palette.grey[500]} !important` : isHoveredColumn || isHoveredRow || isResizingColumn ? `2px dashed ${draggingBorderColor} !important` : undefined;\n    if (showResizeBorder) {\n      return columnResizeDirection === 'ltr' ? {\n        borderRight: borderStyle\n      } : {\n        borderLeft: borderStyle\n      };\n    }\n    return borderStyle ? {\n      borderBottom: isDraggingRow || isHoveredRow || isLastRow && !isResizingColumn ? borderStyle : undefined,\n      borderLeft: isDraggingColumn || isHoveredColumn || (isDraggingRow || isHoveredRow) && isFirstColumn ? borderStyle : undefined,\n      borderRight: isDraggingColumn || isHoveredColumn || (isDraggingRow || isHoveredRow) && isLastColumn ? borderStyle : undefined,\n      borderTop: isDraggingRow || isHoveredRow ? borderStyle : undefined\n    } : undefined;\n  }, [columnSizingInfo.isResizingColumn, draggingColumn, draggingRow, hoveredColumn, hoveredRow, staticRowIndex]);\n  const isColumnPinned = enableColumnPinning && columnDef.columnDefType !== 'group' && column.getIsPinned();\n  const isEditable = isCellEditable({\n    cell,\n    table\n  });\n  const isEditing = isEditable && !['custom', 'modal'].includes(editDisplayMode) && (editDisplayMode === 'table' || (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id || (editingCell === null || editingCell === void 0 ? void 0 : editingCell.id) === cell.id) && !row.getIsGrouped();\n  const isCreating = isEditable && createDisplayMode === 'row' && (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;\n  const showClickToCopyButton = (parseFromValuesOrFunc(enableClickToCopy, cell) === true || parseFromValuesOrFunc(columnDef.enableClickToCopy, cell) === true) && !['context-menu', false].includes(\n  // @ts-ignore\n  parseFromValuesOrFunc(columnDef.enableClickToCopy, cell));\n  const isRightClickable = parseFromValuesOrFunc(enableCellActions, cell);\n  const cellValueProps = {\n    cell,\n    table\n  };\n  const handleDoubleClick = event => {\n    var _a;\n    (_a = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onDoubleClick) === null || _a === void 0 ? void 0 : _a.call(tableCellProps, event);\n    openEditingCell({\n      cell,\n      table\n    });\n  };\n  const handleDragEnter = e => {\n    var _a;\n    (_a = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onDragEnter) === null || _a === void 0 ? void 0 : _a.call(tableCellProps, e);\n    if (enableGrouping && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone') {\n      setHoveredColumn(null);\n    }\n    if (enableColumnOrdering && draggingColumn) {\n      setHoveredColumn(columnDef.enableColumnOrdering !== false ? column : null);\n    }\n  };\n  const handleDragOver = e => {\n    if (columnDef.enableColumnOrdering !== false) {\n      e.preventDefault();\n    }\n  };\n  const handleContextMenu = e => {\n    var _a;\n    (_a = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onContextMenu) === null || _a === void 0 ? void 0 : _a.call(tableCellProps, e);\n    if (isRightClickable) {\n      e.preventDefault();\n      table.setActionCell(cell);\n      table.refs.actionCellRef.current = e.currentTarget;\n    }\n  };\n  return jsx(TableCell, Object.assign({\n    align: theme.direction === 'rtl' ? 'right' : 'left',\n    \"data-index\": staticColumnIndex,\n    \"data-pinned\": !!isColumnPinned || undefined\n  }, tableCellProps, {\n    onContextMenu: handleContextMenu,\n    onDoubleClick: handleDoubleClick,\n    onDragEnter: handleDragEnter,\n    onDragOver: handleDragOver,\n    sx: theme => Object.assign(Object.assign({\n      '&:hover': {\n        outline: (actionCell === null || actionCell === void 0 ? void 0 : actionCell.id) === cell.id || editDisplayMode === 'cell' && isEditable || editDisplayMode === 'table' && (isCreating || isEditing) ? `1px solid ${theme.palette.grey[500]}` : undefined,\n        textOverflow: 'clip'\n      },\n      alignItems: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'center' : undefined,\n      cursor: isRightClickable ? 'context-menu' : isEditable && editDisplayMode === 'cell' ? 'pointer' : 'inherit',\n      outline: (actionCell === null || actionCell === void 0 ? void 0 : actionCell.id) === cell.id ? `1px solid ${theme.palette.grey[500]}` : undefined,\n      outlineOffset: '-1px',\n      overflow: 'hidden',\n      p: density === 'compact' ? columnDefType === 'display' ? '0 0.5rem' : '0.5rem' : density === 'comfortable' ? columnDefType === 'display' ? '0.5rem 0.75rem' : '1rem' : columnDefType === 'display' ? '1rem 1.25rem' : '1.5rem',\n      textOverflow: columnDefType !== 'display' ? 'ellipsis' : undefined,\n      whiteSpace: row.getIsPinned() || density === 'compact' ? 'nowrap' : 'normal'\n    }, getCommonMRTCellStyles({\n      column,\n      table,\n      tableCellProps,\n      theme\n    })), draggingBorders),\n    children: (_b = tableCellProps.children) !== null && _b !== void 0 ? _b : jsxs(Fragment, {\n      children: [cell.getIsPlaceholder() ? (_d = (_c = columnDef.PlaceholderCell) === null || _c === void 0 ? void 0 : _c.call(columnDef, {\n        cell,\n        column,\n        row,\n        table\n      })) !== null && _d !== void 0 ? _d : null : showSkeletons !== false && (isLoading || showSkeletons) ? jsx(Skeleton, Object.assign({\n        animation: \"wave\",\n        height: 20,\n        width: skeletonWidth\n      }, skeletonProps)) : columnDefType === 'display' && (['mrt-row-expand', 'mrt-row-numbers', 'mrt-row-select'].includes(column.id) || !row.getIsGrouped()) ? (_e = columnDef.Cell) === null || _e === void 0 ? void 0 : _e.call(columnDef, {\n        cell,\n        column,\n        renderedCellValue: cell.renderValue(),\n        row,\n        rowRef,\n        staticColumnIndex,\n        staticRowIndex,\n        table\n      }) : isCreating || isEditing ? jsx(MRT_EditCellTextField, {\n        cell: cell,\n        table: table\n      }) : showClickToCopyButton && columnDef.enableClickToCopy !== false ? jsx(MRT_CopyButton, {\n        cell: cell,\n        table: table,\n        children: jsx(MRT_TableBodyCellValue, Object.assign({}, cellValueProps))\n      }) : jsx(MRT_TableBodyCellValue, Object.assign({}, cellValueProps)), cell.getIsGrouped() && !columnDef.GroupedCell && jsxs(Fragment, {\n        children: [\" (\", (_f = row.subRows) === null || _f === void 0 ? void 0 : _f.length, \")\"]\n      })]\n    })\n  }));\n};\nconst Memo_MRT_TableBodyCell = memo(MRT_TableBodyCell, (prev, next) => next.cell === prev.cell);\nconst MRT_TableDetailPanel = _a => {\n  var {\n      parentRowRef,\n      row,\n      rowVirtualizer,\n      staticRowIndex,\n      table,\n      virtualRow\n    } = _a,\n    rest = __rest(_a, [\"parentRowRef\", \"row\", \"rowVirtualizer\", \"staticRowIndex\", \"table\", \"virtualRow\"]);\n  const {\n    getState,\n    getVisibleLeafColumns,\n    options: {\n      layoutMode,\n      mrtTheme: {\n        baseBackgroundColor\n      },\n      muiDetailPanelProps,\n      muiTableBodyRowProps,\n      renderDetailPanel\n    }\n  } = table;\n  const {\n    isLoading\n  } = getState();\n  const tableRowProps = parseFromValuesOrFunc(muiTableBodyRowProps, {\n    isDetailPanel: true,\n    row,\n    staticRowIndex,\n    table\n  });\n  const tableCellProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiDetailPanelProps, {\n    row,\n    table\n  })), rest);\n  const DetailPanel = !isLoading && (renderDetailPanel === null || renderDetailPanel === void 0 ? void 0 : renderDetailPanel({\n    row,\n    table\n  }));\n  return jsx(TableRow, Object.assign({\n    className: \"Mui-TableBodyCell-DetailPanel\",\n    \"data-index\": renderDetailPanel ? staticRowIndex * 2 + 1 : staticRowIndex,\n    ref: node => {\n      var _a;\n      if (node) {\n        (_a = rowVirtualizer === null || rowVirtualizer === void 0 ? void 0 : rowVirtualizer.measureElement) === null || _a === void 0 ? void 0 : _a.call(rowVirtualizer, node);\n      }\n    }\n  }, tableRowProps, {\n    sx: theme => {\n      var _a, _b;\n      return Object.assign({\n        display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'flex' : undefined,\n        position: virtualRow ? 'absolute' : undefined,\n        top: virtualRow ? `${(_b = (_a = parentRowRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) === null || _b === void 0 ? void 0 : _b.height}px` : undefined,\n        transform: virtualRow ? `translateY(${virtualRow === null || virtualRow === void 0 ? void 0 : virtualRow.start}px)` : undefined,\n        width: '100%'\n      }, parseFromValuesOrFunc(tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx, theme));\n    },\n    children: jsx(TableCell, Object.assign({\n      className: \"Mui-TableBodyCell-DetailPanel\",\n      colSpan: getVisibleLeafColumns().length\n    }, tableCellProps, {\n      sx: theme => Object.assign({\n        backgroundColor: virtualRow ? baseBackgroundColor : undefined,\n        borderBottom: !row.getIsExpanded() ? 'none' : undefined,\n        display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'flex' : undefined,\n        py: !!DetailPanel && row.getIsExpanded() ? '1rem' : 0,\n        transition: !virtualRow ? 'all 150ms ease-in-out' : undefined,\n        width: `100%`\n      }, parseFromValuesOrFunc(tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx, theme)),\n      children: virtualRow ? row.getIsExpanded() && DetailPanel : jsx(Collapse, {\n        in: row.getIsExpanded(),\n        mountOnEnter: true,\n        unmountOnExit: true,\n        children: DetailPanel\n      })\n    }))\n  }));\n};\nconst MRT_TableBodyRow = _a => {\n  var _b, _c, _d, _f;\n  var {\n      columnVirtualizer,\n      numRows,\n      pinnedRowIds,\n      row,\n      rowVirtualizer,\n      staticRowIndex,\n      table,\n      virtualRow\n    } = _a,\n    rest = __rest(_a, [\"columnVirtualizer\", \"numRows\", \"pinnedRowIds\", \"row\", \"rowVirtualizer\", \"staticRowIndex\", \"table\", \"virtualRow\"]);\n  const theme = useTheme();\n  const {\n    getState,\n    options: {\n      enableRowOrdering,\n      enableRowPinning,\n      enableStickyFooter,\n      enableStickyHeader,\n      layoutMode,\n      memoMode,\n      mrtTheme: {\n        baseBackgroundColor,\n        pinnedRowBackgroundColor,\n        selectedRowBackgroundColor\n      },\n      muiTableBodyRowProps,\n      renderDetailPanel,\n      rowPinningDisplayMode\n    },\n    refs: {\n      tableFooterRef,\n      tableHeadRef\n    },\n    setHoveredRow\n  } = table;\n  const {\n    density,\n    draggingColumn,\n    draggingRow,\n    editingCell,\n    editingRow,\n    hoveredRow,\n    isFullScreen,\n    rowPinning\n  } = getState();\n  const visibleCells = row.getVisibleCells();\n  const {\n    virtualColumns,\n    virtualPaddingLeft,\n    virtualPaddingRight\n  } = columnVirtualizer !== null && columnVirtualizer !== void 0 ? columnVirtualizer : {};\n  const isRowSelected = getIsRowSelected({\n    row,\n    table\n  });\n  const isRowPinned = enableRowPinning && row.getIsPinned();\n  const isDraggingRow = (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id) === row.id;\n  const isHoveredRow = (hoveredRow === null || hoveredRow === void 0 ? void 0 : hoveredRow.id) === row.id;\n  const tableRowProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableBodyRowProps, {\n    row,\n    staticRowIndex,\n    table\n  })), rest);\n  const [bottomPinnedIndex, topPinnedIndex] = useMemo(() => {\n    if (!enableRowPinning || !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky')) || !pinnedRowIds || !row.getIsPinned()) return [];\n    return [[...pinnedRowIds].reverse().indexOf(row.id), pinnedRowIds.indexOf(row.id)];\n  }, [pinnedRowIds, rowPinning]);\n  const tableHeadHeight = (enableStickyHeader || isFullScreen) && ((_b = tableHeadRef.current) === null || _b === void 0 ? void 0 : _b.clientHeight) || 0;\n  const tableFooterHeight = enableStickyFooter && ((_c = tableFooterRef.current) === null || _c === void 0 ? void 0 : _c.clientHeight) || 0;\n  const sx = parseFromValuesOrFunc(tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx, theme);\n  const defaultRowHeight = density === 'compact' ? 37 : density === 'comfortable' ? 53 : 69;\n  const customRowHeight =\n  // @ts-ignore\n  parseInt((_f = (_d = tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.style) === null || _d === void 0 ? void 0 : _d.height) !== null && _f !== void 0 ? _f : sx === null || sx === void 0 ? void 0 : sx.height, 10) || undefined;\n  const rowHeight = customRowHeight || defaultRowHeight;\n  const handleDragEnter = _e => {\n    if (enableRowOrdering && draggingRow) {\n      setHoveredRow(row);\n    }\n  };\n  const handleDragOver = e => {\n    e.preventDefault();\n  };\n  const rowRef = useRef(null);\n  const cellHighlightColor = isRowSelected ? selectedRowBackgroundColor : isRowPinned ? pinnedRowBackgroundColor : undefined;\n  const cellHighlightColorHover = (tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.hover) !== false ? isRowSelected ? cellHighlightColor : theme.palette.mode === 'dark' ? `${lighten(baseBackgroundColor, 0.3)}` : `${darken(baseBackgroundColor, 0.3)}` : undefined;\n  return jsxs(Fragment, {\n    children: [jsxs(TableRow, Object.assign({\n      \"data-index\": renderDetailPanel ? staticRowIndex * 2 : staticRowIndex,\n      \"data-pinned\": !!isRowPinned || undefined,\n      \"data-selected\": isRowSelected || undefined,\n      onDragEnter: handleDragEnter,\n      onDragOver: handleDragOver,\n      ref: node => {\n        if (node) {\n          rowRef.current = node;\n          rowVirtualizer === null || rowVirtualizer === void 0 ? void 0 : rowVirtualizer.measureElement(node);\n        }\n      },\n      selected: isRowSelected\n    }, tableRowProps, {\n      style: Object.assign({\n        transform: virtualRow ? `translateY(${virtualRow.start}px)` : undefined\n      }, tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.style),\n      sx: theme => Object.assign({\n        '&:hover td:after': cellHighlightColorHover ? Object.assign({\n          backgroundColor: alpha(cellHighlightColorHover, 0.3)\n        }, commonCellBeforeAfterStyles) : undefined,\n        backgroundColor: `${baseBackgroundColor} !important`,\n        bottom: !virtualRow && bottomPinnedIndex !== undefined && isRowPinned ? `${bottomPinnedIndex * rowHeight + (enableStickyFooter ? tableFooterHeight - 1 : 0)}px` : undefined,\n        boxSizing: 'border-box',\n        display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'flex' : undefined,\n        opacity: isRowPinned ? 0.97 : isDraggingRow || isHoveredRow ? 0.5 : 1,\n        position: virtualRow ? 'absolute' : (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky')) && isRowPinned ? 'sticky' : 'relative',\n        td: Object.assign({}, getCommonPinnedCellStyles({\n          table,\n          theme\n        })),\n        'td:after': cellHighlightColor ? Object.assign({\n          backgroundColor: cellHighlightColor\n        }, commonCellBeforeAfterStyles) : undefined,\n        top: virtualRow ? 0 : topPinnedIndex !== undefined && isRowPinned ? `${topPinnedIndex * rowHeight + (enableStickyHeader || isFullScreen ? tableHeadHeight - 1 : 0)}px` : undefined,\n        transition: virtualRow ? 'none' : 'all 150ms ease-in-out',\n        width: '100%',\n        zIndex: (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky')) && isRowPinned ? 2 : 0\n      }, sx),\n      children: [virtualPaddingLeft ? jsx(\"td\", {\n        style: {\n          display: 'flex',\n          width: virtualPaddingLeft\n        }\n      }) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : visibleCells).map((cellOrVirtualCell, staticColumnIndex) => {\n        let cell = cellOrVirtualCell;\n        if (columnVirtualizer) {\n          staticColumnIndex = cellOrVirtualCell.index;\n          cell = visibleCells[staticColumnIndex];\n        }\n        const props = {\n          cell,\n          numRows,\n          rowRef,\n          staticColumnIndex,\n          staticRowIndex,\n          table\n        };\n        return cell ? memoMode === 'cells' && cell.column.columnDef.columnDefType === 'data' && !draggingColumn && !draggingRow && (editingCell === null || editingCell === void 0 ? void 0 : editingCell.id) !== cell.id && (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) !== row.id ? jsx(Memo_MRT_TableBodyCell, Object.assign({}, props), cell.id) : jsx(MRT_TableBodyCell, Object.assign({}, props), cell.id) : null;\n      }), virtualPaddingRight ? jsx(\"td\", {\n        style: {\n          display: 'flex',\n          width: virtualPaddingRight\n        }\n      }) : null]\n    })), renderDetailPanel && !row.getIsGrouped() && jsx(MRT_TableDetailPanel, {\n      parentRowRef: rowRef,\n      row: row,\n      rowVirtualizer: rowVirtualizer,\n      staticRowIndex: staticRowIndex,\n      table: table,\n      virtualRow: virtualRow\n    })]\n  });\n};\nconst Memo_MRT_TableBodyRow = memo(MRT_TableBodyRow, (prev, next) => prev.row === next.row && prev.staticRowIndex === next.staticRowIndex);\nconst MRT_TableBody = _a => {\n  var _b, _c, _d, _e, _f, _g;\n  var {\n      columnVirtualizer,\n      table\n    } = _a,\n    rest = __rest(_a, [\"columnVirtualizer\", \"table\"]);\n  const {\n    getBottomRows,\n    getIsSomeRowsPinned,\n    getRowModel,\n    getState,\n    getTopRows,\n    options: {\n      enableStickyFooter,\n      enableStickyHeader,\n      layoutMode,\n      localization,\n      memoMode,\n      muiTableBodyProps,\n      renderDetailPanel,\n      renderEmptyRowsFallback,\n      rowPinningDisplayMode\n    },\n    refs: {\n      tableFooterRef,\n      tableHeadRef,\n      tablePaperRef\n    }\n  } = table;\n  const {\n    columnFilters,\n    globalFilter,\n    isFullScreen,\n    rowPinning\n  } = getState();\n  const tableBodyProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableBodyProps, {\n    table\n  })), rest);\n  const tableHeadHeight = (enableStickyHeader || isFullScreen) && ((_b = tableHeadRef.current) === null || _b === void 0 ? void 0 : _b.clientHeight) || 0;\n  const tableFooterHeight = enableStickyFooter && ((_c = tableFooterRef.current) === null || _c === void 0 ? void 0 : _c.clientHeight) || 0;\n  const pinnedRowIds = useMemo(() => {\n    var _a, _b;\n    if (!((_a = rowPinning.bottom) === null || _a === void 0 ? void 0 : _a.length) && !((_b = rowPinning.top) === null || _b === void 0 ? void 0 : _b.length)) return [];\n    return getRowModel().rows.filter(row => row.getIsPinned()).map(r => r.id);\n  }, [rowPinning, getRowModel().rows]);\n  const rows = useMRT_Rows(table);\n  const rowVirtualizer = useMRT_RowVirtualizer(table, rows);\n  const {\n    virtualRows\n  } = rowVirtualizer !== null && rowVirtualizer !== void 0 ? rowVirtualizer : {};\n  const commonRowProps = {\n    columnVirtualizer,\n    numRows: rows.length,\n    table\n  };\n  return jsxs(Fragment, {\n    children: [!(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky')) && getIsSomeRowsPinned('top') && jsx(TableBody, Object.assign({}, tableBodyProps, {\n      sx: theme => Object.assign({\n        display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined,\n        position: 'sticky',\n        top: tableHeadHeight - 1,\n        zIndex: 1\n      }, parseFromValuesOrFunc(tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx, theme)),\n      children: getTopRows().map((row, staticRowIndex) => {\n        const props = Object.assign(Object.assign({}, commonRowProps), {\n          row,\n          staticRowIndex\n        });\n        return memoMode === 'rows' ? jsx(Memo_MRT_TableBodyRow, Object.assign({}, props), row.id) : jsx(MRT_TableBodyRow, Object.assign({}, props), row.id);\n      })\n    })), jsx(TableBody, Object.assign({}, tableBodyProps, {\n      sx: theme => Object.assign({\n        display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined,\n        height: rowVirtualizer ? `${rowVirtualizer.getTotalSize()}px` : undefined,\n        minHeight: !rows.length ? '100px' : undefined,\n        position: 'relative'\n      }, parseFromValuesOrFunc(tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx, theme)),\n      children: (_d = tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.children) !== null && _d !== void 0 ? _d : !rows.length ? jsx(\"tr\", {\n        style: {\n          display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined\n        },\n        children: jsx(\"td\", {\n          colSpan: table.getVisibleLeafColumns().length,\n          style: {\n            display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined\n          },\n          children: (_e = renderEmptyRowsFallback === null || renderEmptyRowsFallback === void 0 ? void 0 : renderEmptyRowsFallback({\n            table\n          })) !== null && _e !== void 0 ? _e : jsx(Typography, {\n            sx: {\n              color: 'text.secondary',\n              fontStyle: 'italic',\n              maxWidth: `min(100vw, ${(_g = (_f = tablePaperRef.current) === null || _f === void 0 ? void 0 : _f.clientWidth) !== null && _g !== void 0 ? _g : 360}px)`,\n              py: '2rem',\n              textAlign: 'center',\n              width: '100%'\n            },\n            children: globalFilter || columnFilters.length ? localization.noResultsFound : localization.noRecordsToDisplay\n          })\n        })\n      }) : jsx(Fragment, {\n        children: (virtualRows !== null && virtualRows !== void 0 ? virtualRows : rows).map((rowOrVirtualRow, staticRowIndex) => {\n          let row = rowOrVirtualRow;\n          if (rowVirtualizer) {\n            if (renderDetailPanel) {\n              if (rowOrVirtualRow.index % 2 === 1) {\n                return null;\n              } else {\n                staticRowIndex = rowOrVirtualRow.index / 2;\n              }\n            } else {\n              staticRowIndex = rowOrVirtualRow.index;\n            }\n            row = rows[staticRowIndex];\n          }\n          const props = Object.assign(Object.assign({}, commonRowProps), {\n            pinnedRowIds,\n            row,\n            rowVirtualizer,\n            staticRowIndex,\n            virtualRow: rowVirtualizer ? rowOrVirtualRow : undefined\n          });\n          const key = `${row.id}-${row.index}`;\n          return memoMode === 'rows' ? jsx(Memo_MRT_TableBodyRow, Object.assign({}, props), key) : jsx(MRT_TableBodyRow, Object.assign({}, props), key);\n        })\n      })\n    })), !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky')) && getIsSomeRowsPinned('bottom') && jsx(TableBody, Object.assign({}, tableBodyProps, {\n      sx: theme => Object.assign({\n        bottom: tableFooterHeight - 1,\n        display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined,\n        position: 'sticky',\n        zIndex: 1\n      }, parseFromValuesOrFunc(tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx, theme)),\n      children: getBottomRows().map((row, staticRowIndex) => {\n        const props = Object.assign(Object.assign({}, commonRowProps), {\n          row,\n          staticRowIndex\n        });\n        return memoMode === 'rows' ? jsx(Memo_MRT_TableBodyRow, Object.assign({}, props), row.id) : jsx(MRT_TableBodyRow, Object.assign({}, props), row.id);\n      })\n    }))]\n  });\n};\nconst Memo_MRT_TableBody = memo(MRT_TableBody, (prev, next) => prev.table.options.data === next.table.options.data);\nconst MRT_TableFooterCell = _a => {\n  var _b, _c, _d;\n  var {\n      footer,\n      staticColumnIndex,\n      table\n    } = _a,\n    rest = __rest(_a, [\"footer\", \"staticColumnIndex\", \"table\"]);\n  const theme = useTheme();\n  const {\n    getState,\n    options: {\n      enableColumnPinning,\n      muiTableFooterCellProps\n    }\n  } = table;\n  const {\n    density\n  } = getState();\n  const {\n    column\n  } = footer;\n  const {\n    columnDef\n  } = column;\n  const {\n    columnDefType\n  } = columnDef;\n  const isColumnPinned = enableColumnPinning && columnDef.columnDefType !== 'group' && column.getIsPinned();\n  const args = {\n    column,\n    table\n  };\n  const tableCellProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableFooterCellProps, args)), parseFromValuesOrFunc(columnDef.muiTableFooterCellProps, args)), rest);\n  return jsx(TableCell, Object.assign({\n    align: columnDefType === 'group' ? 'center' : theme.direction === 'rtl' ? 'right' : 'left',\n    colSpan: footer.colSpan,\n    \"data-index\": staticColumnIndex,\n    \"data-pinned\": !!isColumnPinned || undefined,\n    variant: \"footer\"\n  }, tableCellProps, {\n    sx: theme => Object.assign(Object.assign({\n      fontWeight: 'bold',\n      p: density === 'compact' ? '0.5rem' : density === 'comfortable' ? '1rem' : '1.5rem',\n      verticalAlign: 'top'\n    }, getCommonMRTCellStyles({\n      column,\n      header: footer,\n      table,\n      tableCellProps,\n      theme\n    })), parseFromValuesOrFunc(tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx, theme)),\n    children: (_b = tableCellProps.children) !== null && _b !== void 0 ? _b : footer.isPlaceholder ? null : (_d = (_c = parseFromValuesOrFunc(columnDef.Footer, {\n      column,\n      footer,\n      table\n    })) !== null && _c !== void 0 ? _c : columnDef.footer) !== null && _d !== void 0 ? _d : null\n  }));\n};\nconst MRT_TableFooterRow = _a => {\n  var _b;\n  var {\n      columnVirtualizer,\n      footerGroup,\n      table\n    } = _a,\n    rest = __rest(_a, [\"columnVirtualizer\", \"footerGroup\", \"table\"]);\n  const {\n    options: {\n      layoutMode,\n      mrtTheme: {\n        baseBackgroundColor\n      },\n      muiTableFooterRowProps\n    }\n  } = table;\n  const {\n    virtualColumns,\n    virtualPaddingLeft,\n    virtualPaddingRight\n  } = columnVirtualizer !== null && columnVirtualizer !== void 0 ? columnVirtualizer : {};\n  // if no content in row, skip row\n  if (!((_b = footerGroup.headers) === null || _b === void 0 ? void 0 : _b.some(header => typeof header.column.columnDef.footer === 'string' && !!header.column.columnDef.footer || header.column.columnDef.Footer))) {\n    return null;\n  }\n  const tableRowProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableFooterRowProps, {\n    footerGroup,\n    table\n  })), rest);\n  return jsxs(TableRow, Object.assign({}, tableRowProps, {\n    sx: theme => Object.assign({\n      backgroundColor: baseBackgroundColor,\n      display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'flex' : undefined,\n      position: 'relative',\n      width: '100%'\n    }, parseFromValuesOrFunc(tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx, theme)),\n    children: [virtualPaddingLeft ? jsx(\"th\", {\n      style: {\n        display: 'flex',\n        width: virtualPaddingLeft\n      }\n    }) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : footerGroup.headers).map((footerOrVirtualFooter, staticColumnIndex) => {\n      let footer = footerOrVirtualFooter;\n      if (columnVirtualizer) {\n        staticColumnIndex = footerOrVirtualFooter.index;\n        footer = footerGroup.headers[staticColumnIndex];\n      }\n      return footer ? jsx(MRT_TableFooterCell, {\n        footer: footer,\n        staticColumnIndex: staticColumnIndex,\n        table: table\n      }, footer.id) : null;\n    }), virtualPaddingRight ? jsx(\"th\", {\n      style: {\n        display: 'flex',\n        width: virtualPaddingRight\n      }\n    }) : null]\n  }));\n};\nconst MRT_TableFooter = _a => {\n  var {\n      columnVirtualizer,\n      table\n    } = _a,\n    rest = __rest(_a, [\"columnVirtualizer\", \"table\"]);\n  const {\n    getFooterGroups,\n    getState,\n    options: {\n      enableStickyFooter,\n      layoutMode,\n      muiTableFooterProps\n    },\n    refs: {\n      tableFooterRef\n    }\n  } = table;\n  const {\n    isFullScreen\n  } = getState();\n  const tableFooterProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableFooterProps, {\n    table\n  })), rest);\n  const stickFooter = (isFullScreen || enableStickyFooter) && enableStickyFooter !== false;\n  return jsx(TableFooter, Object.assign({}, tableFooterProps, {\n    ref: ref => {\n      tableFooterRef.current = ref;\n      if (tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.ref) {\n        // @ts-ignore\n        tableFooterProps.ref.current = ref;\n      }\n    },\n    sx: theme => Object.assign({\n      bottom: stickFooter ? 0 : undefined,\n      display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined,\n      opacity: stickFooter ? 0.97 : undefined,\n      outline: stickFooter ? theme.palette.mode === 'light' ? `1px solid ${theme.palette.grey[300]}` : `1px solid ${theme.palette.grey[700]}` : undefined,\n      position: stickFooter ? 'sticky' : 'relative',\n      zIndex: stickFooter ? 1 : undefined\n    }, parseFromValuesOrFunc(tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.sx, theme)),\n    children: getFooterGroups().map(footerGroup => jsx(MRT_TableFooterRow, {\n      columnVirtualizer: columnVirtualizer,\n      footerGroup: footerGroup,\n      table: table\n    }, footerGroup.id))\n  }));\n};\nconst mrtFilterOptions = localization => [{\n  divider: false,\n  label: localization.filterFuzzy,\n  option: 'fuzzy',\n  symbol: '≈'\n}, {\n  divider: false,\n  label: localization.filterContains,\n  option: 'contains',\n  symbol: '*'\n}, {\n  divider: false,\n  label: localization.filterStartsWith,\n  option: 'startsWith',\n  symbol: 'a'\n}, {\n  divider: true,\n  label: localization.filterEndsWith,\n  option: 'endsWith',\n  symbol: 'z'\n}, {\n  divider: false,\n  label: localization.filterEquals,\n  option: 'equals',\n  symbol: '='\n}, {\n  divider: true,\n  label: localization.filterNotEquals,\n  option: 'notEquals',\n  symbol: '≠'\n}, {\n  divider: false,\n  label: localization.filterBetween,\n  option: 'between',\n  symbol: '⇿'\n}, {\n  divider: true,\n  label: localization.filterBetweenInclusive,\n  option: 'betweenInclusive',\n  symbol: '⬌'\n}, {\n  divider: false,\n  label: localization.filterGreaterThan,\n  option: 'greaterThan',\n  symbol: '>'\n}, {\n  divider: false,\n  label: localization.filterGreaterThanOrEqualTo,\n  option: 'greaterThanOrEqualTo',\n  symbol: '≥'\n}, {\n  divider: false,\n  label: localization.filterLessThan,\n  option: 'lessThan',\n  symbol: '<'\n}, {\n  divider: true,\n  label: localization.filterLessThanOrEqualTo,\n  option: 'lessThanOrEqualTo',\n  symbol: '≤'\n}, {\n  divider: false,\n  label: localization.filterEmpty,\n  option: 'empty',\n  symbol: '∅'\n}, {\n  divider: false,\n  label: localization.filterNotEmpty,\n  option: 'notEmpty',\n  symbol: '!∅'\n}];\nconst rangeModes = ['between', 'betweenInclusive', 'inNumberRange'];\nconst emptyModes = ['empty', 'notEmpty'];\nconst arrModes = ['arrIncludesSome', 'arrIncludesAll', 'arrIncludes'];\nconst rangeVariants = ['range-slider', 'date-range', 'datetime-range', 'range'];\nconst MRT_FilterOptionMenu = _a => {\n  var _b, _c, _d, _e;\n  var {\n      anchorEl,\n      header,\n      onSelect,\n      setAnchorEl,\n      setFilterValue,\n      table\n    } = _a,\n    rest = __rest(_a, [\"anchorEl\", \"header\", \"onSelect\", \"setAnchorEl\", \"setFilterValue\", \"table\"]);\n  const {\n    getState,\n    options: {\n      columnFilterModeOptions,\n      globalFilterModeOptions,\n      localization,\n      mrtTheme: {\n        menuBackgroundColor\n      },\n      renderColumnFilterModeMenuItems,\n      renderGlobalFilterModeMenuItems\n    },\n    setColumnFilterFns,\n    setGlobalFilterFn\n  } = table;\n  const {\n    density,\n    globalFilterFn\n  } = getState();\n  const {\n    column\n  } = header !== null && header !== void 0 ? header : {};\n  const {\n    columnDef\n  } = column !== null && column !== void 0 ? column : {};\n  const currentFilterValue = column === null || column === void 0 ? void 0 : column.getFilterValue();\n  let allowedColumnFilterOptions = (_b = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _b !== void 0 ? _b : columnFilterModeOptions;\n  if (rangeVariants.includes(columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant)) {\n    allowedColumnFilterOptions = [...rangeModes, ...(allowedColumnFilterOptions !== null && allowedColumnFilterOptions !== void 0 ? allowedColumnFilterOptions : [])].filter(option => rangeModes.includes(option));\n  }\n  const internalFilterOptions = useMemo(() => mrtFilterOptions(localization).filter(filterOption => columnDef ? allowedColumnFilterOptions === undefined || (allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.includes(filterOption.option)) : (!globalFilterModeOptions || globalFilterModeOptions.includes(filterOption.option)) && ['contains', 'fuzzy', 'startsWith'].includes(filterOption.option)), []);\n  const handleSelectFilterMode = option => {\n    var _a, _b;\n    const prevFilterMode = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef._filterFn) !== null && _a !== void 0 ? _a : '';\n    if (!header || !column) {\n      // global filter mode\n      setGlobalFilterFn(option);\n    } else if (option !== prevFilterMode) {\n      // column filter mode\n      setColumnFilterFns(prev => Object.assign(Object.assign({}, prev), {\n        [header.id]: option\n      }));\n      // reset filter value and/or perform new filter render\n      if (emptyModes.includes(option)) {\n        // will now be empty/notEmpty filter mode\n        if (currentFilterValue !== ' ' && !emptyModes.includes(prevFilterMode)) {\n          column.setFilterValue(' ');\n        } else if (currentFilterValue) {\n          column.setFilterValue(currentFilterValue); // perform new filter render\n        }\n      } else if ((columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) === 'multi-select' || arrModes.includes(option)) {\n        // will now be array filter mode\n        if (currentFilterValue instanceof String || (currentFilterValue === null || currentFilterValue === void 0 ? void 0 : currentFilterValue.length)) {\n          column.setFilterValue([]);\n          setFilterValue === null || setFilterValue === void 0 ? void 0 : setFilterValue([]);\n        } else if (currentFilterValue) {\n          column.setFilterValue(currentFilterValue); // perform new filter render\n        }\n      } else if (((_b = columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) === null || _b === void 0 ? void 0 : _b.includes('range')) || rangeModes.includes(option)) {\n        // will now be range filter mode\n        if (!Array.isArray(currentFilterValue) || !(currentFilterValue === null || currentFilterValue === void 0 ? void 0 : currentFilterValue.every(v => v === '')) && !rangeModes.includes(prevFilterMode)) {\n          column.setFilterValue(['', '']);\n          setFilterValue === null || setFilterValue === void 0 ? void 0 : setFilterValue('');\n        } else {\n          column.setFilterValue(currentFilterValue); // perform new filter render\n        }\n      } else {\n        // will now be single value filter mode\n        if (Array.isArray(currentFilterValue)) {\n          column.setFilterValue('');\n          setFilterValue === null || setFilterValue === void 0 ? void 0 : setFilterValue('');\n        } else if (currentFilterValue === ' ' && emptyModes.includes(prevFilterMode)) {\n          column.setFilterValue(undefined);\n        } else {\n          column.setFilterValue(currentFilterValue); // perform new filter render\n        }\n      }\n    }\n    setAnchorEl(null);\n    onSelect === null || onSelect === void 0 ? void 0 : onSelect();\n  };\n  const filterOption = !!header && columnDef ? columnDef._filterFn : globalFilterFn;\n  return jsx(Menu, Object.assign({\n    MenuListProps: {\n      dense: density === 'compact',\n      sx: {\n        backgroundColor: menuBackgroundColor\n      }\n    },\n    anchorEl: anchorEl,\n    anchorOrigin: {\n      horizontal: 'right',\n      vertical: 'center'\n    },\n    disableScrollLock: true,\n    onClose: () => setAnchorEl(null),\n    open: !!anchorEl\n  }, rest, {\n    children: (_e = header && column && columnDef ? (_d = (_c = columnDef.renderColumnFilterModeMenuItems) === null || _c === void 0 ? void 0 : _c.call(columnDef, {\n      column: column,\n      internalFilterOptions,\n      onSelectFilterMode: handleSelectFilterMode,\n      table\n    })) !== null && _d !== void 0 ? _d : renderColumnFilterModeMenuItems === null || renderColumnFilterModeMenuItems === void 0 ? void 0 : renderColumnFilterModeMenuItems({\n      column: column,\n      internalFilterOptions,\n      onSelectFilterMode: handleSelectFilterMode,\n      table\n    }) : renderGlobalFilterModeMenuItems === null || renderGlobalFilterModeMenuItems === void 0 ? void 0 : renderGlobalFilterModeMenuItems({\n      internalFilterOptions,\n      onSelectFilterMode: handleSelectFilterMode,\n      table\n    })) !== null && _e !== void 0 ? _e : internalFilterOptions.map(({\n      divider,\n      label,\n      option,\n      symbol\n    }, index) => jsx(MRT_ActionMenuItem, {\n      divider: divider,\n      icon: symbol,\n      label: label,\n      onClick: () => handleSelectFilterMode(option),\n      selected: option === filterOption,\n      table: table,\n      value: option\n    }, index))\n  }));\n};\nconst MRT_ColumnActionMenu = _a => {\n  var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n  var {\n      anchorEl,\n      header,\n      setAnchorEl,\n      table\n    } = _a,\n    rest = __rest(_a, [\"anchorEl\", \"header\", \"setAnchorEl\", \"table\"]);\n  const {\n    getAllLeafColumns,\n    getState,\n    options: {\n      columnFilterDisplayMode,\n      columnFilterModeOptions,\n      enableColumnFilterModes,\n      enableColumnFilters,\n      enableColumnPinning,\n      enableColumnResizing,\n      enableGrouping,\n      enableHiding,\n      enableSorting,\n      enableSortingRemoval,\n      icons: {\n        ClearAllIcon,\n        DynamicFeedIcon,\n        FilterListIcon,\n        FilterListOffIcon,\n        PushPinIcon,\n        RestartAltIcon,\n        SortIcon,\n        ViewColumnIcon,\n        VisibilityOffIcon\n      },\n      localization,\n      mrtTheme: {\n        menuBackgroundColor\n      },\n      renderColumnActionsMenuItems\n    },\n    refs: {\n      filterInputRefs\n    },\n    setColumnFilterFns,\n    setColumnOrder,\n    setColumnSizingInfo,\n    setShowColumnFilters\n  } = table;\n  const {\n    column\n  } = header;\n  const {\n    columnDef\n  } = column;\n  const {\n    columnSizing,\n    columnVisibility,\n    density,\n    showColumnFilters\n  } = getState();\n  const columnFilterValue = column.getFilterValue();\n  const [filterMenuAnchorEl, setFilterMenuAnchorEl] = useState(null);\n  const handleClearSort = () => {\n    column.clearSorting();\n    setAnchorEl(null);\n  };\n  const handleSortAsc = () => {\n    column.toggleSorting(false);\n    setAnchorEl(null);\n  };\n  const handleSortDesc = () => {\n    column.toggleSorting(true);\n    setAnchorEl(null);\n  };\n  const handleResetColumnSize = () => {\n    setColumnSizingInfo(old => Object.assign(Object.assign({}, old), {\n      isResizingColumn: false\n    }));\n    column.resetSize();\n    setAnchorEl(null);\n  };\n  const handleHideColumn = () => {\n    column.toggleVisibility(false);\n    setAnchorEl(null);\n  };\n  const handlePinColumn = pinDirection => {\n    column.pin(pinDirection);\n    setAnchorEl(null);\n  };\n  const handleGroupByColumn = () => {\n    column.toggleGrouping();\n    setColumnOrder(old => ['mrt-row-expand', ...old]);\n    setAnchorEl(null);\n  };\n  const handleClearFilter = () => {\n    column.setFilterValue(undefined);\n    setAnchorEl(null);\n    if (['empty', 'notEmpty'].includes(columnDef._filterFn)) {\n      setColumnFilterFns(prev => {\n        var _a;\n        return Object.assign(Object.assign({}, prev), {\n          [header.id]: (_a = allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions[0]) !== null && _a !== void 0 ? _a : 'fuzzy'\n        });\n      });\n    }\n  };\n  const handleFilterByColumn = () => {\n    setShowColumnFilters(true);\n    queueMicrotask(() => {\n      var _a;\n      return (_a = filterInputRefs.current[`${column.id}-0`]) === null || _a === void 0 ? void 0 : _a.focus();\n    });\n    setAnchorEl(null);\n  };\n  const handleShowAllColumns = () => {\n    getAllLeafColumns().filter(col => col.columnDef.enableHiding !== false).forEach(col => col.toggleVisibility(true));\n    setAnchorEl(null);\n  };\n  const handleOpenFilterModeMenu = event => {\n    event.stopPropagation();\n    setFilterMenuAnchorEl(event.currentTarget);\n  };\n  const isSelectFilter = !!columnDef.filterSelectOptions;\n  const allowedColumnFilterOptions = (_b = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _b !== void 0 ? _b : columnFilterModeOptions;\n  const showFilterModeSubMenu = enableColumnFilterModes && columnDef.enableColumnFilterModes !== false && !isSelectFilter && (allowedColumnFilterOptions === undefined || !!(allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.length));\n  const internalColumnMenuItems = [...(enableSorting && column.getCanSort() ? [enableSortingRemoval !== false && jsx(MRT_ActionMenuItem, {\n    icon: jsx(ClearAllIcon, {}),\n    label: localization.clearSort,\n    onClick: handleClearSort,\n    table: table\n  }, 0), jsx(MRT_ActionMenuItem, {\n    disabled: column.getIsSorted() === 'asc',\n    icon: jsx(SortIcon, {\n      style: {\n        transform: 'rotate(180deg) scaleX(-1)'\n      }\n    }),\n    label: (_c = localization.sortByColumnAsc) === null || _c === void 0 ? void 0 : _c.replace('{column}', String(columnDef.header)),\n    onClick: handleSortAsc,\n    table: table\n  }, 1), jsx(MRT_ActionMenuItem, {\n    disabled: column.getIsSorted() === 'desc',\n    divider: enableColumnFilters || enableGrouping || enableHiding,\n    icon: jsx(SortIcon, {}),\n    label: (_d = localization.sortByColumnDesc) === null || _d === void 0 ? void 0 : _d.replace('{column}', String(columnDef.header)),\n    onClick: handleSortDesc,\n    table: table\n  }, 2)] : []), ...(enableColumnFilters && column.getCanFilter() ? [jsx(MRT_ActionMenuItem, {\n    disabled: !columnFilterValue || Array.isArray(columnFilterValue) && !columnFilterValue.filter(value => value).length,\n    icon: jsx(FilterListOffIcon, {}),\n    label: localization.clearFilter,\n    onClick: handleClearFilter,\n    table: table\n  }, 3), columnFilterDisplayMode === 'subheader' && jsx(MRT_ActionMenuItem, {\n    disabled: showColumnFilters && !enableColumnFilterModes,\n    divider: enableGrouping || enableHiding,\n    icon: jsx(FilterListIcon, {}),\n    label: (_e = localization.filterByColumn) === null || _e === void 0 ? void 0 : _e.replace('{column}', String(columnDef.header)),\n    onClick: showColumnFilters ? handleOpenFilterModeMenu : handleFilterByColumn,\n    onOpenSubMenu: showFilterModeSubMenu ? handleOpenFilterModeMenu : undefined,\n    table: table\n  }, 4), showFilterModeSubMenu && jsx(MRT_FilterOptionMenu, {\n    anchorEl: filterMenuAnchorEl,\n    header: header,\n    onSelect: handleFilterByColumn,\n    setAnchorEl: setFilterMenuAnchorEl,\n    table: table\n  }, 5)].filter(Boolean) : []), ...(enableGrouping && column.getCanGroup() ? [jsx(MRT_ActionMenuItem, {\n    divider: enableColumnPinning,\n    icon: jsx(DynamicFeedIcon, {}),\n    label: (_f = localization[column.getIsGrouped() ? 'ungroupByColumn' : 'groupByColumn']) === null || _f === void 0 ? void 0 : _f.replace('{column}', String(columnDef.header)),\n    onClick: handleGroupByColumn,\n    table: table\n  }, 6)] : []), ...(enableColumnPinning && column.getCanPin() ? [jsx(MRT_ActionMenuItem, {\n    disabled: column.getIsPinned() === 'left' || !column.getCanPin(),\n    icon: jsx(PushPinIcon, {\n      style: {\n        transform: 'rotate(90deg)'\n      }\n    }),\n    label: localization.pinToLeft,\n    onClick: () => handlePinColumn('left'),\n    table: table\n  }, 7), jsx(MRT_ActionMenuItem, {\n    disabled: column.getIsPinned() === 'right' || !column.getCanPin(),\n    icon: jsx(PushPinIcon, {\n      style: {\n        transform: 'rotate(-90deg)'\n      }\n    }),\n    label: localization.pinToRight,\n    onClick: () => handlePinColumn('right'),\n    table: table\n  }, 8), jsx(MRT_ActionMenuItem, {\n    disabled: !column.getIsPinned(),\n    divider: enableHiding,\n    icon: jsx(PushPinIcon, {}),\n    label: localization.unpin,\n    onClick: () => handlePinColumn(false),\n    table: table\n  }, 9)] : []), ...(enableColumnResizing && column.getCanResize() ? [jsx(MRT_ActionMenuItem, {\n    disabled: !columnSizing[column.id],\n    icon: jsx(RestartAltIcon, {}),\n    label: localization.resetColumnSize,\n    onClick: handleResetColumnSize,\n    table: table\n  }, 10)] : []), ...(enableHiding ? [jsx(MRT_ActionMenuItem, {\n    disabled: !column.getCanHide(),\n    icon: jsx(VisibilityOffIcon, {}),\n    label: (_g = localization.hideColumn) === null || _g === void 0 ? void 0 : _g.replace('{column}', String(columnDef.header)),\n    onClick: handleHideColumn,\n    table: table\n  }, 11), jsx(MRT_ActionMenuItem, {\n    disabled: !Object.values(columnVisibility).filter(visible => !visible).length,\n    icon: jsx(ViewColumnIcon, {}),\n    label: (_h = localization.showAllColumns) === null || _h === void 0 ? void 0 : _h.replace('{column}', String(columnDef.header)),\n    onClick: handleShowAllColumns,\n    table: table\n  }, 12)] : [])].filter(Boolean);\n  return jsx(Menu, Object.assign({\n    MenuListProps: {\n      dense: density === 'compact',\n      sx: {\n        backgroundColor: menuBackgroundColor\n      }\n    },\n    anchorEl: anchorEl,\n    disableScrollLock: true,\n    onClose: () => setAnchorEl(null),\n    open: !!anchorEl\n  }, rest, {\n    children: (_l = (_k = (_j = columnDef.renderColumnActionsMenuItems) === null || _j === void 0 ? void 0 : _j.call(columnDef, {\n      closeMenu: () => setAnchorEl(null),\n      column,\n      internalColumnMenuItems,\n      table\n    })) !== null && _k !== void 0 ? _k : renderColumnActionsMenuItems === null || renderColumnActionsMenuItems === void 0 ? void 0 : renderColumnActionsMenuItems({\n      closeMenu: () => setAnchorEl(null),\n      column,\n      internalColumnMenuItems,\n      table\n    })) !== null && _l !== void 0 ? _l : internalColumnMenuItems\n  }));\n};\nconst MRT_TableHeadCellColumnActionsButton = _a => {\n  var _b, _c;\n  var {\n      header,\n      table\n    } = _a,\n    rest = __rest(_a, [\"header\", \"table\"]);\n  const {\n    options: {\n      icons: {\n        MoreVertIcon\n      },\n      localization,\n      muiColumnActionsButtonProps\n    }\n  } = table;\n  const {\n    column\n  } = header;\n  const {\n    columnDef\n  } = column;\n  const [anchorEl, setAnchorEl] = useState(null);\n  const handleClick = event => {\n    event.stopPropagation();\n    event.preventDefault();\n    setAnchorEl(event.currentTarget);\n  };\n  const iconButtonProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiColumnActionsButtonProps, {\n    column,\n    table\n  })), parseFromValuesOrFunc(columnDef.muiColumnActionsButtonProps, {\n    column,\n    table\n  })), rest);\n  return jsxs(Fragment, {\n    children: [jsx(Tooltip, Object.assign({}, getCommonTooltipProps('top'), {\n      title: (_b = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.title) !== null && _b !== void 0 ? _b : localization.columnActions,\n      children: jsx(IconButton, Object.assign({\n        \"aria-label\": localization.columnActions,\n        onClick: handleClick,\n        size: \"small\"\n      }, iconButtonProps, {\n        sx: theme => Object.assign({\n          '&:hover': {\n            opacity: 1\n          },\n          height: '2rem',\n          m: '-8px -4px',\n          opacity: 0.3,\n          transition: 'all 150ms',\n          width: '2rem'\n        }, parseFromValuesOrFunc(iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx, theme)),\n        title: undefined,\n        children: (_c = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.children) !== null && _c !== void 0 ? _c : jsx(MoreVertIcon, {\n          style: {\n            transform: 'scale(0.9)'\n          }\n        })\n      }))\n    })), anchorEl && jsx(MRT_ColumnActionMenu, {\n      anchorEl: anchorEl,\n      header: header,\n      setAnchorEl: setAnchorEl,\n      table: table\n    })]\n  });\n};\nconst MRT_FilterCheckbox = _a => {\n  var _b, _c, _d;\n  var {\n      column,\n      table\n    } = _a,\n    rest = __rest(_a, [\"column\", \"table\"]);\n  const {\n    getState,\n    options: {\n      localization,\n      muiFilterCheckboxProps\n    }\n  } = table;\n  const {\n    density\n  } = getState();\n  const {\n    columnDef\n  } = column;\n  const checkboxProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterCheckboxProps, {\n    column,\n    table\n  })), parseFromValuesOrFunc(columnDef.muiFilterCheckboxProps, {\n    column,\n    table\n  })), rest);\n  const filterLabel = (_b = localization.filterByColumn) === null || _b === void 0 ? void 0 : _b.replace('{column}', columnDef.header);\n  return jsx(Tooltip, Object.assign({}, getCommonTooltipProps(), {\n    title: (_c = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.title) !== null && _c !== void 0 ? _c : filterLabel,\n    children: jsx(FormControlLabel, {\n      control: jsx(Checkbox, Object.assign({\n        checked: column.getFilterValue() === 'true',\n        color: column.getFilterValue() === undefined ? 'default' : 'primary',\n        indeterminate: column.getFilterValue() === undefined,\n        size: density === 'compact' ? 'small' : 'medium'\n      }, checkboxProps, {\n        onChange: (e, checked) => {\n          var _a;\n          column.setFilterValue(column.getFilterValue() === undefined ? 'true' : column.getFilterValue() === 'true' ? 'false' : undefined);\n          (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onChange) === null || _a === void 0 ? void 0 : _a.call(checkboxProps, e, checked);\n        },\n        onClick: e => {\n          var _a;\n          e.stopPropagation();\n          (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a === void 0 ? void 0 : _a.call(checkboxProps, e);\n        },\n        sx: theme => Object.assign({\n          height: '2.5rem',\n          width: '2.5rem'\n        }, parseFromValuesOrFunc(checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.sx, theme))\n      })),\n      disableTypography: true,\n      label: (_d = checkboxProps.title) !== null && _d !== void 0 ? _d : filterLabel,\n      sx: {\n        color: 'text.secondary',\n        fontWeight: 'normal',\n        mt: '-4px'\n      },\n      title: undefined\n    })\n  }));\n};\nconst MRT_FilterTextField = _a => {\n  var _b, _c, _d, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;\n  var {\n      header,\n      rangeFilterIndex,\n      table\n    } = _a,\n    rest = __rest(_a, [\"header\", \"rangeFilterIndex\", \"table\"]);\n  const {\n    options: {\n      enableColumnFilterModes,\n      icons: {\n        CloseIcon,\n        FilterListIcon\n      },\n      localization,\n      manualFiltering,\n      muiFilterAutocompleteProps,\n      muiFilterDatePickerProps,\n      muiFilterDateTimePickerProps,\n      muiFilterTextFieldProps,\n      muiFilterTimePickerProps\n    },\n    refs: {\n      filterInputRefs\n    },\n    setColumnFilterFns\n  } = table;\n  const {\n    column\n  } = header;\n  const {\n    columnDef\n  } = column;\n  const {\n    filterVariant\n  } = columnDef;\n  const args = {\n    column,\n    rangeFilterIndex,\n    table\n  };\n  const textFieldProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterTextFieldProps, args)), parseFromValuesOrFunc(columnDef.muiFilterTextFieldProps, args)), rest);\n  const autocompleteProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterAutocompleteProps, args)), parseFromValuesOrFunc(columnDef.muiFilterAutocompleteProps, args));\n  const datePickerProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterDatePickerProps, args)), parseFromValuesOrFunc(columnDef.muiFilterDatePickerProps, args));\n  const dateTimePickerProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterDateTimePickerProps, args)), parseFromValuesOrFunc(columnDef.muiFilterDateTimePickerProps, args));\n  const timePickerProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterTimePickerProps, args)), parseFromValuesOrFunc(columnDef.muiFilterTimePickerProps, args));\n  const {\n    allowedColumnFilterOptions,\n    currentFilterOption,\n    facetedUniqueValues,\n    isAutocompleteFilter,\n    isDateFilter,\n    isMultiSelectFilter,\n    isRangeFilter,\n    isSelectFilter,\n    isTextboxFilter\n  } = getColumnFilterInfo({\n    header,\n    table\n  });\n  const dropdownOptions = useDropdownOptions({\n    header,\n    table\n  });\n  const filterChipLabel = ['empty', 'notEmpty'].includes(currentFilterOption) ?\n  //@ts-ignore\n  localization[`filter${((_c = (_b = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt) === null || _b === void 0 ? void 0 : _b.call(currentFilterOption, 0)) === null || _c === void 0 ? void 0 : _c.toUpperCase()) + (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`] : '';\n  const filterPlaceholder = !isRangeFilter ? (_d = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.placeholder) !== null && _d !== void 0 ? _d : (_f = localization.filterByColumn) === null || _f === void 0 ? void 0 : _f.replace('{column}', String(columnDef.header)) : rangeFilterIndex === 0 ? localization.min : rangeFilterIndex === 1 ? localization.max : '';\n  const showChangeModeButton = !!(enableColumnFilterModes && columnDef.enableColumnFilterModes !== false && !rangeFilterIndex && (allowedColumnFilterOptions === undefined || !!(allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.length)));\n  const [anchorEl, setAnchorEl] = useState(null);\n  const [filterValue, setFilterValue] = useState(() => {\n    var _a, _b;\n    return isMultiSelectFilter ? column.getFilterValue() || [] : isRangeFilter ? ((_a = column.getFilterValue()) === null || _a === void 0 ? void 0 : _a[rangeFilterIndex]) || '' : (_b = column.getFilterValue()) !== null && _b !== void 0 ? _b : '';\n  });\n  const [autocompleteValue, setAutocompleteValue] = useState(isAutocompleteFilter ? filterValue : null);\n  const handleChangeDebounced = useCallback(debounce(newValue => {\n    if (isRangeFilter) {\n      column.setFilterValue(old => {\n        const newFilterValues = old !== null && old !== void 0 ? old : ['', ''];\n        newFilterValues[rangeFilterIndex] = newValue !== null && newValue !== void 0 ? newValue : undefined;\n        return newFilterValues;\n      });\n    } else {\n      column.setFilterValue(newValue !== null && newValue !== void 0 ? newValue : undefined);\n    }\n  }, isTextboxFilter ? manualFiltering ? 400 : 200 : 1), []);\n  const handleChange = newValue => {\n    setFilterValue(newValue !== null && newValue !== void 0 ? newValue : '');\n    handleChangeDebounced(newValue);\n  };\n  const handleTextFieldChange = event => {\n    var _a;\n    const newValue = textFieldProps.type === 'date' ? event.target.valueAsDate : textFieldProps.type === 'number' ? event.target.valueAsNumber : event.target.value;\n    handleChange(newValue);\n    (_a = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.onChange) === null || _a === void 0 ? void 0 : _a.call(textFieldProps, event);\n  };\n  const handleAutocompleteChange = newValue => {\n    setAutocompleteValue(newValue);\n    handleChange(getValueAndLabel(newValue).value);\n  };\n  const handleClear = () => {\n    if (isMultiSelectFilter) {\n      setFilterValue([]);\n      column.setFilterValue([]);\n    } else if (isRangeFilter) {\n      setFilterValue('');\n      column.setFilterValue(old => {\n        const newFilterValues = Array.isArray(old) && old || ['', ''];\n        newFilterValues[rangeFilterIndex] = undefined;\n        return newFilterValues;\n      });\n    } else {\n      setFilterValue('');\n      column.setFilterValue(undefined);\n    }\n  };\n  const handleClearEmptyFilterChip = () => {\n    setFilterValue('');\n    column.setFilterValue(undefined);\n    setColumnFilterFns(prev => {\n      var _a;\n      return Object.assign(Object.assign({}, prev), {\n        [header.id]: (_a = allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions[0]) !== null && _a !== void 0 ? _a : 'fuzzy'\n      });\n    });\n  };\n  const handleFilterMenuOpen = event => {\n    setAnchorEl(event.currentTarget);\n  };\n  const isMounted = useRef(false);\n  useEffect(() => {\n    if (isMounted.current) {\n      const filterValue = column.getFilterValue();\n      if (filterValue === undefined) {\n        handleClear();\n      } else if (isRangeFilter && rangeFilterIndex !== undefined) {\n        setFilterValue(filterValue[rangeFilterIndex]);\n      } else {\n        setFilterValue(filterValue);\n      }\n    }\n    isMounted.current = true;\n  }, [column.getFilterValue()]);\n  if (columnDef.Filter) {\n    return jsx(Fragment, {\n      children: (_g = columnDef.Filter) === null || _g === void 0 ? void 0 : _g.call(columnDef, {\n        column,\n        header,\n        rangeFilterIndex,\n        table\n      })\n    });\n  }\n  const endAdornment = !isAutocompleteFilter && !isDateFilter && !filterChipLabel ? jsx(InputAdornment, {\n    position: \"end\",\n    sx: {\n      mr: isSelectFilter || isMultiSelectFilter ? '20px' : undefined\n    },\n    children: jsx(Tooltip, {\n      placement: \"right\",\n      title: (_h = localization.clearFilter) !== null && _h !== void 0 ? _h : '',\n      children: jsx(\"span\", {\n        children: jsx(IconButton, {\n          \"aria-label\": localization.clearFilter,\n          disabled: !((_j = filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString()) === null || _j === void 0 ? void 0 : _j.length),\n          onClick: handleClear,\n          size: \"small\",\n          sx: {\n            height: '2rem',\n            transform: 'scale(0.9)',\n            width: '2rem'\n          },\n          children: jsx(CloseIcon, {})\n        })\n      })\n    })\n  }) : null;\n  const startAdornment = showChangeModeButton ? jsxs(InputAdornment, {\n    position: \"start\",\n    children: [jsx(Tooltip, {\n      title: localization.changeFilterMode,\n      children: jsx(\"span\", {\n        children: jsx(IconButton, {\n          \"aria-label\": localization.changeFilterMode,\n          onClick: handleFilterMenuOpen,\n          size: \"small\",\n          sx: {\n            height: '1.75rem',\n            width: '1.75rem'\n          },\n          children: jsx(FilterListIcon, {})\n        })\n      })\n    }), filterChipLabel && jsx(Chip, {\n      label: filterChipLabel,\n      onDelete: handleClearEmptyFilterChip\n    })]\n  }) : null;\n  const commonTextFieldProps = Object.assign(Object.assign({\n    FormHelperTextProps: {\n      sx: {\n        fontSize: '0.75rem',\n        lineHeight: '0.8rem',\n        whiteSpace: 'nowrap'\n      }\n    },\n    InputProps: endAdornment //hack because mui looks for presence of endAdornment key instead of undefined\n    ? {\n      endAdornment,\n      startAdornment\n    } : {\n      startAdornment\n    },\n    fullWidth: true,\n    helperText: showChangeModeButton ? jsx(\"label\", {\n      children: localization.filterMode.replace('{filterType}',\n      // @ts-ignore\n      localization[`filter${((_k = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt(0)) === null || _k === void 0 ? void 0 : _k.toUpperCase()) + (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`])\n    }) : null,\n    inputProps: {\n      'aria-label': filterPlaceholder,\n      autoComplete: 'new-password',\n      // disable autocomplete and autofill\n      disabled: !!filterChipLabel,\n      sx: {\n        textOverflow: 'ellipsis',\n        width: filterChipLabel ? 0 : undefined\n      },\n      title: filterPlaceholder\n    },\n    inputRef: inputRef => {\n      filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] = inputRef;\n      if (textFieldProps.inputRef) {\n        textFieldProps.inputRef = inputRef;\n      }\n    },\n    margin: 'none',\n    placeholder: filterChipLabel || isSelectFilter || isMultiSelectFilter ? undefined : filterPlaceholder,\n    variant: 'standard'\n  }, textFieldProps), {\n    sx: theme => Object.assign({\n      minWidth: isDateFilter ? '160px' : enableColumnFilterModes && rangeFilterIndex === 0 ? '110px' : isRangeFilter ? '100px' : !filterChipLabel ? '120px' : 'auto',\n      mx: '-2px',\n      p: 0,\n      width: 'calc(100% + 4px)'\n    }, parseFromValuesOrFunc(textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.sx, theme))\n  });\n  const commonDatePickerProps = {\n    onChange: newDate => {\n      handleChange(newDate);\n    },\n    value: filterValue || null\n  };\n  return jsxs(Fragment, {\n    children: [(filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.startsWith('time')) ? jsx(TimePicker, Object.assign({}, commonDatePickerProps, timePickerProps, {\n      slotProps: {\n        field: Object.assign({\n          clearable: true,\n          onClear: () => handleClear()\n        }, (_l = timePickerProps === null || timePickerProps === void 0 ? void 0 : timePickerProps.slotProps) === null || _l === void 0 ? void 0 : _l.field),\n        textField: Object.assign(Object.assign({}, commonTextFieldProps), (_m = timePickerProps === null || timePickerProps === void 0 ? void 0 : timePickerProps.slotProps) === null || _m === void 0 ? void 0 : _m.textField)\n      }\n    })) : (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.startsWith('datetime')) ? jsx(DateTimePicker, Object.assign({}, commonDatePickerProps, dateTimePickerProps, {\n      slotProps: {\n        field: Object.assign({\n          clearable: true,\n          onClear: () => handleClear()\n        }, (_o = dateTimePickerProps === null || dateTimePickerProps === void 0 ? void 0 : dateTimePickerProps.slotProps) === null || _o === void 0 ? void 0 : _o.field),\n        textField: Object.assign(Object.assign({}, commonTextFieldProps), (_p = dateTimePickerProps === null || dateTimePickerProps === void 0 ? void 0 : dateTimePickerProps.slotProps) === null || _p === void 0 ? void 0 : _p.textField)\n      }\n    })) : (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.startsWith('date')) ? jsx(DatePicker, Object.assign({}, commonDatePickerProps, datePickerProps, {\n      slotProps: {\n        field: Object.assign({\n          clearable: true,\n          onClear: () => handleClear()\n        }, (_q = datePickerProps === null || datePickerProps === void 0 ? void 0 : datePickerProps.slotProps) === null || _q === void 0 ? void 0 : _q.field),\n        textField: Object.assign(Object.assign({}, commonTextFieldProps), (_r = datePickerProps === null || datePickerProps === void 0 ? void 0 : datePickerProps.slotProps) === null || _r === void 0 ? void 0 : _r.textField)\n      }\n    })) : isAutocompleteFilter ? jsx(Autocomplete, Object.assign({\n      freeSolo: true,\n      getOptionLabel: option => getValueAndLabel(option).label,\n      onChange: (_e, newValue) => handleAutocompleteChange(newValue),\n      options: (_s = dropdownOptions === null || dropdownOptions === void 0 ? void 0 : dropdownOptions.map(option => getValueAndLabel(option))) !== null && _s !== void 0 ? _s : []\n    }, autocompleteProps, {\n      renderInput: builtinTextFieldProps => {\n        var _a;\n        return jsx(TextField, Object.assign({}, builtinTextFieldProps, commonTextFieldProps, {\n          InputProps: Object.assign(Object.assign({}, builtinTextFieldProps.InputProps), {\n            startAdornment: (_a = commonTextFieldProps === null || commonTextFieldProps === void 0 ? void 0 : commonTextFieldProps.InputProps) === null || _a === void 0 ? void 0 : _a.startAdornment\n          }),\n          inputProps: Object.assign(Object.assign({}, builtinTextFieldProps.inputProps), commonTextFieldProps === null || commonTextFieldProps === void 0 ? void 0 : commonTextFieldProps.inputProps),\n          onChange: handleTextFieldChange,\n          onClick: e => e.stopPropagation()\n        }));\n      },\n      value: autocompleteValue\n    })) : jsx(TextField, Object.assign({\n      select: isSelectFilter || isMultiSelectFilter\n    }, commonTextFieldProps, {\n      SelectProps: Object.assign({\n        MenuProps: {\n          disableScrollLock: true\n        },\n        displayEmpty: true,\n        multiple: isMultiSelectFilter,\n        renderValue: isMultiSelectFilter ? selected => !(selected === null || selected === void 0 ? void 0 : selected.length) ? jsx(Box, {\n          sx: {\n            opacity: 0.5\n          },\n          children: filterPlaceholder\n        }) : jsx(Box, {\n          sx: {\n            display: 'flex',\n            flexWrap: 'wrap',\n            gap: '2px'\n          },\n          children: selected === null || selected === void 0 ? void 0 : selected.map(value => {\n            const selectedValue = dropdownOptions === null || dropdownOptions === void 0 ? void 0 : dropdownOptions.find(option => getValueAndLabel(option).value === value);\n            return jsx(Chip, {\n              label: getValueAndLabel(selectedValue).label\n            }, value);\n          })\n        }) : undefined\n      }, commonTextFieldProps.SelectProps),\n      onChange: handleTextFieldChange,\n      onClick: e => e.stopPropagation(),\n      value: filterValue !== null && filterValue !== void 0 ? filterValue : '',\n      children: (isSelectFilter || isMultiSelectFilter) && [jsx(MenuItem, {\n        disabled: true,\n        divider: true,\n        hidden: true,\n        value: \"\",\n        children: jsx(Box, {\n          sx: {\n            opacity: 0.5\n          },\n          children: filterPlaceholder\n        })\n      }, \"p\"), ...[(_t = textFieldProps.children) !== null && _t !== void 0 ? _t : dropdownOptions === null || dropdownOptions === void 0 ? void 0 : dropdownOptions.map((option, index) => {\n        var _a;\n        const {\n          label,\n          value\n        } = getValueAndLabel(option);\n        return jsxs(MenuItem, {\n          sx: {\n            alignItems: 'center',\n            display: 'flex',\n            gap: '0.5rem',\n            m: 0\n          },\n          value: value,\n          children: [isMultiSelectFilter && jsx(Checkbox, {\n            checked: ((_a = column.getFilterValue()) !== null && _a !== void 0 ? _a : []).includes(value),\n            sx: {\n              mr: '0.5rem'\n            }\n          }), label, ' ', !columnDef.filterSelectOptions && `(${facetedUniqueValues.get(value)})`]\n        }, `${index}-${value}`);\n      })]]\n    })), jsx(MRT_FilterOptionMenu, {\n      anchorEl: anchorEl,\n      header: header,\n      setAnchorEl: setAnchorEl,\n      setFilterValue: setFilterValue,\n      table: table\n    })]\n  });\n};\nconst MRT_FilterRangeFields = _a => {\n  var {\n      header,\n      table\n    } = _a,\n    rest = __rest(_a, [\"header\", \"table\"]);\n  return jsx(Box, Object.assign({}, rest, {\n    sx: theme => Object.assign({\n      display: 'grid',\n      gap: '1rem',\n      gridTemplateColumns: '1fr 1fr'\n    }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)),\n    children: [0, 1].map(rangeFilterIndex => jsx(MRT_FilterTextField, {\n      header: header,\n      rangeFilterIndex: rangeFilterIndex,\n      table: table\n    }, rangeFilterIndex))\n  }));\n};\nconst MRT_FilterRangeSlider = _a => {\n  var _b, _c;\n  var {\n      header,\n      table\n    } = _a,\n    rest = __rest(_a, [\"header\", \"table\"]);\n  const {\n    options: {\n      enableColumnFilterModes,\n      localization,\n      muiFilterSliderProps\n    },\n    refs: {\n      filterInputRefs\n    }\n  } = table;\n  const {\n    column\n  } = header;\n  const {\n    columnDef\n  } = column;\n  const currentFilterOption = columnDef._filterFn;\n  const showChangeModeButton = enableColumnFilterModes && columnDef.enableColumnFilterModes !== false;\n  const sliderProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterSliderProps, {\n    column,\n    table\n  })), parseFromValuesOrFunc(columnDef.muiFilterSliderProps, {\n    column,\n    table\n  })), rest);\n  let [min, max] = sliderProps.min !== undefined && sliderProps.max !== undefined ? [sliderProps.min, sliderProps.max] : (_b = column.getFacetedMinMaxValues()) !== null && _b !== void 0 ? _b : [0, 1];\n  //fix potential TanStack Table bugs where min or max is an array\n  if (Array.isArray(min)) min = min[0];\n  if (Array.isArray(max)) max = max[0];\n  if (min === null) min = 0;\n  if (max === null) max = 1;\n  const [filterValues, setFilterValues] = useState([min, max]);\n  const columnFilterValue = column.getFilterValue();\n  const isMounted = useRef(false);\n  useEffect(() => {\n    if (isMounted.current) {\n      if (columnFilterValue === undefined) {\n        setFilterValues([min, max]);\n      } else if (Array.isArray(columnFilterValue)) {\n        setFilterValues(columnFilterValue);\n      }\n    }\n    isMounted.current = true;\n  }, [columnFilterValue, min, max]);\n  return jsxs(Stack, {\n    children: [jsx(Slider, Object.assign({\n      disableSwap: true,\n      max: max,\n      min: min,\n      onChange: (_event, values) => {\n        setFilterValues(values);\n      },\n      onChangeCommitted: (_event, value) => {\n        if (Array.isArray(value)) {\n          if (value[0] <= min && value[1] >= max) {\n            //if the user has selected the entire range, remove the filter\n            column.setFilterValue(undefined);\n          } else {\n            column.setFilterValue(value);\n          }\n        }\n      },\n      value: filterValues,\n      valueLabelDisplay: \"auto\"\n    }, sliderProps, {\n      slotProps: {\n        input: {\n          ref: node => {\n            var _a, _b;\n            if (node) {\n              filterInputRefs.current[`${column.id}-0`] = node;\n              // @ts-ignore\n              if ((_b = (_a = sliderProps === null || sliderProps === void 0 ? void 0 : sliderProps.slotProps) === null || _a === void 0 ? void 0 : _a.input) === null || _b === void 0 ? void 0 : _b.ref) {\n                //@ts-ignore\n                sliderProps.slotProps.input.ref = node;\n              }\n            }\n          }\n        }\n      },\n      sx: theme => Object.assign({\n        m: 'auto',\n        minWidth: `${column.getSize() - 50}px`,\n        mt: !showChangeModeButton ? '10px' : '6px',\n        px: '4px',\n        width: 'calc(100% - 8px)'\n      }, parseFromValuesOrFunc(sliderProps === null || sliderProps === void 0 ? void 0 : sliderProps.sx, theme))\n    })), showChangeModeButton ? jsx(FormHelperText, {\n      sx: {\n        fontSize: '0.75rem',\n        lineHeight: '0.8rem',\n        m: '-3px -6px',\n        whiteSpace: 'nowrap'\n      },\n      children: localization.filterMode.replace('{filterType}',\n      // @ts-ignore\n      localization[`filter${((_c = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt(0)) === null || _c === void 0 ? void 0 : _c.toUpperCase()) + (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`])\n    }) : null]\n  });\n};\nconst MRT_TableHeadCellFilterContainer = _a => {\n  var {\n      header,\n      table\n    } = _a,\n    rest = __rest(_a, [\"header\", \"table\"]);\n  const {\n    getState,\n    options: {\n      columnFilterDisplayMode\n    }\n  } = table;\n  const {\n    showColumnFilters\n  } = getState();\n  const {\n    column\n  } = header;\n  const {\n    columnDef\n  } = column;\n  const {\n    isRangeFilter\n  } = getColumnFilterInfo({\n    header,\n    table\n  });\n  return jsx(Collapse, Object.assign({\n    in: showColumnFilters || columnFilterDisplayMode === 'popover',\n    mountOnEnter: true,\n    unmountOnExit: true\n  }, rest, {\n    children: columnDef.filterVariant === 'checkbox' ? jsx(MRT_FilterCheckbox, {\n      column: column,\n      table: table\n    }) : columnDef.filterVariant === 'range-slider' ? jsx(MRT_FilterRangeSlider, {\n      header: header,\n      table: table\n    }) : isRangeFilter ? jsx(MRT_FilterRangeFields, {\n      header: header,\n      table: table\n    }) : jsx(MRT_FilterTextField, {\n      header: header,\n      table: table\n    })\n  }));\n};\nconst MRT_TableHeadCellFilterLabel = _a => {\n  var _b, _c;\n  var {\n      header,\n      table\n    } = _a,\n    rest = __rest(_a, [\"header\", \"table\"]);\n  const {\n    options: {\n      columnFilterDisplayMode,\n      icons: {\n        FilterAltIcon\n      },\n      localization\n    },\n    refs: {\n      filterInputRefs\n    },\n    setShowColumnFilters\n  } = table;\n  const {\n    column\n  } = header;\n  const {\n    columnDef\n  } = column;\n  const filterValue = column.getFilterValue();\n  const [anchorEl, setAnchorEl] = useState(null);\n  const {\n    currentFilterOption,\n    isMultiSelectFilter,\n    isRangeFilter,\n    isSelectFilter\n  } = getColumnFilterInfo({\n    header,\n    table\n  });\n  const dropdownOptions = useDropdownOptions({\n    header,\n    table\n  });\n  const getSelectLabel = index => getValueAndLabel(dropdownOptions === null || dropdownOptions === void 0 ? void 0 : dropdownOptions.find(option => getValueAndLabel(option).value === (index !== undefined ? filterValue[index] : filterValue))).label;\n  const isFilterActive = Array.isArray(filterValue) && filterValue.some(Boolean) || !!filterValue && !Array.isArray(filterValue);\n  const filterTooltip = columnFilterDisplayMode === 'popover' && !isFilterActive ? (_b = localization.filterByColumn) === null || _b === void 0 ? void 0 : _b.replace('{column}', String(columnDef.header)) : localization.filteringByColumn.replace('{column}', String(columnDef.header)).replace('{filterType}', currentFilterOption ?\n  // @ts-ignore\n  localization[`filter${((_c = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt(0)) === null || _c === void 0 ? void 0 : _c.toUpperCase()) + (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`] : '').replace('{filterValue}', `\"${Array.isArray(filterValue) ? filterValue.map((value, index) => isMultiSelectFilter ? getSelectLabel(index) : value).join(`\" ${isRangeFilter ? localization.and : localization.or} \"`) : isSelectFilter ? getSelectLabel() : filterValue}\"`).replace('\" \"', '');\n  return jsxs(Fragment, {\n    children: [jsx(Grow, {\n      in: columnFilterDisplayMode === 'popover' || !!filterValue && !isRangeFilter || isRangeFilter && (\n      // @ts-ignore\n      !!(filterValue === null || filterValue === void 0 ? void 0 : filterValue[0]) || !!(filterValue === null || filterValue === void 0 ? void 0 : filterValue[1])),\n      unmountOnExit: true,\n      children: jsx(Box, {\n        component: \"span\",\n        sx: {\n          flex: '0 0'\n        },\n        children: jsx(Tooltip, {\n          placement: \"top\",\n          title: filterTooltip,\n          children: jsx(IconButton, Object.assign({\n            disableRipple: true,\n            onClick: event => {\n              if (columnFilterDisplayMode === 'popover') {\n                setAnchorEl(event.currentTarget);\n              } else {\n                setShowColumnFilters(true);\n              }\n              queueMicrotask(() => {\n                var _a, _b, _c, _d;\n                (_b = (_a = filterInputRefs.current[`${column.id}-0`]) === null || _a === void 0 ? void 0 : _a.focus) === null || _b === void 0 ? void 0 : _b.call(_a);\n                (_d = (_c = filterInputRefs.current[`${column.id}-0`]) === null || _c === void 0 ? void 0 : _c.select) === null || _d === void 0 ? void 0 : _d.call(_c);\n              });\n              event.stopPropagation();\n            },\n            size: \"small\"\n          }, rest, {\n            sx: theme => Object.assign({\n              height: '16px',\n              ml: '4px',\n              opacity: isFilterActive ? 1 : 0.3,\n              p: '8px',\n              transform: 'scale(0.75)',\n              transition: 'all 150ms ease-in-out',\n              width: '16px'\n            }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)),\n            children: jsx(FilterAltIcon, {})\n          }))\n        })\n      })\n    }), columnFilterDisplayMode === 'popover' && jsx(Popover, {\n      anchorEl: anchorEl,\n      anchorOrigin: {\n        horizontal: 'center',\n        vertical: 'top'\n      },\n      disableScrollLock: true,\n      onClick: event => event.stopPropagation(),\n      onClose: event => {\n        //@ts-ignore\n        event.stopPropagation();\n        setAnchorEl(null);\n      },\n      onKeyDown: event => event.key === 'Enter' && setAnchorEl(null),\n      open: !!anchorEl,\n      slotProps: {\n        paper: {\n          sx: {\n            overflow: 'visible'\n          }\n        }\n      },\n      transformOrigin: {\n        horizontal: 'center',\n        vertical: 'bottom'\n      },\n      children: jsx(Box, {\n        sx: {\n          p: '1rem'\n        },\n        children: jsx(MRT_TableHeadCellFilterContainer, {\n          header: header,\n          table: table\n        })\n      })\n    })]\n  });\n};\nconst MRT_TableHeadCellGrabHandle = _a => {\n  var {\n      column,\n      table,\n      tableHeadCellRef\n    } = _a,\n    rest = __rest(_a, [\"column\", \"table\", \"tableHeadCellRef\"]);\n  const {\n    getState,\n    options: {\n      enableColumnOrdering,\n      muiColumnDragHandleProps\n    },\n    setColumnOrder,\n    setDraggingColumn,\n    setHoveredColumn\n  } = table;\n  const {\n    columnDef\n  } = column;\n  const {\n    columnOrder,\n    draggingColumn,\n    hoveredColumn\n  } = getState();\n  const iconButtonProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiColumnDragHandleProps, {\n    column,\n    table\n  })), parseFromValuesOrFunc(columnDef.muiColumnDragHandleProps, {\n    column,\n    table\n  })), rest);\n  const handleDragStart = event => {\n    var _a;\n    (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragStart) === null || _a === void 0 ? void 0 : _a.call(iconButtonProps, event);\n    setDraggingColumn(column);\n    try {\n      event.dataTransfer.setDragImage(tableHeadCellRef.current, 0, 0);\n    } catch (e) {\n      console.error(e);\n    }\n  };\n  const handleDragEnd = event => {\n    var _a;\n    (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragEnd) === null || _a === void 0 ? void 0 : _a.call(iconButtonProps, event);\n    if ((hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone') {\n      column.toggleGrouping();\n    } else if (enableColumnOrdering && hoveredColumn && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) !== (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id)) {\n      setColumnOrder(reorderColumn(column, hoveredColumn, columnOrder));\n    }\n    setDraggingColumn(null);\n    setHoveredColumn(null);\n  };\n  return jsx(MRT_GrabHandleButton, Object.assign({}, iconButtonProps, {\n    onDragEnd: handleDragEnd,\n    onDragStart: handleDragStart,\n    table: table\n  }));\n};\nconst MRT_TableHeadCellResizeHandle = _a => {\n  var _b;\n  var {\n      header,\n      table\n    } = _a,\n    rest = __rest(_a, [\"header\", \"table\"]);\n  const {\n    getState,\n    options: {\n      columnResizeDirection,\n      columnResizeMode\n    },\n    setColumnSizingInfo\n  } = table;\n  const {\n    density\n  } = getState();\n  const {\n    column\n  } = header;\n  const handler = header.getResizeHandler();\n  const mx = density === 'compact' ? '-8px' : density === 'comfortable' ? '-16px' : '-24px';\n  const lr = column.columnDef.columnDefType === 'display' ? '4px' : '0';\n  return jsx(Box, {\n    className: \"Mui-TableHeadCell-ResizeHandle-Wrapper\",\n    onDoubleClick: () => {\n      setColumnSizingInfo(old => Object.assign(Object.assign({}, old), {\n        isResizingColumn: false\n      }));\n      column.resetSize();\n    },\n    onMouseDown: handler,\n    onTouchStart: handler,\n    style: {\n      transform: column.getIsResizing() && columnResizeMode === 'onEnd' ? `translateX(${(columnResizeDirection === 'rtl' ? -1 : 1) * ((_b = getState().columnSizingInfo.deltaOffset) !== null && _b !== void 0 ? _b : 0)}px)` : undefined\n    },\n    sx: theme => ({\n      '&:active > hr': {\n        backgroundColor: theme.palette.info.main,\n        opacity: header.subHeaders.length || columnResizeMode === 'onEnd' ? 1 : 0\n      },\n      cursor: 'col-resize',\n      left: columnResizeDirection === 'rtl' ? lr : undefined,\n      ml: columnResizeDirection === 'rtl' ? mx : undefined,\n      mr: columnResizeDirection === 'ltr' ? mx : undefined,\n      position: 'absolute',\n      px: '4px',\n      right: columnResizeDirection === 'ltr' ? lr : undefined\n    }),\n    children: jsx(Divider, {\n      className: \"Mui-TableHeadCell-ResizeHandle-Divider\",\n      flexItem: true,\n      orientation: \"vertical\",\n      sx: theme => Object.assign({\n        borderRadius: '2px',\n        borderWidth: '2px',\n        height: '24px',\n        touchAction: 'none',\n        transform: 'translateX(4px)',\n        transition: column.getIsResizing() ? undefined : 'all 150ms ease-in-out',\n        userSelect: 'none',\n        zIndex: 4\n      }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme))\n    })\n  });\n};\nconst MRT_TableHeadCellSortLabel = _a => {\n  var {\n      header,\n      table\n    } = _a,\n    rest = __rest(_a, [\"header\", \"table\"]);\n  const {\n    getState,\n    options: {\n      icons: {\n        ArrowDownwardIcon,\n        SyncAltIcon\n      },\n      localization\n    }\n  } = table;\n  const {\n    column\n  } = header;\n  const {\n    columnDef\n  } = column;\n  const {\n    isLoading,\n    showSkeletons,\n    sorting\n  } = getState();\n  const isSorted = !!column.getIsSorted();\n  const sortTooltip = isLoading || showSkeletons ? '' : column.getIsSorted() ? column.getIsSorted() === 'desc' ? localization.sortedByColumnDesc.replace('{column}', columnDef.header) : localization.sortedByColumnAsc.replace('{column}', columnDef.header) : column.getNextSortingOrder() === 'desc' ? localization.sortByColumnDesc.replace('{column}', columnDef.header) : localization.sortByColumnAsc.replace('{column}', columnDef.header);\n  const direction = isSorted ? column.getIsSorted() : undefined;\n  return jsx(Tooltip, {\n    placement: \"top\",\n    title: sortTooltip,\n    children: jsx(Badge, {\n      badgeContent: sorting.length > 1 ? column.getSortIndex() + 1 : 0,\n      overlap: \"circular\",\n      children: jsx(TableSortLabel, Object.assign({\n        IconComponent: !isSorted ? props => jsx(SyncAltIcon, Object.assign({}, props, {\n          direction: direction,\n          style: {\n            transform: 'rotate(-90deg) scaleX(0.9) translateX(-1px)'\n          }\n        })) : ArrowDownwardIcon,\n        active: true,\n        \"aria-label\": sortTooltip,\n        direction: direction,\n        onClick: e => {\n          var _a;\n          e.stopPropagation();\n          (_a = header.column.getToggleSortingHandler()) === null || _a === void 0 ? void 0 : _a(e);\n        }\n      }, rest, {\n        sx: theme => Object.assign({\n          '.MuiTableSortLabel-icon': {\n            color: `${theme.palette.mode === 'dark' ? theme.palette.text.primary : theme.palette.text.secondary} !important`\n          },\n          flex: '0 0',\n          opacity: isSorted ? 1 : 0.3,\n          transition: 'all 150ms ease-in-out',\n          width: '3ch'\n        }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme))\n      }))\n    })\n  });\n};\nconst MRT_TableHeadCell = _a => {\n  var _b, _c, _d, _f, _g, _h;\n  var {\n      columnVirtualizer,\n      header,\n      staticColumnIndex,\n      table\n    } = _a,\n    rest = __rest(_a, [\"columnVirtualizer\", \"header\", \"staticColumnIndex\", \"table\"]);\n  const theme = useTheme();\n  const {\n    getState,\n    options: {\n      columnFilterDisplayMode,\n      columnResizeDirection,\n      columnResizeMode,\n      enableColumnActions,\n      enableColumnDragging,\n      enableColumnOrdering,\n      enableColumnPinning,\n      enableGrouping,\n      enableMultiSort,\n      layoutMode,\n      mrtTheme: {\n        draggingBorderColor\n      },\n      muiTableHeadCellProps\n    },\n    refs: {\n      tableHeadCellRefs\n    },\n    setHoveredColumn\n  } = table;\n  const {\n    columnSizingInfo,\n    density,\n    draggingColumn,\n    grouping,\n    hoveredColumn,\n    showColumnFilters\n  } = getState();\n  const {\n    column\n  } = header;\n  const {\n    columnDef\n  } = column;\n  const {\n    columnDefType\n  } = columnDef;\n  const tableCellProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableHeadCellProps, {\n    column,\n    table\n  })), parseFromValuesOrFunc(columnDef.muiTableHeadCellProps, {\n    column,\n    table\n  })), rest);\n  const isColumnPinned = enableColumnPinning && columnDef.columnDefType !== 'group' && column.getIsPinned();\n  const showColumnActions = (enableColumnActions || columnDef.enableColumnActions) && columnDef.enableColumnActions !== false;\n  const showDragHandle = enableColumnDragging !== false && columnDef.enableColumnDragging !== false && (enableColumnDragging || enableColumnOrdering && columnDef.enableColumnOrdering !== false || enableGrouping && columnDef.enableGrouping !== false && !grouping.includes(column.id));\n  const headerPL = useMemo(() => {\n    let pl = 0;\n    if (column.getCanSort()) pl += 1;\n    if (showColumnActions) pl += 1.75;\n    if (showDragHandle) pl += 1.5;\n    return pl;\n  }, [showColumnActions, showDragHandle]);\n  const draggingBorders = useMemo(() => {\n    const showResizeBorder = columnSizingInfo.isResizingColumn === column.id && columnResizeMode === 'onChange' && !header.subHeaders.length;\n    const borderStyle = showResizeBorder ? `2px solid ${draggingBorderColor} !important` : (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id ? `1px dashed ${theme.palette.grey[500]}` : (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id ? `2px dashed ${draggingBorderColor}` : undefined;\n    if (showResizeBorder) {\n      return columnResizeDirection === 'ltr' ? {\n        borderRight: borderStyle\n      } : {\n        borderLeft: borderStyle\n      };\n    }\n    const draggingBorders = borderStyle ? {\n      borderLeft: borderStyle,\n      borderRight: borderStyle,\n      borderTop: borderStyle\n    } : undefined;\n    return draggingBorders;\n  }, [draggingColumn, hoveredColumn, columnSizingInfo.isResizingColumn]);\n  const handleDragEnter = _e => {\n    if (enableGrouping && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone') {\n      setHoveredColumn(null);\n    }\n    if (enableColumnOrdering && draggingColumn && columnDefType !== 'group') {\n      setHoveredColumn(columnDef.enableColumnOrdering !== false ? column : null);\n    }\n  };\n  const handleDragOver = e => {\n    if (columnDef.enableColumnOrdering !== false) {\n      e.preventDefault();\n    }\n  };\n  const HeaderElement = (_b = parseFromValuesOrFunc(columnDef.Header, {\n    column,\n    header,\n    table\n  })) !== null && _b !== void 0 ? _b : columnDef.header;\n  return jsxs(TableCell, Object.assign({\n    align: columnDefType === 'group' ? 'center' : theme.direction === 'rtl' ? 'right' : 'left',\n    colSpan: header.colSpan,\n    \"data-index\": staticColumnIndex,\n    \"data-pinned\": !!isColumnPinned || undefined,\n    onDragEnter: handleDragEnter,\n    onDragOver: handleDragOver,\n    ref: node => {\n      var _a;\n      if (node) {\n        tableHeadCellRefs.current[column.id] = node;\n        if (columnDefType !== 'group') {\n          (_a = columnVirtualizer === null || columnVirtualizer === void 0 ? void 0 : columnVirtualizer.measureElement) === null || _a === void 0 ? void 0 : _a.call(columnVirtualizer, node);\n        }\n      }\n    }\n  }, tableCellProps, {\n    sx: theme => Object.assign(Object.assign({\n      '& :hover': {\n        '.MuiButtonBase-root': {\n          opacity: 1\n        }\n      },\n      flexDirection: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'column' : undefined,\n      fontWeight: 'bold',\n      overflow: 'visible',\n      p: density === 'compact' ? '0.5rem' : density === 'comfortable' ? columnDefType === 'display' ? '0.75rem' : '1rem' : columnDefType === 'display' ? '1rem 1.25rem' : '1.5rem',\n      pb: columnDefType === 'display' ? 0 : showColumnFilters || density === 'compact' ? '0.4rem' : '0.6rem',\n      pt: columnDefType === 'group' || density === 'compact' ? '0.25rem' : density === 'comfortable' ? '.75rem' : '1.25rem',\n      userSelect: enableMultiSort && column.getCanSort() ? 'none' : undefined,\n      verticalAlign: 'top'\n    }, getCommonMRTCellStyles({\n      column,\n      header,\n      table,\n      tableCellProps,\n      theme\n    })), draggingBorders),\n    children: [header.isPlaceholder ? null : (_c = tableCellProps.children) !== null && _c !== void 0 ? _c : jsxs(Box, {\n      className: \"Mui-TableHeadCell-Content\",\n      sx: {\n        alignItems: 'center',\n        display: 'flex',\n        flexDirection: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'right' ? 'row-reverse' : 'row',\n        justifyContent: columnDefType === 'group' || (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'center' ? 'center' : column.getCanResize() ? 'space-between' : 'flex-start',\n        position: 'relative',\n        width: '100%'\n      },\n      children: [jsxs(Box, {\n        className: \"Mui-TableHeadCell-Content-Labels\",\n        onClick: column.getToggleSortingHandler(),\n        sx: {\n          alignItems: 'center',\n          cursor: column.getCanSort() && columnDefType !== 'group' ? 'pointer' : undefined,\n          display: 'flex',\n          flexDirection: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'right' ? 'row-reverse' : 'row',\n          overflow: columnDefType === 'data' ? 'hidden' : undefined,\n          pl: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'center' ? `${headerPL}rem` : undefined\n        },\n        children: [jsx(Box, {\n          className: \"Mui-TableHeadCell-Content-Wrapper\",\n          sx: {\n            '&:hover': {\n              textOverflow: 'clip'\n            },\n            minWidth: `${Math.min((_f = (_d = columnDef.header) === null || _d === void 0 ? void 0 : _d.length) !== null && _f !== void 0 ? _f : 0, 4)}ch`,\n            overflow: columnDefType === 'data' ? 'hidden' : undefined,\n            textOverflow: 'ellipsis',\n            whiteSpace: ((_h = (_g = columnDef.header) === null || _g === void 0 ? void 0 : _g.length) !== null && _h !== void 0 ? _h : 0) < 20 ? 'nowrap' : 'normal'\n          },\n          children: HeaderElement\n        }), column.getCanFilter() && jsx(MRT_TableHeadCellFilterLabel, {\n          header: header,\n          table: table\n        }), column.getCanSort() && jsx(MRT_TableHeadCellSortLabel, {\n          header: header,\n          table: table\n        })]\n      }), columnDefType !== 'group' && jsxs(Box, {\n        className: \"Mui-TableHeadCell-Content-Actions\",\n        sx: {\n          whiteSpace: 'nowrap'\n        },\n        children: [showDragHandle && jsx(MRT_TableHeadCellGrabHandle, {\n          column: column,\n          table: table,\n          tableHeadCellRef: {\n            current: tableHeadCellRefs.current[column.id]\n          }\n        }), showColumnActions && jsx(MRT_TableHeadCellColumnActionsButton, {\n          header: header,\n          table: table\n        })]\n      }), column.getCanResize() && jsx(MRT_TableHeadCellResizeHandle, {\n        header: header,\n        table: table\n      })]\n    }), columnFilterDisplayMode === 'subheader' && column.getCanFilter() && jsx(MRT_TableHeadCellFilterContainer, {\n      header: header,\n      table: table\n    })]\n  }));\n};\nconst MRT_TableHeadRow = _a => {\n  var {\n      columnVirtualizer,\n      headerGroup,\n      table\n    } = _a,\n    rest = __rest(_a, [\"columnVirtualizer\", \"headerGroup\", \"table\"]);\n  const {\n    options: {\n      enableStickyHeader,\n      layoutMode,\n      mrtTheme: {\n        baseBackgroundColor\n      },\n      muiTableHeadRowProps\n    }\n  } = table;\n  const {\n    virtualColumns,\n    virtualPaddingLeft,\n    virtualPaddingRight\n  } = columnVirtualizer !== null && columnVirtualizer !== void 0 ? columnVirtualizer : {};\n  const tableRowProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableHeadRowProps, {\n    headerGroup,\n    table\n  })), rest);\n  return jsxs(TableRow, Object.assign({}, tableRowProps, {\n    sx: theme => Object.assign({\n      backgroundColor: baseBackgroundColor,\n      boxShadow: `4px 0 8px ${alpha(theme.palette.common.black, 0.1)}`,\n      display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'flex' : undefined,\n      position: enableStickyHeader && layoutMode === 'semantic' ? 'sticky' : 'relative',\n      top: 0\n    }, parseFromValuesOrFunc(tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx, theme)),\n    children: [virtualPaddingLeft ? jsx(\"th\", {\n      style: {\n        display: 'flex',\n        width: virtualPaddingLeft\n      }\n    }) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : headerGroup.headers).map((headerOrVirtualHeader, staticColumnIndex) => {\n      let header = headerOrVirtualHeader;\n      if (columnVirtualizer) {\n        staticColumnIndex = headerOrVirtualHeader.index;\n        header = headerGroup.headers[staticColumnIndex];\n      }\n      return header ? jsx(MRT_TableHeadCell, {\n        columnVirtualizer: columnVirtualizer,\n        header: header,\n        staticColumnIndex: staticColumnIndex,\n        table: table\n      }, header.id) : null;\n    }), virtualPaddingRight ? jsx(\"th\", {\n      style: {\n        display: 'flex',\n        width: virtualPaddingRight\n      }\n    }) : null]\n  }));\n};\nconst MRT_ToolbarAlertBanner = _a => {\n  var _b, _c, _d;\n  var {\n      stackAlertBanner,\n      table\n    } = _a,\n    rest = __rest(_a, [\"stackAlertBanner\", \"table\"]);\n  const {\n    getFilteredSelectedRowModel,\n    getPrePaginationRowModel,\n    getState,\n    options: {\n      enableRowSelection,\n      enableSelectAll,\n      localization,\n      manualPagination,\n      muiToolbarAlertBannerChipProps,\n      muiToolbarAlertBannerProps,\n      positionToolbarAlertBanner,\n      renderToolbarAlertBannerContent,\n      rowCount\n    },\n    refs: {\n      tablePaperRef\n    }\n  } = table;\n  const {\n    density,\n    grouping,\n    rowSelection,\n    showAlertBanner\n  } = getState();\n  const alertProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiToolbarAlertBannerProps, {\n    table\n  })), rest);\n  const chipProps = parseFromValuesOrFunc(muiToolbarAlertBannerChipProps, {\n    table\n  });\n  const totalRowCount = rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().flatRows.length;\n  const selectedRowCount = useMemo(() => manualPagination ? Object.values(rowSelection).filter(Boolean).length : getFilteredSelectedRowModel().rows.length, [rowSelection, totalRowCount, manualPagination]);\n  const selectedAlert = selectedRowCount > 0 ? jsxs(Stack, {\n    alignItems: \"center\",\n    direction: \"row\",\n    gap: \"16px\",\n    children: [(_c = (_b = localization.selectedCountOfRowCountRowsSelected) === null || _b === void 0 ? void 0 : _b.replace('{selectedCount}', selectedRowCount.toLocaleString())) === null || _c === void 0 ? void 0 : _c.replace('{rowCount}', totalRowCount.toString()), jsx(Button, {\n      onClick: event => getMRT_SelectAllHandler({\n        table\n      })(event, false, true),\n      size: \"small\",\n      sx: {\n        p: '2px'\n      },\n      children: localization.clearSelection\n    })]\n  }) : null;\n  const groupedAlert = grouping.length > 0 ? jsxs(\"span\", {\n    children: [localization.groupedBy, ' ', grouping.map((columnId, index) => jsxs(Fragment$1, {\n      children: [index > 0 ? localization.thenBy : '', jsx(Chip, Object.assign({\n        label: table.getColumn(columnId).columnDef.header,\n        onDelete: () => table.getColumn(columnId).toggleGrouping()\n      }, chipProps))]\n    }, `${index}-${columnId}`))]\n  }) : null;\n  return jsx(Collapse, {\n    in: showAlertBanner || !!selectedAlert || !!groupedAlert,\n    timeout: stackAlertBanner ? 200 : 0,\n    children: jsx(Alert, Object.assign({\n      color: \"info\",\n      icon: false\n    }, alertProps, {\n      sx: theme => {\n        var _a, _b;\n        return Object.assign({\n          '& .MuiAlert-message': {\n            maxWidth: `calc(${(_b = (_a = tablePaperRef.current) === null || _a === void 0 ? void 0 : _a.clientWidth) !== null && _b !== void 0 ? _b : 360}px - 1rem)`,\n            width: '100%'\n          },\n          borderRadius: 0,\n          fontSize: '1rem',\n          left: 0,\n          mb: stackAlertBanner ? 0 : positionToolbarAlertBanner === 'bottom' ? '-1rem' : undefined,\n          p: 0,\n          position: 'relative',\n          right: 0,\n          top: 0,\n          width: '100%',\n          zIndex: 2\n        }, parseFromValuesOrFunc(alertProps === null || alertProps === void 0 ? void 0 : alertProps.sx, theme));\n      },\n      children: (_d = renderToolbarAlertBannerContent === null || renderToolbarAlertBannerContent === void 0 ? void 0 : renderToolbarAlertBannerContent({\n        groupedAlert,\n        selectedAlert,\n        table\n      })) !== null && _d !== void 0 ? _d : jsxs(Fragment, {\n        children: [(alertProps === null || alertProps === void 0 ? void 0 : alertProps.title) && jsx(AlertTitle, {\n          children: alertProps.title\n        }), jsxs(Stack, {\n          sx: {\n            p: positionToolbarAlertBanner !== 'head-overlay' ? '0.5rem 1rem' : density === 'spacious' ? '0.75rem 1.25rem' : density === 'comfortable' ? '0.5rem 0.75rem' : '0.25rem 0.5rem'\n          },\n          children: [alertProps === null || alertProps === void 0 ? void 0 : alertProps.children, (alertProps === null || alertProps === void 0 ? void 0 : alertProps.children) && (selectedAlert || groupedAlert) && jsx(\"br\", {}), jsxs(Box, {\n            sx: {\n              display: 'flex'\n            },\n            children: [enableRowSelection && enableSelectAll && positionToolbarAlertBanner === 'head-overlay' && jsx(MRT_SelectCheckbox, {\n              table: table\n            }), ' ', selectedAlert]\n          }), selectedAlert && groupedAlert && jsx(\"br\", {}), groupedAlert]\n        })]\n      })\n    }))\n  });\n};\nconst MRT_TableHead = _a => {\n  var {\n      columnVirtualizer,\n      table\n    } = _a,\n    rest = __rest(_a, [\"columnVirtualizer\", \"table\"]);\n  const {\n    getState,\n    options: {\n      enableStickyHeader,\n      layoutMode,\n      muiTableHeadProps,\n      positionToolbarAlertBanner\n    },\n    refs: {\n      tableHeadRef\n    }\n  } = table;\n  const {\n    isFullScreen,\n    showAlertBanner\n  } = getState();\n  const tableHeadProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableHeadProps, {\n    table\n  })), rest);\n  const stickyHeader = enableStickyHeader || isFullScreen;\n  return jsx(TableHead, Object.assign({}, tableHeadProps, {\n    ref: ref => {\n      tableHeadRef.current = ref;\n      if (tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.ref) {\n        // @ts-ignore\n        tableHeadProps.ref.current = ref;\n      }\n    },\n    sx: theme => Object.assign({\n      display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined,\n      opacity: 0.97,\n      position: stickyHeader ? 'sticky' : 'relative',\n      top: stickyHeader && (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 0 : undefined,\n      zIndex: stickyHeader ? 2 : undefined\n    }, parseFromValuesOrFunc(tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.sx, theme)),\n    children: positionToolbarAlertBanner === 'head-overlay' && (showAlertBanner || table.getSelectedRowModel().rows.length > 0) ? jsx(\"tr\", {\n      style: {\n        display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined\n      },\n      children: jsx(\"th\", {\n        colSpan: table.getVisibleLeafColumns().length,\n        style: {\n          display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined,\n          padding: 0\n        },\n        children: jsx(MRT_ToolbarAlertBanner, {\n          table: table\n        })\n      })\n    }) : table.getHeaderGroups().map(headerGroup => jsx(MRT_TableHeadRow, {\n      columnVirtualizer: columnVirtualizer,\n      headerGroup: headerGroup,\n      table: table\n    }, headerGroup.id))\n  }));\n};\nconst MRT_Table = _a => {\n  var {\n      table\n    } = _a,\n    rest = __rest(_a, [\"table\"]);\n  const {\n    getFlatHeaders,\n    getState,\n    options: {\n      columns,\n      enableStickyHeader,\n      enableTableFooter,\n      enableTableHead,\n      layoutMode,\n      memoMode,\n      muiTableProps,\n      renderCaption\n    }\n  } = table;\n  const {\n    columnSizing,\n    columnSizingInfo,\n    columnVisibility,\n    isFullScreen\n  } = getState();\n  const tableProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableProps, {\n    table\n  })), rest);\n  const Caption = parseFromValuesOrFunc(renderCaption, {\n    table\n  });\n  const columnSizeVars = useMemo(() => {\n    const headers = getFlatHeaders();\n    const colSizes = {};\n    for (let i = 0; i < headers.length; i++) {\n      const header = headers[i];\n      const colSize = header.getSize();\n      colSizes[`--header-${parseCSSVarId(header.id)}-size`] = colSize;\n      colSizes[`--col-${parseCSSVarId(header.column.id)}-size`] = colSize;\n    }\n    return colSizes;\n  }, [columns, columnSizing, columnSizingInfo, columnVisibility]);\n  const columnVirtualizer = useMRT_ColumnVirtualizer(table);\n  const commonTableGroupProps = {\n    columnVirtualizer,\n    table\n  };\n  return jsxs(Table, Object.assign({\n    stickyHeader: enableStickyHeader || isFullScreen\n  }, tableProps, {\n    style: Object.assign(Object.assign({}, columnSizeVars), tableProps === null || tableProps === void 0 ? void 0 : tableProps.style),\n    sx: theme => Object.assign({\n      borderCollapse: 'separate',\n      display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined,\n      position: 'relative'\n    }, parseFromValuesOrFunc(tableProps === null || tableProps === void 0 ? void 0 : tableProps.sx, theme)),\n    children: [!!Caption && jsx(\"caption\", {\n      children: Caption\n    }), enableTableHead && jsx(MRT_TableHead, Object.assign({}, commonTableGroupProps)), memoMode === 'table-body' || columnSizingInfo.isResizingColumn ? jsx(Memo_MRT_TableBody, Object.assign({}, commonTableGroupProps)) : jsx(MRT_TableBody, Object.assign({}, commonTableGroupProps)), enableTableFooter && jsx(MRT_TableFooter, Object.assign({}, commonTableGroupProps))]\n  }));\n};\nconst MRT_TableLoadingOverlay = _a => {\n  var _b;\n  var {\n      table\n    } = _a,\n    rest = __rest(_a, [\"table\"]);\n  const {\n    options: {\n      localization,\n      mrtTheme: {\n        baseBackgroundColor\n      },\n      muiCircularProgressProps\n    }\n  } = table;\n  const circularProgressProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiCircularProgressProps, {\n    table\n  })), rest);\n  return jsx(Box, {\n    sx: {\n      alignItems: 'center',\n      backgroundColor: alpha(baseBackgroundColor, 0.5),\n      bottom: 0,\n      display: 'flex',\n      justifyContent: 'center',\n      left: 0,\n      maxHeight: '100vh',\n      position: 'absolute',\n      right: 0,\n      top: 0,\n      width: '100%',\n      zIndex: 3\n    },\n    children: (_b = circularProgressProps === null || circularProgressProps === void 0 ? void 0 : circularProgressProps.Component) !== null && _b !== void 0 ? _b : jsx(CircularProgress, Object.assign({\n      \"aria-label\": localization.noRecordsToDisplay,\n      id: \"mrt-progress\"\n    }, circularProgressProps))\n  });\n};\nconst MRT_CellActionMenu = _a => {\n  var _b, _c;\n  var {\n      table\n    } = _a,\n    rest = __rest(_a, [\"table\"]);\n  const {\n    getState,\n    options: {\n      editDisplayMode,\n      enableClickToCopy,\n      enableEditing,\n      icons: {\n        ContentCopy,\n        EditIcon\n      },\n      localization,\n      mrtTheme: {\n        menuBackgroundColor\n      },\n      renderCellActionMenuItems\n    },\n    refs: {\n      actionCellRef\n    }\n  } = table;\n  const {\n    actionCell,\n    density\n  } = getState();\n  const cell = actionCell;\n  const {\n    row\n  } = cell;\n  const {\n    column\n  } = cell;\n  const {\n    columnDef\n  } = column;\n  const handleClose = event => {\n    event === null || event === void 0 ? void 0 : event.stopPropagation();\n    table.setActionCell(null);\n    actionCellRef.current = null;\n  };\n  const internalMenuItems = [(parseFromValuesOrFunc(enableClickToCopy, cell) === 'context-menu' || parseFromValuesOrFunc(columnDef.enableClickToCopy, cell) === 'context-menu') && jsx(MRT_ActionMenuItem, {\n    icon: jsx(ContentCopy, {}),\n    label: localization.copy,\n    onClick: event => {\n      event.stopPropagation();\n      navigator.clipboard.writeText(cell.getValue());\n      handleClose();\n    },\n    table: table\n  }, 'mrt-copy'), parseFromValuesOrFunc(enableEditing, row) && editDisplayMode === 'cell' && jsx(MRT_ActionMenuItem, {\n    icon: jsx(EditIcon, {}),\n    label: localization.edit,\n    onClick: () => {\n      openEditingCell({\n        cell,\n        table\n      });\n      handleClose();\n    },\n    table: table\n  }, 'mrt-edit')].filter(Boolean);\n  const renderActionProps = {\n    cell,\n    closeMenu: handleClose,\n    column,\n    internalMenuItems,\n    row,\n    table\n  };\n  const menuItems = (_c = (_b = columnDef.renderCellActionMenuItems) === null || _b === void 0 ? void 0 : _b.call(columnDef, renderActionProps)) !== null && _c !== void 0 ? _c : renderCellActionMenuItems === null || renderCellActionMenuItems === void 0 ? void 0 : renderCellActionMenuItems(renderActionProps);\n  return (!!(menuItems === null || menuItems === void 0 ? void 0 : menuItems.length) || !!(internalMenuItems === null || internalMenuItems === void 0 ? void 0 : internalMenuItems.length)) && jsx(Menu, Object.assign({\n    MenuListProps: {\n      dense: density === 'compact',\n      sx: {\n        backgroundColor: menuBackgroundColor\n      }\n    },\n    anchorEl: actionCellRef.current,\n    disableScrollLock: true,\n    onClick: event => event.stopPropagation(),\n    onClose: handleClose,\n    open: !!cell,\n    transformOrigin: {\n      horizontal: -100,\n      vertical: 8\n    }\n  }, rest, {\n    children: menuItems !== null && menuItems !== void 0 ? menuItems : internalMenuItems\n  }));\n};\nconst MRT_EditRowModal = _a => {\n  var _b;\n  var {\n      open,\n      table\n    } = _a,\n    rest = __rest(_a, [\"open\", \"table\"]);\n  const {\n    getState,\n    options: {\n      localization,\n      muiCreateRowModalProps,\n      muiEditRowDialogProps,\n      onCreatingRowCancel,\n      onEditingRowCancel,\n      renderCreateRowDialogContent,\n      renderEditRowDialogContent\n    },\n    setCreatingRow,\n    setEditingRow\n  } = table;\n  const {\n    creatingRow,\n    editingRow\n  } = getState();\n  const row = creatingRow !== null && creatingRow !== void 0 ? creatingRow : editingRow;\n  const dialogProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiEditRowDialogProps, {\n    row,\n    table\n  })), creatingRow && parseFromValuesOrFunc(muiCreateRowModalProps, {\n    row,\n    table\n  })), rest);\n  const internalEditComponents = row.getAllCells().filter(cell => cell.column.columnDef.columnDefType === 'data').map(cell => jsx(MRT_EditCellTextField, {\n    cell: cell,\n    table: table\n  }, cell.id));\n  return jsx(Dialog, Object.assign({\n    fullWidth: true,\n    maxWidth: \"xs\",\n    onClose: (event, reason) => {\n      var _a;\n      if (creatingRow) {\n        onCreatingRowCancel === null || onCreatingRowCancel === void 0 ? void 0 : onCreatingRowCancel({\n          row,\n          table\n        });\n        setCreatingRow(null);\n      } else {\n        onEditingRowCancel === null || onEditingRowCancel === void 0 ? void 0 : onEditingRowCancel({\n          row,\n          table\n        });\n        setEditingRow(null);\n      }\n      row._valuesCache = {}; //reset values cache\n      (_a = dialogProps.onClose) === null || _a === void 0 ? void 0 : _a.call(dialogProps, event, reason);\n    },\n    open: open\n  }, dialogProps, {\n    children: (_b = creatingRow && (renderCreateRowDialogContent === null || renderCreateRowDialogContent === void 0 ? void 0 : renderCreateRowDialogContent({\n      internalEditComponents,\n      row,\n      table\n    })) || (renderEditRowDialogContent === null || renderEditRowDialogContent === void 0 ? void 0 : renderEditRowDialogContent({\n      internalEditComponents,\n      row,\n      table\n    }))) !== null && _b !== void 0 ? _b : jsxs(Fragment, {\n      children: [jsx(DialogTitle, {\n        sx: {\n          textAlign: 'center'\n        },\n        children: localization.edit\n      }), jsx(DialogContent, {\n        children: jsx(\"form\", {\n          onSubmit: e => e.preventDefault(),\n          children: jsx(Stack, {\n            sx: {\n              gap: '32px',\n              paddingTop: '16px',\n              width: '100%'\n            },\n            children: internalEditComponents\n          })\n        })\n      }), jsx(DialogActions, {\n        sx: {\n          p: '1.25rem'\n        },\n        children: jsx(MRT_EditActionButtons, {\n          row: row,\n          table: table,\n          variant: \"text\"\n        })\n      })]\n    })\n  }));\n};\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\nconst MRT_TableContainer = _a => {\n  var {\n      table\n    } = _a,\n    rest = __rest(_a, [\"table\"]);\n  const {\n    getState,\n    options: {\n      createDisplayMode,\n      editDisplayMode,\n      enableCellActions,\n      enableStickyHeader,\n      muiTableContainerProps\n    },\n    refs: {\n      bottomToolbarRef,\n      tableContainerRef,\n      topToolbarRef\n    }\n  } = table;\n  const {\n    actionCell,\n    creatingRow,\n    editingRow,\n    isFullScreen,\n    isLoading,\n    showLoadingOverlay\n  } = getState();\n  const loading = showLoadingOverlay !== false && (isLoading || showLoadingOverlay);\n  const [totalToolbarHeight, setTotalToolbarHeight] = useState(0);\n  const tableContainerProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableContainerProps, {\n    table\n  })), rest);\n  useIsomorphicLayoutEffect(() => {\n    var _a, _b, _c, _d;\n    const topToolbarHeight = typeof document !== 'undefined' ? (_b = (_a = topToolbarRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) !== null && _b !== void 0 ? _b : 0 : 0;\n    const bottomToolbarHeight = typeof document !== 'undefined' ? (_d = (_c = bottomToolbarRef === null || bottomToolbarRef === void 0 ? void 0 : bottomToolbarRef.current) === null || _c === void 0 ? void 0 : _c.offsetHeight) !== null && _d !== void 0 ? _d : 0 : 0;\n    setTotalToolbarHeight(topToolbarHeight + bottomToolbarHeight);\n  });\n  const createModalOpen = createDisplayMode === 'modal' && creatingRow;\n  const editModalOpen = editDisplayMode === 'modal' && editingRow;\n  return jsxs(TableContainer, Object.assign({\n    \"aria-busy\": loading,\n    \"aria-describedby\": loading ? 'mrt-progress' : undefined\n  }, tableContainerProps, {\n    ref: node => {\n      if (node) {\n        tableContainerRef.current = node;\n        if (tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.ref) {\n          //@ts-ignore\n          tableContainerProps.ref.current = node;\n        }\n      }\n    },\n    style: Object.assign({\n      maxHeight: isFullScreen ? `calc(100vh - ${totalToolbarHeight}px)` : undefined\n    }, tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.style),\n    sx: theme => Object.assign({\n      maxHeight: enableStickyHeader ? `clamp(350px, calc(100vh - ${totalToolbarHeight}px), 9999px)` : undefined,\n      maxWidth: '100%',\n      overflow: 'auto',\n      position: 'relative'\n    }, parseFromValuesOrFunc(tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.sx, theme)),\n    children: [loading ? jsx(MRT_TableLoadingOverlay, {\n      table: table\n    }) : null, jsx(MRT_Table, {\n      table: table\n    }), (createModalOpen || editModalOpen) && jsx(MRT_EditRowModal, {\n      open: true,\n      table: table\n    }), enableCellActions && actionCell && jsx(MRT_CellActionMenu, {\n      table: table\n    })]\n  }));\n};\nconst MRT_LinearProgressBar = _a => {\n  var {\n      isTopToolbar,\n      table\n    } = _a,\n    rest = __rest(_a, [\"isTopToolbar\", \"table\"]);\n  const {\n    getState,\n    options: {\n      muiLinearProgressProps\n    }\n  } = table;\n  const {\n    isSaving,\n    showProgressBars\n  } = getState();\n  const linearProgressProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiLinearProgressProps, {\n    isTopToolbar,\n    table\n  })), rest);\n  return jsx(Collapse, {\n    in: showProgressBars !== false && (showProgressBars || isSaving),\n    mountOnEnter: true,\n    sx: {\n      bottom: isTopToolbar ? 0 : undefined,\n      position: 'absolute',\n      top: !isTopToolbar ? 0 : undefined,\n      width: '100%'\n    },\n    unmountOnExit: true,\n    children: jsx(LinearProgress, Object.assign({\n      \"aria-busy\": \"true\",\n      \"aria-label\": \"Loading\",\n      sx: {\n        position: 'relative'\n      }\n    }, linearProgressProps))\n  });\n};\nconst defaultRowsPerPage = [5, 10, 15, 20, 25, 30, 50, 100];\nconst MRT_TablePagination = _a => {\n  var {\n      position = 'bottom',\n      table\n    } = _a,\n    rest = __rest(_a, [\"position\", \"table\"]);\n  const theme = useTheme();\n  const isMobile = useMediaQuery('(max-width: 720px)');\n  const {\n    getState,\n    options: {\n      enableToolbarInternalActions,\n      icons: {\n        ChevronLeftIcon,\n        ChevronRightIcon,\n        FirstPageIcon,\n        LastPageIcon\n      },\n      localization,\n      muiPaginationProps,\n      paginationDisplayMode\n    }\n  } = table;\n  const {\n    pagination: {\n      pageIndex = 0,\n      pageSize = 10\n    },\n    showGlobalFilter\n  } = getState();\n  const paginationProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiPaginationProps, {\n    table\n  })), rest);\n  const totalRowCount = table.getRowCount();\n  const numberOfPages = table.getPageCount();\n  const showFirstLastPageButtons = numberOfPages > 2;\n  const firstRowIndex = pageIndex * pageSize;\n  const lastRowIndex = Math.min(pageIndex * pageSize + pageSize, totalRowCount);\n  const _b = paginationProps !== null && paginationProps !== void 0 ? paginationProps : {},\n    {\n      SelectProps = {},\n      disabled = false,\n      rowsPerPageOptions = defaultRowsPerPage,\n      showFirstButton = showFirstLastPageButtons,\n      showLastButton = showFirstLastPageButtons,\n      showRowsPerPage = true\n    } = _b,\n    restPaginationProps = __rest(_b, [\"SelectProps\", \"disabled\", \"rowsPerPageOptions\", \"showFirstButton\", \"showLastButton\", \"showRowsPerPage\"]);\n  const disableBack = pageIndex <= 0 || disabled;\n  const disableNext = lastRowIndex >= totalRowCount || disabled;\n  if (isMobile && (SelectProps === null || SelectProps === void 0 ? void 0 : SelectProps.native) !== false) {\n    SelectProps.native = true;\n  }\n  const tooltipProps = getCommonTooltipProps();\n  return jsxs(Box, {\n    className: \"MuiTablePagination-root\",\n    sx: {\n      alignItems: 'center',\n      display: 'flex',\n      flexWrap: 'wrap',\n      gap: '8px',\n      justifyContent: {\n        md: 'space-between',\n        sm: 'center'\n      },\n      justifySelf: 'flex-end',\n      mt: position === 'top' && enableToolbarInternalActions && !showGlobalFilter ? '3rem' : undefined,\n      position: 'relative',\n      px: '8px',\n      py: '12px',\n      zIndex: 2\n    },\n    children: [showRowsPerPage && jsxs(Box, {\n      sx: {\n        alignItems: 'center',\n        display: 'flex',\n        gap: '8px'\n      },\n      children: [jsx(InputLabel, {\n        htmlFor: \"mrt-rows-per-page\",\n        sx: {\n          mb: 0\n        },\n        children: localization.rowsPerPage\n      }), jsx(Select, Object.assign({\n        MenuProps: {\n          disableScrollLock: true\n        },\n        disableUnderline: true,\n        disabled: disabled,\n        inputProps: {\n          'aria-label': localization.rowsPerPage,\n          id: 'mrt-rows-per-page'\n        },\n        label: localization.rowsPerPage,\n        onChange: event => table.setPageSize(+event.target.value),\n        sx: {\n          mb: 0\n        },\n        value: pageSize,\n        variant: \"standard\"\n      }, SelectProps, {\n        children: rowsPerPageOptions.map(option => {\n          var _a;\n          const value = typeof option !== 'number' ? option.value : option;\n          const label = typeof option !== 'number' ? option.label : `${option}`;\n          return (_a = SelectProps === null || SelectProps === void 0 ? void 0 : SelectProps.children) !== null && _a !== void 0 ? _a : (SelectProps === null || SelectProps === void 0 ? void 0 : SelectProps.native) ? jsx(\"option\", {\n            value: value,\n            children: label\n          }, value) : jsx(MenuItem, {\n            sx: {\n              m: 0\n            },\n            value: value,\n            children: label\n          }, value);\n        })\n      }))]\n    }), paginationDisplayMode === 'pages' ? jsx(Pagination, Object.assign({\n      count: numberOfPages,\n      disabled: disabled,\n      onChange: (_e, newPageIndex) => table.setPageIndex(newPageIndex - 1),\n      page: pageIndex + 1,\n      renderItem: item => jsx(PaginationItem, Object.assign({\n        slots: {\n          first: FirstPageIcon,\n          last: LastPageIcon,\n          next: ChevronRightIcon,\n          previous: ChevronLeftIcon\n        }\n      }, item)),\n      showFirstButton: showFirstButton,\n      showLastButton: showLastButton\n    }, restPaginationProps)) : paginationDisplayMode === 'default' ? jsxs(Fragment, {\n      children: [jsx(Typography, {\n        align: \"center\",\n        component: \"span\",\n        sx: {\n          m: '0 4px',\n          minWidth: '8ch'\n        },\n        variant: \"body2\",\n        children: `${lastRowIndex === 0 ? 0 : (firstRowIndex + 1).toLocaleString()}-${lastRowIndex.toLocaleString()} ${localization.of} ${totalRowCount.toLocaleString()}`\n      }), jsxs(Box, {\n        gap: \"xs\",\n        children: [showFirstButton && jsx(Tooltip, Object.assign({}, tooltipProps, {\n          title: localization.goToFirstPage,\n          children: jsx(\"span\", {\n            children: jsx(IconButton, {\n              \"aria-label\": localization.goToFirstPage,\n              disabled: disableBack,\n              onClick: () => table.firstPage(),\n              size: \"small\",\n              children: jsx(FirstPageIcon, Object.assign({}, flipIconStyles(theme)))\n            })\n          })\n        })), jsx(Tooltip, Object.assign({}, tooltipProps, {\n          title: localization.goToPreviousPage,\n          children: jsx(\"span\", {\n            children: jsx(IconButton, {\n              \"aria-label\": localization.goToPreviousPage,\n              disabled: disableBack,\n              onClick: () => table.previousPage(),\n              size: \"small\",\n              children: jsx(ChevronLeftIcon, Object.assign({}, flipIconStyles(theme)))\n            })\n          })\n        })), jsx(Tooltip, Object.assign({}, tooltipProps, {\n          title: localization.goToNextPage,\n          children: jsx(\"span\", {\n            children: jsx(IconButton, {\n              \"aria-label\": localization.goToNextPage,\n              disabled: disableNext,\n              onClick: () => table.nextPage(),\n              size: \"small\",\n              children: jsx(ChevronRightIcon, Object.assign({}, flipIconStyles(theme)))\n            })\n          })\n        })), showLastButton && jsx(Tooltip, Object.assign({}, tooltipProps, {\n          title: localization.goToLastPage,\n          children: jsx(\"span\", {\n            children: jsx(IconButton, {\n              \"aria-label\": localization.goToLastPage,\n              disabled: disableNext,\n              onClick: () => table.lastPage(),\n              size: \"small\",\n              children: jsx(LastPageIcon, Object.assign({}, flipIconStyles(theme)))\n            })\n          })\n        }))]\n      })]\n    }) : null]\n  });\n};\nconst MRT_ToolbarDropZone = _a => {\n  var _b, _c;\n  var {\n      table\n    } = _a,\n    rest = __rest(_a, [\"table\"]);\n  const {\n    getState,\n    options: {\n      enableGrouping,\n      localization\n    },\n    setHoveredColumn,\n    setShowToolbarDropZone\n  } = table;\n  const {\n    draggingColumn,\n    grouping,\n    hoveredColumn,\n    showToolbarDropZone\n  } = getState();\n  const handleDragEnter = _event => {\n    setHoveredColumn({\n      id: 'drop-zone'\n    });\n  };\n  const handleDragOver = e => {\n    e.preventDefault();\n  };\n  useEffect(() => {\n    var _a;\n    if (((_a = table.options.state) === null || _a === void 0 ? void 0 : _a.showToolbarDropZone) !== undefined) {\n      setShowToolbarDropZone(!!enableGrouping && !!draggingColumn && draggingColumn.columnDef.enableGrouping !== false && !grouping.includes(draggingColumn.id));\n    }\n  }, [enableGrouping, draggingColumn, grouping]);\n  return jsx(Fade, {\n    in: showToolbarDropZone,\n    children: jsx(Box, Object.assign({\n      className: \"Mui-ToolbarDropZone\",\n      onDragEnter: handleDragEnter,\n      onDragOver: handleDragOver\n    }, rest, {\n      sx: theme => Object.assign({\n        alignItems: 'center',\n        backdropFilter: 'blur(4px)',\n        backgroundColor: alpha(theme.palette.info.main, (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone' ? 0.2 : 0.1),\n        border: `dashed ${theme.palette.info.main} 2px`,\n        boxSizing: 'border-box',\n        display: 'flex',\n        height: '100%',\n        justifyContent: 'center',\n        position: 'absolute',\n        width: '100%',\n        zIndex: 4\n      }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)),\n      children: jsx(Typography, {\n        fontStyle: \"italic\",\n        children: localization.dropToGroupBy.replace('{column}', (_c = (_b = draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.columnDef) === null || _b === void 0 ? void 0 : _b.header) !== null && _c !== void 0 ? _c : '')\n      })\n    }))\n  });\n};\nconst MRT_BottomToolbar = _a => {\n  var {\n      table\n    } = _a,\n    rest = __rest(_a, [\"table\"]);\n  const {\n    getState,\n    options: {\n      enablePagination,\n      muiBottomToolbarProps,\n      positionPagination,\n      positionToolbarAlertBanner,\n      positionToolbarDropZone,\n      renderBottomToolbarCustomActions\n    },\n    refs: {\n      bottomToolbarRef\n    }\n  } = table;\n  const {\n    isFullScreen\n  } = getState();\n  const isMobile = useMediaQuery('(max-width:720px)');\n  const toolbarProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiBottomToolbarProps, {\n    table\n  })), rest);\n  const stackAlertBanner = isMobile || !!renderBottomToolbarCustomActions;\n  return jsxs(Box, Object.assign({}, toolbarProps, {\n    ref: node => {\n      if (node) {\n        bottomToolbarRef.current = node;\n        if (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.ref) {\n          // @ts-ignore\n          toolbarProps.ref.current = node;\n        }\n      }\n    },\n    sx: theme => Object.assign(Object.assign(Object.assign({}, getCommonToolbarStyles({\n      table,\n      theme\n    })), {\n      bottom: isFullScreen ? '0' : undefined,\n      boxShadow: `0 1px 2px -1px ${alpha(theme.palette.grey[700], 0.5)} inset`,\n      left: 0,\n      position: isFullScreen ? 'fixed' : 'relative',\n      right: 0\n    }), parseFromValuesOrFunc(toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx, theme)),\n    children: [jsx(MRT_LinearProgressBar, {\n      isTopToolbar: false,\n      table: table\n    }), positionToolbarAlertBanner === 'bottom' && jsx(MRT_ToolbarAlertBanner, {\n      stackAlertBanner: stackAlertBanner,\n      table: table\n    }), ['both', 'bottom'].includes(positionToolbarDropZone !== null && positionToolbarDropZone !== void 0 ? positionToolbarDropZone : '') && jsx(MRT_ToolbarDropZone, {\n      table: table\n    }), jsxs(Box, {\n      sx: {\n        alignItems: 'center',\n        boxSizing: 'border-box',\n        display: 'flex',\n        justifyContent: 'space-between',\n        p: '0.5rem',\n        width: '100%'\n      },\n      children: [renderBottomToolbarCustomActions ? renderBottomToolbarCustomActions({\n        table\n      }) : jsx(\"span\", {}), jsx(Box, {\n        sx: {\n          display: 'flex',\n          justifyContent: 'flex-end',\n          position: stackAlertBanner ? 'relative' : 'absolute',\n          right: 0,\n          top: 0\n        },\n        children: enablePagination && ['both', 'bottom'].includes(positionPagination !== null && positionPagination !== void 0 ? positionPagination : '') && jsx(MRT_TablePagination, {\n          position: \"bottom\",\n          table: table\n        })\n      })]\n    })]\n  }));\n};\nconst MRT_ColumnPinningButtons = _a => {\n  var {\n      column,\n      table\n    } = _a,\n    rest = __rest(_a, [\"column\", \"table\"]);\n  const {\n    options: {\n      icons: {\n        PushPinIcon\n      },\n      localization\n    }\n  } = table;\n  const handlePinColumn = pinDirection => {\n    column.pin(pinDirection);\n  };\n  return jsx(Box, Object.assign({}, rest, {\n    sx: theme => Object.assign({\n      minWidth: '70px',\n      textAlign: 'center'\n    }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)),\n    children: column.getIsPinned() ? jsx(Tooltip, {\n      title: localization.unpin,\n      children: jsx(IconButton, {\n        onClick: () => handlePinColumn(false),\n        size: \"small\",\n        children: jsx(PushPinIcon, {})\n      })\n    }) : jsxs(Fragment, {\n      children: [jsx(Tooltip, {\n        title: localization.pinToLeft,\n        children: jsx(IconButton, {\n          onClick: () => handlePinColumn('left'),\n          size: \"small\",\n          children: jsx(PushPinIcon, {\n            style: {\n              transform: 'rotate(90deg)'\n            }\n          })\n        })\n      }), jsx(Tooltip, {\n        title: localization.pinToRight,\n        children: jsx(IconButton, {\n          onClick: () => handlePinColumn('right'),\n          size: \"small\",\n          children: jsx(PushPinIcon, {\n            style: {\n              transform: 'rotate(-90deg)'\n            }\n          })\n        })\n      })]\n    })\n  }));\n};\nconst MRT_ShowHideColumnsMenuItems = _a => {\n  var _b;\n  var {\n      allColumns,\n      column,\n      hoveredColumn,\n      isNestedColumns,\n      setHoveredColumn,\n      table\n    } = _a,\n    rest = __rest(_a, [\"allColumns\", \"column\", \"hoveredColumn\", \"isNestedColumns\", \"setHoveredColumn\", \"table\"]);\n  const {\n    getState,\n    options: {\n      enableColumnOrdering,\n      enableColumnPinning,\n      enableHiding,\n      localization,\n      mrtTheme: {\n        draggingBorderColor\n      }\n    },\n    setColumnOrder\n  } = table;\n  const {\n    columnOrder\n  } = getState();\n  const {\n    columnDef\n  } = column;\n  const {\n    columnDefType\n  } = columnDef;\n  const switchChecked = column.getIsVisible();\n  const handleToggleColumnHidden = column => {\n    var _a, _b;\n    if (columnDefType === 'group') {\n      (_b = (_a = column === null || column === void 0 ? void 0 : column.columns) === null || _a === void 0 ? void 0 : _a.forEach) === null || _b === void 0 ? void 0 : _b.call(_a, childColumn => {\n        childColumn.toggleVisibility(!switchChecked);\n      });\n    } else {\n      column.toggleVisibility();\n    }\n  };\n  const menuItemRef = useRef(null);\n  const [isDragging, setIsDragging] = useState(false);\n  const handleDragStart = e => {\n    setIsDragging(true);\n    try {\n      e.dataTransfer.setDragImage(menuItemRef.current, 0, 0);\n    } catch (e) {\n      console.error(e);\n    }\n  };\n  const handleDragEnd = _e => {\n    setIsDragging(false);\n    setHoveredColumn(null);\n    if (hoveredColumn) {\n      setColumnOrder(reorderColumn(column, hoveredColumn, columnOrder));\n    }\n  };\n  const handleDragEnter = _e => {\n    if (!isDragging && columnDef.enableColumnOrdering !== false) {\n      setHoveredColumn(column);\n    }\n  };\n  if (!columnDef.header || columnDef.visibleInShowHideMenu === false) {\n    return null;\n  }\n  return jsxs(Fragment, {\n    children: [jsx(MenuItem, Object.assign({\n      disableRipple: true,\n      onDragEnter: handleDragEnter,\n      ref: menuItemRef\n    }, rest, {\n      sx: theme => Object.assign({\n        alignItems: 'center',\n        justifyContent: 'flex-start',\n        my: 0,\n        opacity: isDragging ? 0.5 : 1,\n        outline: isDragging ? `2px dashed ${theme.palette.grey[500]}` : (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id ? `2px dashed ${draggingBorderColor}` : 'none',\n        outlineOffset: '-2px',\n        pl: `${(column.depth + 0.5) * 2}rem`,\n        py: '6px'\n      }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)),\n      children: jsxs(Box, {\n        sx: {\n          display: 'flex',\n          flexWrap: 'nowrap',\n          gap: '8px'\n        },\n        children: [columnDefType !== 'group' && enableColumnOrdering && !isNestedColumns && (columnDef.enableColumnOrdering !== false ? jsx(MRT_GrabHandleButton, {\n          onDragEnd: handleDragEnd,\n          onDragStart: handleDragStart,\n          table: table\n        }) : jsx(Box, {\n          sx: {\n            width: '28px'\n          }\n        })), enableColumnPinning && (column.getCanPin() ? jsx(MRT_ColumnPinningButtons, {\n          column: column,\n          table: table\n        }) : jsx(Box, {\n          sx: {\n            width: '70px'\n          }\n        })), enableHiding ? jsx(FormControlLabel, {\n          checked: switchChecked,\n          componentsProps: {\n            typography: {\n              sx: {\n                mb: 0,\n                opacity: columnDefType !== 'display' ? 1 : 0.5\n              }\n            }\n          },\n          control: jsx(Tooltip, Object.assign({}, getCommonTooltipProps(), {\n            title: localization.toggleVisibility,\n            children: jsx(Switch, {})\n          })),\n          disabled: !column.getCanHide(),\n          label: columnDef.header,\n          onChange: () => handleToggleColumnHidden(column)\n        }) : jsx(Typography, {\n          sx: {\n            alignSelf: 'center'\n          },\n          children: columnDef.header\n        })]\n      })\n    })), (_b = column.columns) === null || _b === void 0 ? void 0 : _b.map((c, i) => jsx(MRT_ShowHideColumnsMenuItems, {\n      allColumns: allColumns,\n      column: c,\n      hoveredColumn: hoveredColumn,\n      isNestedColumns: isNestedColumns,\n      setHoveredColumn: setHoveredColumn,\n      table: table\n    }, `${i}-${c.id}`))]\n  });\n};\nconst MRT_ShowHideColumnsMenu = _a => {\n  var {\n      anchorEl,\n      setAnchorEl,\n      table\n    } = _a,\n    rest = __rest(_a, [\"anchorEl\", \"setAnchorEl\", \"table\"]);\n  const {\n    getAllColumns,\n    getAllLeafColumns,\n    getCenterLeafColumns,\n    getIsAllColumnsVisible,\n    getIsSomeColumnsPinned,\n    getIsSomeColumnsVisible,\n    getLeftLeafColumns,\n    getRightLeafColumns,\n    getState,\n    options: {\n      enableColumnOrdering,\n      enableColumnPinning,\n      enableHiding,\n      localization,\n      mrtTheme: {\n        menuBackgroundColor\n      }\n    }\n  } = table;\n  const {\n    columnOrder,\n    columnPinning,\n    density\n  } = getState();\n  const handleToggleAllColumns = value => {\n    getAllLeafColumns().filter(col => col.columnDef.enableHiding !== false).forEach(col => col.toggleVisibility(value));\n  };\n  const allColumns = useMemo(() => {\n    const columns = getAllColumns();\n    if (columnOrder.length > 0 && !columns.some(col => col.columnDef.columnDefType === 'group')) {\n      return [...getLeftLeafColumns(), ...Array.from(new Set(columnOrder)).map(colId => getCenterLeafColumns().find(col => (col === null || col === void 0 ? void 0 : col.id) === colId)), ...getRightLeafColumns()].filter(Boolean);\n    }\n    return columns;\n  }, [columnOrder, columnPinning, getAllColumns(), getCenterLeafColumns(), getLeftLeafColumns(), getRightLeafColumns()]);\n  const isNestedColumns = allColumns.some(col => col.columnDef.columnDefType === 'group');\n  const [hoveredColumn, setHoveredColumn] = useState(null);\n  return jsxs(Menu, Object.assign({\n    MenuListProps: {\n      dense: density === 'compact',\n      sx: {\n        backgroundColor: menuBackgroundColor\n      }\n    },\n    anchorEl: anchorEl,\n    disableScrollLock: true,\n    onClose: () => setAnchorEl(null),\n    open: !!anchorEl\n  }, rest, {\n    children: [jsxs(Box, {\n      sx: {\n        display: 'flex',\n        justifyContent: 'space-between',\n        p: '0.5rem',\n        pt: 0\n      },\n      children: [enableHiding && jsx(Button, {\n        disabled: !getIsSomeColumnsVisible(),\n        onClick: () => handleToggleAllColumns(false),\n        children: localization.hideAll\n      }), enableColumnOrdering && jsx(Button, {\n        onClick: () => table.setColumnOrder(getDefaultColumnOrderIds(table.options, true)),\n        children: localization.resetOrder\n      }), enableColumnPinning && jsx(Button, {\n        disabled: !getIsSomeColumnsPinned(),\n        onClick: () => table.resetColumnPinning(true),\n        children: localization.unpinAll\n      }), enableHiding && jsx(Button, {\n        disabled: getIsAllColumnsVisible(),\n        onClick: () => handleToggleAllColumns(true),\n        children: localization.showAll\n      })]\n    }), jsx(Divider, {}), allColumns.map((column, index) => jsx(MRT_ShowHideColumnsMenuItems, {\n      allColumns: allColumns,\n      column: column,\n      hoveredColumn: hoveredColumn,\n      isNestedColumns: isNestedColumns,\n      setHoveredColumn: setHoveredColumn,\n      table: table\n    }, `${index}-${column.id}`))]\n  }));\n};\nconst MRT_ShowHideColumnsButton = _a => {\n  var _b;\n  var {\n      table\n    } = _a,\n    rest = __rest(_a, [\"table\"]);\n  const {\n    options: {\n      icons: {\n        ViewColumnIcon\n      },\n      localization\n    }\n  } = table;\n  const [anchorEl, setAnchorEl] = useState(null);\n  const handleClick = event => {\n    setAnchorEl(event.currentTarget);\n  };\n  return jsxs(Fragment, {\n    children: [jsx(Tooltip, {\n      title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideColumns,\n      children: jsx(IconButton, Object.assign({\n        \"aria-label\": localization.showHideColumns,\n        onClick: handleClick\n      }, rest, {\n        title: undefined,\n        children: jsx(ViewColumnIcon, {})\n      }))\n    }), anchorEl && jsx(MRT_ShowHideColumnsMenu, {\n      anchorEl: anchorEl,\n      setAnchorEl: setAnchorEl,\n      table: table\n    })]\n  });\n};\nconst MRT_ToggleDensePaddingButton = _a => {\n  var _b;\n  var {\n      table\n    } = _a,\n    rest = __rest(_a, [\"table\"]);\n  const {\n    getState,\n    options: {\n      icons: {\n        DensityLargeIcon,\n        DensityMediumIcon,\n        DensitySmallIcon\n      },\n      localization\n    },\n    setDensity\n  } = table;\n  const {\n    density\n  } = getState();\n  const handleToggleDensePadding = () => {\n    const nextDensity = density === 'comfortable' ? 'compact' : density === 'compact' ? 'spacious' : 'comfortable';\n    setDensity(nextDensity);\n  };\n  return jsx(Tooltip, {\n    title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.toggleDensity,\n    children: jsx(IconButton, Object.assign({\n      \"aria-label\": localization.toggleDensity,\n      onClick: handleToggleDensePadding\n    }, rest, {\n      title: undefined,\n      children: density === 'compact' ? jsx(DensitySmallIcon, {}) : density === 'comfortable' ? jsx(DensityMediumIcon, {}) : jsx(DensityLargeIcon, {})\n    }))\n  });\n};\nconst MRT_ToggleFiltersButton = _a => {\n  var _b;\n  var {\n      table\n    } = _a,\n    rest = __rest(_a, [\"table\"]);\n  const {\n    getState,\n    options: {\n      icons: {\n        FilterListIcon,\n        FilterListOffIcon\n      },\n      localization\n    },\n    setShowColumnFilters\n  } = table;\n  const {\n    showColumnFilters\n  } = getState();\n  const handleToggleShowFilters = () => {\n    setShowColumnFilters(!showColumnFilters);\n  };\n  return jsx(Tooltip, {\n    title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideFilters,\n    children: jsx(IconButton, Object.assign({\n      \"aria-label\": localization.showHideFilters,\n      onClick: handleToggleShowFilters\n    }, rest, {\n      title: undefined,\n      children: showColumnFilters ? jsx(FilterListOffIcon, {}) : jsx(FilterListIcon, {})\n    }))\n  });\n};\nconst MRT_ToggleFullScreenButton = _a => {\n  var _b;\n  var {\n      table\n    } = _a,\n    rest = __rest(_a, [\"table\"]);\n  const {\n    getState,\n    options: {\n      icons: {\n        FullscreenExitIcon,\n        FullscreenIcon\n      },\n      localization\n    },\n    setIsFullScreen\n  } = table;\n  const {\n    isFullScreen\n  } = getState();\n  const [tooltipOpened, setTooltipOpened] = useState(false);\n  const handleToggleFullScreen = () => {\n    setTooltipOpened(false);\n    setIsFullScreen(!isFullScreen);\n  };\n  return jsx(Tooltip, {\n    open: tooltipOpened,\n    title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.toggleFullScreen,\n    children: jsx(IconButton, Object.assign({\n      \"aria-label\": localization.toggleFullScreen,\n      onClick: handleToggleFullScreen,\n      onMouseEnter: () => setTooltipOpened(true),\n      onMouseLeave: () => setTooltipOpened(false)\n    }, rest, {\n      title: undefined,\n      children: isFullScreen ? jsx(FullscreenExitIcon, {}) : jsx(FullscreenIcon, {})\n    }))\n  });\n};\nconst MRT_ToggleGlobalFilterButton = _a => {\n  var _b, _c;\n  var {\n      table\n    } = _a,\n    rest = __rest(_a, [\"table\"]);\n  const {\n    getState,\n    options: {\n      icons: {\n        SearchIcon,\n        SearchOffIcon\n      },\n      localization\n    },\n    refs: {\n      searchInputRef\n    },\n    setShowGlobalFilter\n  } = table;\n  const {\n    globalFilter,\n    showGlobalFilter\n  } = getState();\n  const handleToggleSearch = () => {\n    setShowGlobalFilter(!showGlobalFilter);\n    queueMicrotask(() => {\n      var _a;\n      return (_a = searchInputRef.current) === null || _a === void 0 ? void 0 : _a.focus();\n    });\n  };\n  return jsx(Tooltip, {\n    title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideSearch,\n    children: jsx(IconButton, Object.assign({\n      \"aria-label\": (_c = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _c !== void 0 ? _c : localization.showHideSearch,\n      disabled: !!globalFilter,\n      onClick: handleToggleSearch\n    }, rest, {\n      title: undefined,\n      children: showGlobalFilter ? jsx(SearchOffIcon, {}) : jsx(SearchIcon, {})\n    }))\n  });\n};\nconst MRT_ToolbarInternalButtons = _a => {\n  var _b;\n  var {\n      table\n    } = _a,\n    rest = __rest(_a, [\"table\"]);\n  const {\n    options: {\n      columnFilterDisplayMode,\n      enableColumnFilters,\n      enableColumnOrdering,\n      enableColumnPinning,\n      enableDensityToggle,\n      enableFilters,\n      enableFullScreenToggle,\n      enableGlobalFilter,\n      enableHiding,\n      initialState,\n      renderToolbarInternalActions\n    }\n  } = table;\n  return jsx(Box, Object.assign({}, rest, {\n    sx: theme => Object.assign({\n      alignItems: 'center',\n      display: 'flex',\n      zIndex: 3\n    }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)),\n    children: (_b = renderToolbarInternalActions === null || renderToolbarInternalActions === void 0 ? void 0 : renderToolbarInternalActions({\n      table\n    })) !== null && _b !== void 0 ? _b : jsxs(Fragment, {\n      children: [enableFilters && enableGlobalFilter && !(initialState === null || initialState === void 0 ? void 0 : initialState.showGlobalFilter) && jsx(MRT_ToggleGlobalFilterButton, {\n        table: table\n      }), enableFilters && enableColumnFilters && columnFilterDisplayMode !== 'popover' && jsx(MRT_ToggleFiltersButton, {\n        table: table\n      }), (enableHiding || enableColumnOrdering || enableColumnPinning) && jsx(MRT_ShowHideColumnsButton, {\n        table: table\n      }), enableDensityToggle && jsx(MRT_ToggleDensePaddingButton, {\n        table: table\n      }), enableFullScreenToggle && jsx(MRT_ToggleFullScreenButton, {\n        table: table\n      })]\n    })\n  }));\n};\nconst MRT_GlobalFilterTextField = _a => {\n  var _b;\n  var {\n      table\n    } = _a,\n    rest = __rest(_a, [\"table\"]);\n  const {\n    getState,\n    options: {\n      enableGlobalFilterModes,\n      icons: {\n        CloseIcon,\n        SearchIcon\n      },\n      localization,\n      manualFiltering,\n      muiSearchTextFieldProps\n    },\n    refs: {\n      searchInputRef\n    },\n    setGlobalFilter\n  } = table;\n  const {\n    globalFilter,\n    showGlobalFilter\n  } = getState();\n  const textFieldProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiSearchTextFieldProps, {\n    table\n  })), rest);\n  const isMounted = useRef(false);\n  const [anchorEl, setAnchorEl] = useState(null);\n  const [searchValue, setSearchValue] = useState(globalFilter !== null && globalFilter !== void 0 ? globalFilter : '');\n  const handleChangeDebounced = useCallback(debounce(event => {\n    var _a;\n    setGlobalFilter((_a = event.target.value) !== null && _a !== void 0 ? _a : undefined);\n  }, manualFiltering ? 500 : 250), []);\n  const handleChange = event => {\n    setSearchValue(event.target.value);\n    handleChangeDebounced(event);\n  };\n  const handleGlobalFilterMenuOpen = event => {\n    setAnchorEl(event.currentTarget);\n  };\n  const handleClear = () => {\n    setSearchValue('');\n    setGlobalFilter(undefined);\n  };\n  useEffect(() => {\n    if (isMounted.current) {\n      if (globalFilter === undefined) {\n        handleClear();\n      } else {\n        setSearchValue(globalFilter);\n      }\n    }\n    isMounted.current = true;\n  }, [globalFilter]);\n  return jsxs(Collapse, {\n    in: showGlobalFilter,\n    mountOnEnter: true,\n    orientation: \"horizontal\",\n    unmountOnExit: true,\n    children: [jsx(TextField, Object.assign({\n      inputProps: Object.assign({\n        autoComplete: 'new-password'\n      }, textFieldProps.inputProps),\n      onChange: handleChange,\n      placeholder: localization.search,\n      size: \"small\",\n      value: searchValue !== null && searchValue !== void 0 ? searchValue : '',\n      variant: \"outlined\"\n    }, textFieldProps, {\n      InputProps: Object.assign(Object.assign({\n        endAdornment: jsx(InputAdornment, {\n          position: \"end\",\n          children: jsx(Tooltip, {\n            title: (_b = localization.clearSearch) !== null && _b !== void 0 ? _b : '',\n            children: jsx(\"span\", {\n              children: jsx(IconButton, {\n                \"aria-label\": localization.clearSearch,\n                disabled: !(searchValue === null || searchValue === void 0 ? void 0 : searchValue.length),\n                onClick: handleClear,\n                size: \"small\",\n                children: jsx(CloseIcon, {})\n              })\n            })\n          })\n        }),\n        startAdornment: enableGlobalFilterModes ? jsx(InputAdornment, {\n          position: \"start\",\n          children: jsx(Tooltip, {\n            title: localization.changeSearchMode,\n            children: jsx(IconButton, {\n              \"aria-label\": localization.changeSearchMode,\n              onClick: handleGlobalFilterMenuOpen,\n              size: \"small\",\n              sx: {\n                height: '1.75rem',\n                width: '1.75rem'\n              },\n              children: jsx(SearchIcon, {})\n            })\n          })\n        }) : jsx(SearchIcon, {\n          style: {\n            marginRight: '4px'\n          }\n        })\n      }, textFieldProps.InputProps), {\n        sx: theme => {\n          var _a;\n          return Object.assign({\n            mb: 0\n          }, parseFromValuesOrFunc((_a = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.InputProps) === null || _a === void 0 ? void 0 : _a.sx, theme));\n        }\n      }),\n      inputRef: inputRef => {\n        searchInputRef.current = inputRef;\n        if (textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.inputRef) {\n          textFieldProps.inputRef = inputRef;\n        }\n      }\n    })), jsx(MRT_FilterOptionMenu, {\n      anchorEl: anchorEl,\n      onSelect: handleClear,\n      setAnchorEl: setAnchorEl,\n      table: table\n    })]\n  });\n};\nconst MRT_TopToolbar = ({\n  table\n}) => {\n  var _a;\n  const {\n    getState,\n    options: {\n      enableGlobalFilter,\n      enablePagination,\n      enableToolbarInternalActions,\n      muiTopToolbarProps,\n      positionGlobalFilter,\n      positionPagination,\n      positionToolbarAlertBanner,\n      positionToolbarDropZone,\n      renderTopToolbarCustomActions\n    },\n    refs: {\n      topToolbarRef\n    }\n  } = table;\n  const {\n    isFullScreen,\n    showGlobalFilter\n  } = getState();\n  const isMobile = useMediaQuery('(max-width:720px)');\n  const isTablet = useMediaQuery('(max-width:1024px)');\n  const toolbarProps = parseFromValuesOrFunc(muiTopToolbarProps, {\n    table\n  });\n  const stackAlertBanner = isMobile || !!renderTopToolbarCustomActions || showGlobalFilter && isTablet;\n  const globalFilterProps = {\n    sx: !isTablet ? {\n      zIndex: 2\n    } : undefined,\n    table\n  };\n  return jsxs(Box, Object.assign({}, toolbarProps, {\n    ref: ref => {\n      topToolbarRef.current = ref;\n      if (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.ref) {\n        // @ts-ignore\n        toolbarProps.ref.current = ref;\n      }\n    },\n    sx: theme => Object.assign(Object.assign(Object.assign({}, getCommonToolbarStyles({\n      table,\n      theme\n    })), {\n      position: isFullScreen ? 'sticky' : 'relative',\n      top: isFullScreen ? '0' : undefined\n    }), parseFromValuesOrFunc(toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx, theme)),\n    children: [positionToolbarAlertBanner === 'top' && jsx(MRT_ToolbarAlertBanner, {\n      stackAlertBanner: stackAlertBanner,\n      table: table\n    }), ['both', 'top'].includes(positionToolbarDropZone !== null && positionToolbarDropZone !== void 0 ? positionToolbarDropZone : '') && jsx(MRT_ToolbarDropZone, {\n      table: table\n    }), jsxs(Box, {\n      sx: {\n        alignItems: 'flex-start',\n        boxSizing: 'border-box',\n        display: 'flex',\n        gap: '0.5rem',\n        justifyContent: 'space-between',\n        p: '0.5rem',\n        position: stackAlertBanner ? 'relative' : 'absolute',\n        right: 0,\n        top: 0,\n        width: '100%'\n      },\n      children: [enableGlobalFilter && positionGlobalFilter === 'left' && jsx(MRT_GlobalFilterTextField, Object.assign({}, globalFilterProps)), (_a = renderTopToolbarCustomActions === null || renderTopToolbarCustomActions === void 0 ? void 0 : renderTopToolbarCustomActions({\n        table\n      })) !== null && _a !== void 0 ? _a : jsx(\"span\", {}), enableToolbarInternalActions ? jsxs(Box, {\n        sx: {\n          alignItems: 'center',\n          display: 'flex',\n          flexWrap: 'wrap-reverse',\n          gap: '0.5rem',\n          justifyContent: 'flex-end'\n        },\n        children: [enableGlobalFilter && positionGlobalFilter === 'right' && jsx(MRT_GlobalFilterTextField, Object.assign({}, globalFilterProps)), jsx(MRT_ToolbarInternalButtons, {\n          table: table\n        })]\n      }) : enableGlobalFilter && positionGlobalFilter === 'right' && jsx(MRT_GlobalFilterTextField, Object.assign({}, globalFilterProps))]\n    }), enablePagination && ['both', 'top'].includes(positionPagination !== null && positionPagination !== void 0 ? positionPagination : '') && jsx(MRT_TablePagination, {\n      position: \"top\",\n      table: table\n    }), jsx(MRT_LinearProgressBar, {\n      isTopToolbar: true,\n      table: table\n    })]\n  }));\n};\nconst MRT_TablePaper = _a => {\n  var _b, _c;\n  var {\n      table\n    } = _a,\n    rest = __rest(_a, [\"table\"]);\n  const {\n    getState,\n    options: {\n      enableBottomToolbar,\n      enableTopToolbar,\n      mrtTheme: {\n        baseBackgroundColor\n      },\n      muiTablePaperProps,\n      renderBottomToolbar,\n      renderTopToolbar\n    },\n    refs: {\n      tablePaperRef\n    }\n  } = table;\n  const {\n    isFullScreen\n  } = getState();\n  const paperProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTablePaperProps, {\n    table\n  })), rest);\n  const theme = useTheme$1();\n  return jsxs(Paper, Object.assign({\n    elevation: 2\n  }, paperProps, {\n    ref: ref => {\n      tablePaperRef.current = ref;\n      if (paperProps === null || paperProps === void 0 ? void 0 : paperProps.ref) {\n        //@ts-ignore\n        paperProps.ref.current = ref;\n      }\n    },\n    style: Object.assign(Object.assign({}, isFullScreen ? {\n      bottom: 0,\n      height: '100dvh',\n      left: 0,\n      margin: 0,\n      maxHeight: '100dvh',\n      maxWidth: '100dvw',\n      padding: 0,\n      position: 'fixed',\n      right: 0,\n      top: 0,\n      width: '100dvw',\n      zIndex: theme.zIndex.modal\n    } : {}), paperProps === null || paperProps === void 0 ? void 0 : paperProps.style),\n    sx: theme => Object.assign({\n      backgroundColor: baseBackgroundColor,\n      backgroundImage: 'unset',\n      overflow: 'hidden',\n      transition: 'all 100ms ease-in-out'\n    }, parseFromValuesOrFunc(paperProps === null || paperProps === void 0 ? void 0 : paperProps.sx, theme)),\n    children: [enableTopToolbar && ((_b = parseFromValuesOrFunc(renderTopToolbar, {\n      table\n    })) !== null && _b !== void 0 ? _b : jsx(MRT_TopToolbar, {\n      table: table\n    })), jsx(MRT_TableContainer, {\n      table: table\n    }), enableBottomToolbar && ((_c = parseFromValuesOrFunc(renderBottomToolbar, {\n      table\n    })) !== null && _c !== void 0 ? _c : jsx(MRT_BottomToolbar, {\n      table: table\n    }))]\n  }));\n};\nconst isTableInstanceProp = props => props.table !== undefined;\nconst MaterialReactTable = props => {\n  let table;\n  if (isTableInstanceProp(props)) {\n    table = props.table;\n  } else {\n    table = useMaterialReactTable(props);\n  }\n  return jsx(MRT_TablePaper, {\n    table: table\n  });\n};\nexport { MRT_ActionMenuItem, MRT_AggregationFns, MRT_BottomToolbar, MRT_ColumnActionMenu, MRT_ColumnPinningButtons, MRT_CopyButton, MRT_DefaultColumn, MRT_DefaultDisplayColumn, MRT_EditActionButtons, MRT_EditCellTextField, MRT_EditRowModal, MRT_ExpandAllButton, MRT_ExpandButton, MRT_FilterCheckbox, MRT_FilterFns, MRT_FilterOptionMenu, MRT_FilterRangeFields, MRT_FilterRangeSlider, MRT_FilterTextField, MRT_GlobalFilterTextField, MRT_GrabHandleButton, MRT_LinearProgressBar, MRT_RowActionMenu, MRT_RowPinButton, MRT_SelectCheckbox, MRT_ShowHideColumnsButton, MRT_ShowHideColumnsMenu, MRT_ShowHideColumnsMenuItems, MRT_SortingFns, MRT_Table, MRT_TableBody, MRT_TableBodyCell, MRT_TableBodyCellValue, MRT_TableBodyRow, MRT_TableBodyRowGrabHandle, MRT_TableBodyRowPinButton, MRT_TableContainer, MRT_TableDetailPanel, MRT_TableFooter, MRT_TableFooterCell, MRT_TableFooterRow, MRT_TableHead, MRT_TableHeadCell, MRT_TableHeadCellColumnActionsButton, MRT_TableHeadCellFilterContainer, MRT_TableHeadCellFilterLabel, MRT_TableHeadCellGrabHandle, MRT_TableHeadCellResizeHandle, MRT_TableHeadCellSortLabel, MRT_TableHeadRow, MRT_TableLoadingOverlay, MRT_TablePagination, MRT_TablePaper, MRT_ToggleDensePaddingButton, MRT_ToggleFiltersButton, MRT_ToggleFullScreenButton, MRT_ToggleGlobalFilterButton, MRT_ToggleRowActionMenuButton, MRT_ToolbarAlertBanner, MRT_ToolbarDropZone, MRT_ToolbarInternalButtons, MRT_TopToolbar, MaterialReactTable, Memo_MRT_TableBody, Memo_MRT_TableBodyCell, Memo_MRT_TableBodyRow, createMRTColumnHelper, createRow, defaultDisplayColumnProps, flexRender, getAllLeafColumnDefs, getCanRankRows, getColumnFilterInfo, getColumnId, getDefaultColumnFilterFn, getDefaultColumnOrderIds, getIsRankingRows, getIsRowSelected, getLeadingDisplayColumnIds, getMRT_RowSelectionHandler, getMRT_Rows, getMRT_SelectAllHandler, getTrailingDisplayColumnIds, isCellEditable, mrtFilterOptions, openEditingCell, prepareColumns, rankGlobalFuzzy, reorderColumn, showRowActionsColumn, showRowDragColumn, showRowExpandColumn, showRowNumbersColumn, showRowPinningColumn, showRowSelectionColumn, showRowSpacerColumn, useDropdownOptions, useMRT_ColumnVirtualizer, useMRT_Effects, useMRT_RowVirtualizer, useMRT_Rows, useMRT_TableInstance, useMRT_TableOptions, useMaterialReactTable };\n//# sourceMappingURL=index.esm.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}