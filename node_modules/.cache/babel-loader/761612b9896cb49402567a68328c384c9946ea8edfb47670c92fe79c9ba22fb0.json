{"ast":null,"code":"let IDX = 36;\nlet HEX = \"\";\nwhile (IDX--) {\n  HEX += IDX.toString(36);\n}\nfunction uid(len = 11) {\n  let str = \"\";\n  let num = len;\n  while (num--) {\n    str += HEX[Math.random() * 36 | 0];\n  }\n  return str;\n}\nconst escapeRegexp = term => term.replace(/[|\\\\{}()[\\]^$+*?.-]/g, char => `\\\\${char}`);\nconst termsToRegExpString = terms => terms.replace(/\\s{2,}/g, \" \").split(\" \").join(\"|\");\nconst regexpQuery = ({\n  terms,\n  matchExactly = false\n}) => {\n  if (typeof terms !== \"string\") {\n    throw new TypeError(\"Expected a string\");\n  }\n  const escapedTerms = escapeRegexp(terms.trim());\n  return `(${matchExactly ? escapedTerms : termsToRegExpString(escapedTerms)})`;\n};\nconst buildRegexp = ({\n  terms,\n  matchExactly = false\n}) => {\n  try {\n    const fromString = /^([/~@;%#'])(.*?)\\1([gimsuy]*)$/.exec(terms);\n    if (fromString) {\n      return new RegExp(fromString[2], fromString[3]);\n    }\n    return new RegExp(regexpQuery({\n      terms,\n      matchExactly\n    }), \"ig\");\n  } catch (e) {\n    throw new TypeError(\"Expected terms to be either a string or a RegExp!\");\n  }\n};\nconst hasProp = prop => obj => obj !== null && typeof obj === \"object\" && prop in obj;\nconst hasMatch = hasProp(\"match\");\nconst chunkExists = chunk => typeof chunk !== \"undefined\";\nfunction clip({\n  curr,\n  next,\n  prev,\n  clipBy = 3\n}) {\n  const words = curr.text.split(\" \");\n  const len = words.length;\n  if (curr.match || clipBy >= len) {\n    return curr.text;\n  }\n  const ellipsis = \"...\";\n  if (chunkExists(next) && chunkExists(prev) && hasMatch(prev) && hasMatch(next)) {\n    if (len > clipBy * 2) {\n      return [...words.slice(0, clipBy), ellipsis, ...words.slice(-clipBy)].join(\" \");\n    }\n    return curr.text;\n  }\n  if (chunkExists(next) && hasMatch(next)) {\n    return [ellipsis, ...words.slice(-clipBy)].join(\" \");\n  }\n  if (chunkExists(prev) && hasMatch(prev)) {\n    return [...words.slice(0, clipBy), ellipsis].join(\" \");\n  }\n  return curr.text;\n}\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst hasLength = str => str.length > 0;\nconst highlightWords = ({\n  text,\n  query,\n  clipBy,\n  matchExactly = false\n}) => {\n  const safeQuery = typeof query === \"string\" ? query.trim() : query;\n  if (safeQuery === \"\") {\n    return [{\n      key: uid(),\n      text,\n      match: false\n    }];\n  }\n  const searchRegexp = buildRegexp({\n    terms: query,\n    matchExactly\n  });\n  return text.split(searchRegexp).filter(hasLength).map(str => ({\n    // Compose the object for a match\n    key: uid(),\n    text: str,\n    match: matchExactly ? str.toLowerCase() === safeQuery.toLowerCase() : searchRegexp.test(str)\n  })).map((chunk, index, chunks) => __spreadValues(__spreadValues({}, chunk), typeof clipBy === \"number\" && {\n    // We only overwrite the text if there is a clip\n    text: clip(__spreadProps(__spreadValues(__spreadValues({\n      curr: chunk\n    }, index < chunks.length - 1 && {\n      next: chunks[index + 1]\n    }), index > 0 && {\n      prev: chunks[index - 1]\n    }), {\n      // If this wasn't the first chunk, set the previous chunk\n      clipBy\n    }))\n  }));\n};\nexport { highlightWords as default };","map":{"version":3,"names":["IDX","HEX","toString","uid","len","str","num","Math","random","escapeRegexp","term","replace","char","termsToRegExpString","terms","split","join","regexpQuery","matchExactly","TypeError","escapedTerms","trim","buildRegexp","fromString","exec","RegExp","e","hasProp","prop","obj","hasMatch","chunkExists","chunk","clip","curr","next","prev","clipBy","words","text","length","match","ellipsis","slice","__defProp","Object","defineProperty","__defProps","defineProperties","__getOwnPropDescs","getOwnPropertyDescriptors","__getOwnPropSymbols","getOwnPropertySymbols","__hasOwnProp","prototype","hasOwnProperty","__propIsEnum","propertyIsEnumerable","__defNormalProp","key","value","enumerable","configurable","writable","__spreadValues","a","b","call","__spreadProps","hasLength","highlightWords","query","safeQuery","searchRegexp","filter","map","toLowerCase","test","index","chunks","default"],"sources":["/Users/khangdo/Documents/Best Fit College/react code/best_fit_colleges/node_modules/highlight-words/dist/highlight-words.mjs"],"sourcesContent":["let IDX = 36;\nlet HEX = \"\";\nwhile (IDX--) {\n  HEX += IDX.toString(36);\n}\nfunction uid(len = 11) {\n  let str = \"\";\n  let num = len;\n  while (num--) {\n    str += HEX[Math.random() * 36 | 0];\n  }\n  return str;\n}\n\nconst escapeRegexp = (term) => term.replace(/[|\\\\{}()[\\]^$+*?.-]/g, (char) => `\\\\${char}`);\nconst termsToRegExpString = (terms) => terms.replace(/\\s{2,}/g, \" \").split(\" \").join(\"|\");\nconst regexpQuery = ({\n  terms,\n  matchExactly = false\n}) => {\n  if (typeof terms !== \"string\") {\n    throw new TypeError(\"Expected a string\");\n  }\n  const escapedTerms = escapeRegexp(terms.trim());\n  return `(${matchExactly ? escapedTerms : termsToRegExpString(escapedTerms)})`;\n};\nconst buildRegexp = ({\n  terms,\n  matchExactly = false\n}) => {\n  try {\n    const fromString = /^([/~@;%#'])(.*?)\\1([gimsuy]*)$/.exec(terms);\n    if (fromString) {\n      return new RegExp(fromString[2], fromString[3]);\n    }\n    return new RegExp(regexpQuery({ terms, matchExactly }), \"ig\");\n  } catch (e) {\n    throw new TypeError(\"Expected terms to be either a string or a RegExp!\");\n  }\n};\n\nconst hasProp = (prop) => (obj) => obj !== null && typeof obj === \"object\" && prop in obj;\nconst hasMatch = hasProp(\"match\");\nconst chunkExists = (chunk) => typeof chunk !== \"undefined\";\nfunction clip({\n  curr,\n  next,\n  prev,\n  clipBy = 3\n}) {\n  const words = curr.text.split(\" \");\n  const len = words.length;\n  if (curr.match || clipBy >= len) {\n    return curr.text;\n  }\n  const ellipsis = \"...\";\n  if (chunkExists(next) && chunkExists(prev) && hasMatch(prev) && hasMatch(next)) {\n    if (len > clipBy * 2) {\n      return [\n        ...words.slice(0, clipBy),\n        ellipsis,\n        ...words.slice(-clipBy)\n      ].join(\" \");\n    }\n    return curr.text;\n  }\n  if (chunkExists(next) && hasMatch(next)) {\n    return [ellipsis, ...words.slice(-clipBy)].join(\" \");\n  }\n  if (chunkExists(prev) && hasMatch(prev)) {\n    return [...words.slice(0, clipBy), ellipsis].join(\" \");\n  }\n  return curr.text;\n}\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst hasLength = (str) => str.length > 0;\nconst highlightWords = ({\n  text,\n  query,\n  clipBy,\n  matchExactly = false\n}) => {\n  const safeQuery = typeof query === \"string\" ? query.trim() : query;\n  if (safeQuery === \"\") {\n    return [\n      {\n        key: uid(),\n        text,\n        match: false\n      }\n    ];\n  }\n  const searchRegexp = buildRegexp({ terms: query, matchExactly });\n  return text.split(searchRegexp).filter(hasLength).map((str) => ({\n    // Compose the object for a match\n    key: uid(),\n    text: str,\n    match: matchExactly ? str.toLowerCase() === safeQuery.toLowerCase() : searchRegexp.test(str)\n  })).map((chunk, index, chunks) => __spreadValues(__spreadValues({}, chunk), typeof clipBy === \"number\" && {\n    // We only overwrite the text if there is a clip\n    text: clip(__spreadProps(__spreadValues(__spreadValues({\n      curr: chunk\n    }, index < chunks.length - 1 && { next: chunks[index + 1] }), index > 0 && { prev: chunks[index - 1] }), {\n      // If this wasn't the first chunk, set the previous chunk\n      clipBy\n    }))\n  }));\n};\n\nexport { highlightWords as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}